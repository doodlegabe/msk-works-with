<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>tinymce-9f05d2fb98336e9a1ec1f242532b9e54a3fded58d81795b31412a7ca2b83ab62.js</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>
    <div class="banner">
        
        <h1>
            tinymce-9f05d2fb98336e9a1ec1f242532b9e54a3fded58d81795b31412a7ca2b83ab62.js
        </h1>
        <ul class="files">
            <li>public/assets/tinymce/tinymce-9f05d2fb98336e9a1ec1f242532b9e54a3fded58d81795b31412a7ca2b83ab62.js</li>
            <li>Last modified: 2018-12-04 12:31:01 -0500</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>// 4.9.0 (2018-11-27) (function () { (function () {</p>

<pre><code>&#39;use strict&#39;;

var noop = function () {
  var args = [];
  for (var _i = 0; _i &lt; arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
};
var compose = function (fa, fb) {
  return function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return fa(fb.apply(null, args));
  };
};
var constant = function (value) {
  return function () {
    return value;
  };
};
var identity = function (x) {
  return x;
};
function curry(fn) {
  var initialArgs = [];
  for (var _i = 1; _i &lt; arguments.length; _i++) {
    initialArgs[_i - 1] = arguments[_i];
  }
  return function () {
    var restArgs = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
      restArgs[_i] = arguments[_i];
    }
    var all = initialArgs.concat(restArgs);
    return fn.apply(null, all);
  };
}
var not = function (f) {
  return function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return !f.apply(null, args);
  };
};
var die = function (msg) {
  return function () {
    throw new Error(msg);
  };
};
var never = constant(false);
var always = constant(true);

var never$1 = never;
var always$1 = always;
var none = function () {
  return NONE;
};
var NONE = function () {
  var eq = function (o) {
    return o.isNone();
  };
  var call$$1 = function (thunk) {
    return thunk();
  };
  var id = function (n) {
    return n;
  };
  var noop$$1 = function () {
  };
  var nul = function () {
    return null;
  };
  var undef = function () {
    return undefined;
  };
  var me = {
    fold: function (n, s) {
      return n();
    },
    is: never$1,
    isSome: never$1,
    isNone: always$1,
    getOr: id,
    getOrThunk: call$$1,
    getOrDie: function (msg) {
      throw new Error(msg || &#39;error: getOrDie called on none.&#39;);
    },
    getOrNull: nul,
    getOrUndefined: undef,
    or: id,
    orThunk: call$$1,
    map: none,
    ap: none,
    each: noop$$1,
    bind: none,
    flatten: none,
    exists: never$1,
    forall: always$1,
    filter: none,
    equals: eq,
    equals_: eq,
    toArray: function () {
      return [];
    },
    toString: constant(&#39;none()&#39;)
  };
  if (Object.freeze)
    Object.freeze(me);
  return me;
}();
var some = function (a) {
  var constant_a = function () {
    return a;
  };
  var self = function () {
    return me;
  };
  var map = function (f) {
    return some(f(a));
  };
  var bind = function (f) {
    return f(a);
  };
  var me = {
    fold: function (n, s) {
      return s(a);
    },
    is: function (v) {
      return a === v;
    },
    isSome: always$1,
    isNone: never$1,
    getOr: constant_a,
    getOrThunk: constant_a,
    getOrDie: constant_a,
    getOrNull: constant_a,
    getOrUndefined: constant_a,
    or: self,
    orThunk: self,
    map: map,
    ap: function (optfab) {
      return optfab.fold(none, function (fab) {
        return some(fab(a));
      });
    },
    each: function (f) {
      f(a);
    },
    bind: bind,
    flatten: constant_a,
    exists: bind,
    forall: bind,
    filter: function (f) {
      return f(a) ? me : NONE;
    },
    equals: function (o) {
      return o.is(a);
    },
    equals_: function (o, elementEq) {
      return o.fold(never$1, function (b) {
        return elementEq(a, b);
      });
    },
    toArray: function () {
      return [a];
    },
    toString: function () {
      return &#39;some(&#39; + a + &#39;)&#39;;
    }
  };
  return me;
};
var from = function (value) {
  return value === null || value === undefined ? NONE : some(value);
};
var Option = {
  some: some,
  none: none,
  from: from
};

var typeOf = function (x) {
  if (x === null)
    return &#39;null&#39;;
  var t = typeof x;
  if (t === &#39;object&#39; &amp;&amp; Array.prototype.isPrototypeOf(x))
    return &#39;array&#39;;
  if (t === &#39;object&#39; &amp;&amp; String.prototype.isPrototypeOf(x))
    return &#39;string&#39;;
  return t;
};
var isType = function (type) {
  return function (value) {
    return typeOf(value) === type;
  };
};
var isString = isType(&#39;string&#39;);
var isObject = isType(&#39;object&#39;);
var isArray = isType(&#39;array&#39;);
var isNull = isType(&#39;null&#39;);
var isBoolean = isType(&#39;boolean&#39;);
var isFunction = isType(&#39;function&#39;);
var isNumber = isType(&#39;number&#39;);

var rawIndexOf = function () {
  var pIndexOf = Array.prototype.indexOf;
  var fastIndex = function (xs, x) {
    return pIndexOf.call(xs, x);
  };
  var slowIndex = function (xs, x) {
    return slowIndexOf(xs, x);
  };
  return pIndexOf === undefined ? slowIndex : fastIndex;
}();
var indexOf = function (xs, x) {
  var r = rawIndexOf(xs, x);
  return r === -1 ? Option.none() : Option.some(r);
};
var contains = function (xs, x) {
  return rawIndexOf(xs, x) &gt; -1;
};
var exists = function (xs, pred) {
  return findIndex(xs, pred).isSome();
};
var map = function (xs, f) {
  var len = xs.length;
  var r = new Array(len);
  for (var i = 0; i &lt; len; i++) {
    var x = xs[i];
    r[i] = f(x, i, xs);
  }
  return r;
};
var each = function (xs, f) {
  for (var i = 0, len = xs.length; i &lt; len; i++) {
    var x = xs[i];
    f(x, i, xs);
  }
};
var eachr = function (xs, f) {
  for (var i = xs.length - 1; i &gt;= 0; i--) {
    var x = xs[i];
    f(x, i, xs);
  }
};
var partition = function (xs, pred) {
  var pass = [];
  var fail = [];
  for (var i = 0, len = xs.length; i &lt; len; i++) {
    var x = xs[i];
    var arr = pred(x, i, xs) ? pass : fail;
    arr.push(x);
  }
  return {
    pass: pass,
    fail: fail
  };
};
var filter = function (xs, pred) {
  var r = [];
  for (var i = 0, len = xs.length; i &lt; len; i++) {
    var x = xs[i];
    if (pred(x, i, xs)) {
      r.push(x);
    }
  }
  return r;
};
var foldr = function (xs, f, acc) {
  eachr(xs, function (x) {
    acc = f(acc, x);
  });
  return acc;
};
var foldl = function (xs, f, acc) {
  each(xs, function (x) {
    acc = f(acc, x);
  });
  return acc;
};
var find = function (xs, pred) {
  for (var i = 0, len = xs.length; i &lt; len; i++) {
    var x = xs[i];
    if (pred(x, i, xs)) {
      return Option.some(x);
    }
  }
  return Option.none();
};
var findIndex = function (xs, pred) {
  for (var i = 0, len = xs.length; i &lt; len; i++) {
    var x = xs[i];
    if (pred(x, i, xs)) {
      return Option.some(i);
    }
  }
  return Option.none();
};
var slowIndexOf = function (xs, x) {
  for (var i = 0, len = xs.length; i &lt; len; ++i) {
    if (xs[i] === x) {
      return i;
    }
  }
  return -1;
};
var push = Array.prototype.push;
var flatten = function (xs) {
  var r = [];
  for (var i = 0, len = xs.length; i &lt; len; ++i) {
    if (!Array.prototype.isPrototypeOf(xs[i]))
      throw new Error(&#39;Arr.flatten item &#39; + i + &#39; was not an array, input: &#39; + xs);
    push.apply(r, xs[i]);
  }
  return r;
};
var bind = function (xs, f) {
  var output = map(xs, f);
  return flatten(output);
};
var forall = function (xs, pred) {
  for (var i = 0, len = xs.length; i &lt; len; ++i) {
    var x = xs[i];
    if (pred(x, i, xs) !== true) {
      return false;
    }
  }
  return true;
};
var slice = Array.prototype.slice;
var reverse = function (xs) {
  var r = slice.call(xs, 0);
  r.reverse();
  return r;
};
var difference = function (a1, a2) {
  return filter(a1, function (x) {
    return !contains(a2, x);
  });
};
var mapToObject = function (xs, f) {
  var r = {};
  for (var i = 0, len = xs.length; i &lt; len; i++) {
    var x = xs[i];
    r[String(x)] = f(x, i);
  }
  return r;
};
var sort = function (xs, comparator) {
  var copy = slice.call(xs, 0);
  copy.sort(comparator);
  return copy;
};
var head = function (xs) {
  return xs.length === 0 ? Option.none() : Option.some(xs[0]);
};
var last = function (xs) {
  return xs.length === 0 ? Option.none() : Option.some(xs[xs.length - 1]);
};
var from$1 = isFunction(Array.from) ? Array.from : function (x) {
  return slice.call(x);
};

var Global = typeof window !== &#39;undefined&#39; ? window : Function(&#39;return this;&#39;)();

var path = function (parts, scope) {
  var o = scope !== undefined &amp;&amp; scope !== null ? scope : Global;
  for (var i = 0; i &lt; parts.length &amp;&amp; o !== undefined &amp;&amp; o !== null; ++i)
    o = o[parts[i]];
  return o;
};
var resolve = function (p, scope) {
  var parts = p.split(&#39;.&#39;);
  return path(parts, scope);
};

var unsafe = function (name, scope) {
  return resolve(name, scope);
};
var getOrDie = function (name, scope) {
  var actual = unsafe(name, scope);
  if (actual === undefined || actual === null)
    throw name + &#39; not available on this browser&#39;;
  return actual;
};
var Global$1 = { getOrDie: getOrDie };

var url = function () {
  return Global$1.getOrDie(&#39;URL&#39;);
};
var createObjectURL = function (blob) {
  return url().createObjectURL(blob);
};
var revokeObjectURL = function (u) {
  url().revokeObjectURL(u);
};
var URL = {
  createObjectURL: createObjectURL,
  revokeObjectURL: revokeObjectURL
};

var nav = navigator, userAgent = nav.userAgent;
var opera, webkit, ie, ie11, ie12, gecko, mac, iDevice, android, fileApi, phone, tablet, windowsPhone;
var matchMediaQuery = function (query) {
  return &#39;matchMedia&#39; in window ? matchMedia(query).matches : false;
};
opera = false;
android = /Android/.test(userAgent);
webkit = /WebKit/.test(userAgent);
ie = !webkit &amp;&amp; !opera &amp;&amp; /MSIE/gi.test(userAgent) &amp;&amp; /Explorer/gi.test(nav.appName);
ie = ie &amp;&amp; /MSIE (\w+)\./.exec(userAgent)[1];
ie11 = userAgent.indexOf(&#39;Trident/&#39;) !== -1 &amp;&amp; (userAgent.indexOf(&#39;rv:&#39;) !== -1 || nav.appName.indexOf(&#39;Netscape&#39;) !== -1) ? 11 : false;
ie12 = userAgent.indexOf(&#39;Edge/&#39;) !== -1 &amp;&amp; !ie &amp;&amp; !ie11 ? 12 : false;
ie = ie || ie11 || ie12;
gecko = !webkit &amp;&amp; !ie11 &amp;&amp; /Gecko/.test(userAgent);
mac = userAgent.indexOf(&#39;Mac&#39;) !== -1;
iDevice = /(iPad|iPhone)/.test(userAgent);
fileApi = &#39;FormData&#39; in window &amp;&amp; &#39;FileReader&#39; in window &amp;&amp; &#39;URL&#39; in window &amp;&amp; !!URL.createObjectURL;
phone = matchMediaQuery(&#39;only screen and (max-device-width: 480px)&#39;) &amp;&amp; (android || iDevice);
tablet = matchMediaQuery(&#39;only screen and (min-width: 800px)&#39;) &amp;&amp; (android || iDevice);
windowsPhone = userAgent.indexOf(&#39;Windows Phone&#39;) !== -1;
if (ie12) {
  webkit = false;
}
var contentEditable = !iDevice || fileApi || parseInt(userAgent.match(/AppleWebKit\/(\d*)/)[1], 10) &gt;= 534;
var Env = {
  opera: opera,
  webkit: webkit,
  ie: ie,
  gecko: gecko,
  mac: mac,
  iOS: iDevice,
  android: android,
  contentEditable: contentEditable,
  transparentSrc: &#39;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&#39;,
  caretAfter: ie !== 8,
  range: window.getSelection &amp;&amp; &#39;Range&#39; in window,
  documentMode: ie &amp;&amp; !ie12 ? document.documentMode || 7 : 10,
  fileApi: fileApi,
  ceFalse: ie === false || ie &gt; 8,
  cacheSuffix: null,
  container: null,
  overrideViewPort: null,
  experimentalShadowDom: false,
  canHaveCSP: ie === false || ie &gt; 11,
  desktop: !phone &amp;&amp; !tablet,
  windowsPhone: windowsPhone
};

var promise = function () {
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }
  var isArray = Array.isArray || function (value) {
    return Object.prototype.toString.call(value) === &#39;[object Array]&#39;;
  };
  var Promise = function (fn) {
    if (typeof this !== &#39;object&#39;) {
      throw new TypeError(&#39;Promises must be constructed via new&#39;);
    }
    if (typeof fn !== &#39;function&#39;) {
      throw new TypeError(&#39;not a function&#39;);
    }
    this._state = null;
    this._value = null;
    this._deferreds = [];
    doResolve(fn, bind(resolve, this), bind(reject, this));
  };
  var asap = Promise.immediateFn || typeof setImmediate === &#39;function&#39; &amp;&amp; setImmediate || function (fn) {
    setTimeout(fn, 1);
  };
  function handle(deferred) {
    var me = this;
    if (this._state === null) {
      this._deferreds.push(deferred);
      return;
    }
    asap(function () {
      var cb = me._state ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (me._state ? deferred.resolve : deferred.reject)(me._value);
        return;
      }
      var ret;
      try {
        ret = cb(me._value);
      } catch (e) {
        deferred.reject(e);
        return;
      }
      deferred.resolve(ret);
    });
  }
  function resolve(newValue) {
    try {
      if (newValue === this) {
        throw new TypeError(&#39;A promise cannot be resolved with itself.&#39;);
      }
      if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) {
        var then = newValue.then;
        if (typeof then === &#39;function&#39;) {
          doResolve(bind(then, newValue), bind(resolve, this), bind(reject, this));
          return;
        }
      }
      this._state = true;
      this._value = newValue;
      finale.call(this);
    } catch (e) {
      reject.call(this, e);
    }
  }
  function reject(newValue) {
    this._state = false;
    this._value = newValue;
    finale.call(this);
  }
  function finale() {
    for (var i = 0, len = this._deferreds.length; i &lt; len; i++) {
      handle.call(this, this._deferreds[i]);
    }
    this._deferreds = null;
  }
  function Handler(onFulfilled, onRejected, resolve, reject) {
    this.onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : null;
    this.onRejected = typeof onRejected === &#39;function&#39; ? onRejected : null;
    this.resolve = resolve;
    this.reject = reject;
  }
  function doResolve(fn, onFulfilled, onRejected) {
    var done = false;
    try {
      fn(function (value) {
        if (done) {
          return;
        }
        done = true;
        onFulfilled(value);
      }, function (reason) {
        if (done) {
          return;
        }
        done = true;
        onRejected(reason);
      });
    } catch (ex) {
      if (done) {
        return;
      }
      done = true;
      onRejected(ex);
    }
  }
  Promise.prototype.catch = function (onRejected) {
    return this.then(null, onRejected);
  };
  Promise.prototype.then = function (onFulfilled, onRejected) {
    var me = this;
    return new Promise(function (resolve, reject) {
      handle.call(me, new Handler(onFulfilled, onRejected, resolve, reject));
    });
  };
  Promise.all = function () {
    var args = Array.prototype.slice.call(arguments.length === 1 &amp;&amp; isArray(arguments[0]) ? arguments[0] : arguments);
    return new Promise(function (resolve, reject) {
      if (args.length === 0) {
        return resolve([]);
      }
      var remaining = args.length;
      function res(i, val) {
        try {
          if (val &amp;&amp; (typeof val === &#39;object&#39; || typeof val === &#39;function&#39;)) {
            var then = val.then;
            if (typeof then === &#39;function&#39;) {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }
      for (var i = 0; i &lt; args.length; i++) {
        res(i, args[i]);
      }
    });
  };
  Promise.resolve = function (value) {
    if (value &amp;&amp; typeof value === &#39;object&#39; &amp;&amp; value.constructor === Promise) {
      return value;
    }
    return new Promise(function (resolve) {
      resolve(value);
    });
  };
  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };
  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i &lt; len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };
  return Promise;
};
var promiseObj = window.Promise ? window.Promise : promise();

var requestAnimationFramePromise;
var requestAnimationFrame$$1 = function (callback, element) {
  var i, requestAnimationFrameFunc = window.requestAnimationFrame;
  var vendors = [
    &#39;ms&#39;,
    &#39;moz&#39;,
    &#39;webkit&#39;
  ];
  var featurefill = function (callback) {
    window.setTimeout(callback, 0);
  };
  for (i = 0; i &lt; vendors.length &amp;&amp; !requestAnimationFrameFunc; i++) {
    requestAnimationFrameFunc = window[vendors[i] + &#39;RequestAnimationFrame&#39;];
  }
  if (!requestAnimationFrameFunc) {
    requestAnimationFrameFunc = featurefill;
  }
  requestAnimationFrameFunc(callback, element);
};
var wrappedSetTimeout = function (callback, time) {
  if (typeof time !== &#39;number&#39;) {
    time = 0;
  }
  return setTimeout(callback, time);
};
var wrappedSetInterval = function (callback, time) {
  if (typeof time !== &#39;number&#39;) {
    time = 1;
  }
  return setInterval(callback, time);
};
var wrappedClearTimeout = function (id) {
  return clearTimeout(id);
};
var wrappedClearInterval = function (id) {
  return clearInterval(id);
};
var debounce = function (callback, time) {
  var timer, func;
  func = function () {
    var args = arguments;
    clearTimeout(timer);
    timer = wrappedSetTimeout(function () {
      callback.apply(this, args);
    }, time);
  };
  func.stop = function () {
    clearTimeout(timer);
  };
  return func;
};
var Delay = {
  requestAnimationFrame: function (callback, element) {
    if (requestAnimationFramePromise) {
      requestAnimationFramePromise.then(callback);
      return;
    }
    requestAnimationFramePromise = new promiseObj(function (resolve) {
      if (!element) {
        element = document.body;
      }
      requestAnimationFrame$$1(resolve, element);
    }).then(callback);
  },
  setTimeout: wrappedSetTimeout,
  setInterval: wrappedSetInterval,
  setEditorTimeout: function (editor, callback, time) {
    return wrappedSetTimeout(function () {
      if (!editor.removed) {
        callback();
      }
    }, time);
  },
  setEditorInterval: function (editor, callback, time) {
    var timer;
    timer = wrappedSetInterval(function () {
      if (!editor.removed) {
        callback();
      } else {
        clearInterval(timer);
      }
    }, time);
    return timer;
  },
  debounce: debounce,
  throttle: debounce,
  clearInterval: wrappedClearInterval,
  clearTimeout: wrappedClearTimeout
};

var eventExpandoPrefix = &#39;mce-data-&#39;;
var mouseEventRe = /^(?:mouse|contextmenu)|click/;
var deprecated = {
  keyLocation: 1,
  layerX: 1,
  layerY: 1,
  returnValue: 1,
  webkitMovementX: 1,
  webkitMovementY: 1,
  keyIdentifier: 1
};
var hasIsDefaultPrevented = function (event$$1) {
  return event$$1.isDefaultPrevented === returnTrue || event$$1.isDefaultPrevented === returnFalse;
};
var returnFalse = function () {
  return false;
};
var returnTrue = function () {
  return true;
};
var addEvent = function (target, name$$1, callback, capture) {
  if (target.addEventListener) {
    target.addEventListener(name$$1, callback, capture || false);
  } else if (target.attachEvent) {
    target.attachEvent(&#39;on&#39; + name$$1, callback);
  }
};
var removeEvent = function (target, name$$1, callback, capture) {
  if (target.removeEventListener) {
    target.removeEventListener(name$$1, callback, capture || false);
  } else if (target.detachEvent) {
    target.detachEvent(&#39;on&#39; + name$$1, callback);
  }
};
var getTargetFromShadowDom = function (event$$1, defaultTarget) {
  if (event$$1.composedPath) {
    var composedPath = event$$1.composedPath();
    if (composedPath &amp;&amp; composedPath.length &gt; 0) {
      return composedPath[0];
    }
  }
  return defaultTarget;
};
var fix = function (originalEvent, data) {
  var name$$1;
  var event$$1 = data || {};
  for (name$$1 in originalEvent) {
    if (!deprecated[name$$1]) {
      event$$1[name$$1] = originalEvent[name$$1];
    }
  }
  if (!event$$1.target) {
    event$$1.target = event$$1.srcElement || document;
  }
  if (Env.experimentalShadowDom) {
    event$$1.target = getTargetFromShadowDom(originalEvent, event$$1.target);
  }
  if (originalEvent &amp;&amp; mouseEventRe.test(originalEvent.type) &amp;&amp; originalEvent.pageX === undefined &amp;&amp; originalEvent.clientX !== undefined) {
    var eventDoc = event$$1.target.ownerDocument || document;
    var doc = eventDoc.documentElement;
    var body = eventDoc.body;
    event$$1.pageX = originalEvent.clientX + (doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0) - (doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0);
    event$$1.pageY = originalEvent.clientY + (doc &amp;&amp; doc.scrollTop || body &amp;&amp; body.scrollTop || 0) - (doc &amp;&amp; doc.clientTop || body &amp;&amp; body.clientTop || 0);
  }
  event$$1.preventDefault = function () {
    event$$1.isDefaultPrevented = returnTrue;
    if (originalEvent) {
      if (originalEvent.preventDefault) {
        originalEvent.preventDefault();
      } else {
        originalEvent.returnValue = false;
      }
    }
  };
  event$$1.stopPropagation = function () {
    event$$1.isPropagationStopped = returnTrue;
    if (originalEvent) {
      if (originalEvent.stopPropagation) {
        originalEvent.stopPropagation();
      } else {
        originalEvent.cancelBubble = true;
      }
    }
  };
  event$$1.stopImmediatePropagation = function () {
    event$$1.isImmediatePropagationStopped = returnTrue;
    event$$1.stopPropagation();
  };
  if (hasIsDefaultPrevented(event$$1) === false) {
    event$$1.isDefaultPrevented = returnFalse;
    event$$1.isPropagationStopped = returnFalse;
    event$$1.isImmediatePropagationStopped = returnFalse;
  }
  if (typeof event$$1.metaKey === &#39;undefined&#39;) {
    event$$1.metaKey = false;
  }
  return event$$1;
};
var bindOnReady = function (win, callback, eventUtils) {
  var doc = win.document, event$$1 = { type: &#39;ready&#39; };
  if (eventUtils.domLoaded) {
    callback(event$$1);
    return;
  }
  var isDocReady = function () {
    return doc.readyState === &#39;complete&#39; || doc.readyState === &#39;interactive&#39; &amp;&amp; doc.body;
  };
  var readyHandler = function () {
    if (!eventUtils.domLoaded) {
      eventUtils.domLoaded = true;
      callback(event$$1);
    }
  };
  var waitForDomLoaded = function () {
    if (isDocReady()) {
      removeEvent(doc, &#39;readystatechange&#39;, waitForDomLoaded);
      readyHandler();
    }
  };
  var tryScroll = function () {
    try {
      doc.documentElement.doScroll(&#39;left&#39;);
    } catch (ex) {
      Delay.setTimeout(tryScroll);
      return;
    }
    readyHandler();
  };
  if (doc.addEventListener &amp;&amp; !(Env.ie &amp;&amp; Env.ie &lt; 11)) {
    if (isDocReady()) {
      readyHandler();
    } else {
      addEvent(win, &#39;DOMContentLoaded&#39;, readyHandler);
    }
  } else {
    addEvent(doc, &#39;readystatechange&#39;, waitForDomLoaded);
    if (doc.documentElement.doScroll &amp;&amp; win.self === win.top) {
      tryScroll();
    }
  }
  addEvent(win, &#39;load&#39;, readyHandler);
};
var EventUtils = function () {
  var self$$1 = this;
  var events = {}, count, expando, hasFocusIn, hasMouseEnterLeave, mouseEnterLeave;
  expando = eventExpandoPrefix + (+new Date()).toString(32);
  hasMouseEnterLeave = &#39;onmouseenter&#39; in document.documentElement;
  hasFocusIn = &#39;onfocusin&#39; in document.documentElement;
  mouseEnterLeave = {
    mouseenter: &#39;mouseover&#39;,
    mouseleave: &#39;mouseout&#39;
  };
  count = 1;
  self$$1.domLoaded = false;
  self$$1.events = events;
  var executeHandlers = function (evt, id) {
    var callbackList, i, l, callback;
    var container = events[id];
    callbackList = container &amp;&amp; container[evt.type];
    if (callbackList) {
      for (i = 0, l = callbackList.length; i &lt; l; i++) {
        callback = callbackList[i];
        if (callback &amp;&amp; callback.func.call(callback.scope, evt) === false) {
          evt.preventDefault();
        }
        if (evt.isImmediatePropagationStopped()) {
          return;
        }
      }
    }
  };
  self$$1.bind = function (target, names, callback, scope) {
    var id, callbackList, i, name$$1, fakeName, nativeHandler, capture;
    var win = window;
    var defaultNativeHandler = function (evt) {
      executeHandlers(fix(evt || win.event), id);
    };
    if (!target || target.nodeType === 3 || target.nodeType === 8) {
      return;
    }
    if (!target[expando]) {
      id = count++;
      target[expando] = id;
      events[id] = {};
    } else {
      id = target[expando];
    }
    scope = scope || target;
    names = names.split(&#39; &#39;);
    i = names.length;
    while (i--) {
      name$$1 = names[i];
      nativeHandler = defaultNativeHandler;
      fakeName = capture = false;
      if (name$$1 === &#39;DOMContentLoaded&#39;) {
        name$$1 = &#39;ready&#39;;
      }
      if (self$$1.domLoaded &amp;&amp; name$$1 === &#39;ready&#39; &amp;&amp; target.readyState === &#39;complete&#39;) {
        callback.call(scope, fix({ type: name$$1 }));
        continue;
      }
      if (!hasMouseEnterLeave) {
        fakeName = mouseEnterLeave[name$$1];
        if (fakeName) {
          nativeHandler = function (evt) {
            var current, related;
            current = evt.currentTarget;
            related = evt.relatedTarget;
            if (related &amp;&amp; current.contains) {
              related = current.contains(related);
            } else {
              while (related &amp;&amp; related !== current) {
                related = related.parentNode;
              }
            }
            if (!related) {
              evt = fix(evt || win.event);
              evt.type = evt.type === &#39;mouseout&#39; ? &#39;mouseleave&#39; : &#39;mouseenter&#39;;
              evt.target = current;
              executeHandlers(evt, id);
            }
          };
        }
      }
      if (!hasFocusIn &amp;&amp; (name$$1 === &#39;focusin&#39; || name$$1 === &#39;focusout&#39;)) {
        capture = true;
        fakeName = name$$1 === &#39;focusin&#39; ? &#39;focus&#39; : &#39;blur&#39;;
        nativeHandler = function (evt) {
          evt = fix(evt || win.event);
          evt.type = evt.type === &#39;focus&#39; ? &#39;focusin&#39; : &#39;focusout&#39;;
          executeHandlers(evt, id);
        };
      }
      callbackList = events[id][name$$1];
      if (!callbackList) {
        events[id][name$$1] = callbackList = [{
            func: callback,
            scope: scope
          }];
        callbackList.fakeName = fakeName;
        callbackList.capture = capture;
        callbackList.nativeHandler = nativeHandler;
        if (name$$1 === &#39;ready&#39;) {
          bindOnReady(target, nativeHandler, self$$1);
        } else {
          addEvent(target, fakeName || name$$1, nativeHandler, capture);
        }
      } else {
        if (name$$1 === &#39;ready&#39; &amp;&amp; self$$1.domLoaded) {
          callback({ type: name$$1 });
        } else {
          callbackList.push({
            func: callback,
            scope: scope
          });
        }
      }
    }
    target = callbackList = 0;
    return callback;
  };
  self$$1.unbind = function (target, names, callback) {
    var id, callbackList, i, ci, name$$1, eventMap;
    if (!target || target.nodeType === 3 || target.nodeType === 8) {
      return self$$1;
    }
    id = target[expando];
    if (id) {
      eventMap = events[id];
      if (names) {
        names = names.split(&#39; &#39;);
        i = names.length;
        while (i--) {
          name$$1 = names[i];
          callbackList = eventMap[name$$1];
          if (callbackList) {
            if (callback) {
              ci = callbackList.length;
              while (ci--) {
                if (callbackList[ci].func === callback) {
                  var nativeHandler = callbackList.nativeHandler;
                  var fakeName = callbackList.fakeName, capture = callbackList.capture;
                  callbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                  callbackList.nativeHandler = nativeHandler;
                  callbackList.fakeName = fakeName;
                  callbackList.capture = capture;
                  eventMap[name$$1] = callbackList;
                }
              }
            }
            if (!callback || callbackList.length === 0) {
              delete eventMap[name$$1];
              removeEvent(target, callbackList.fakeName || name$$1, callbackList.nativeHandler, callbackList.capture);
            }
          }
        }
      } else {
        for (name$$1 in eventMap) {
          callbackList = eventMap[name$$1];
          removeEvent(target, callbackList.fakeName || name$$1, callbackList.nativeHandler, callbackList.capture);
        }
        eventMap = {};
      }
      for (name$$1 in eventMap) {
        return self$$1;
      }
      delete events[id];
      try {
        delete target[expando];
      } catch (ex) {
        target[expando] = null;
      }
    }
    return self$$1;
  };
  self$$1.fire = function (target, name$$1, args) {
    var id;
    if (!target || target.nodeType === 3 || target.nodeType === 8) {
      return self$$1;
    }
    args = fix(null, args);
    args.type = name$$1;
    args.target = target;
    do {
      id = target[expando];
      if (id) {
        executeHandlers(args, id);
      }
      target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
    } while (target &amp;&amp; !args.isPropagationStopped());
    return self$$1;
  };
  self$$1.clean = function (target) {
    var i, children;
    var unbind = self$$1.unbind;
    if (!target || target.nodeType === 3 || target.nodeType === 8) {
      return self$$1;
    }
    if (target[expando]) {
      unbind(target);
    }
    if (!target.getElementsByTagName) {
      target = target.document;
    }
    if (target &amp;&amp; target.getElementsByTagName) {
      unbind(target);
      children = target.getElementsByTagName(&#39;*&#39;);
      i = children.length;
      while (i--) {
        target = children[i];
        if (target[expando]) {
          unbind(target);
        }
      }
    }
    return self$$1;
  };
  self$$1.destroy = function () {
    events = {};
  };
  self$$1.cancel = function (e) {
    if (e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
    return false;
  };
};
EventUtils.Event = new EventUtils();
EventUtils.Event.bind(window, &#39;ready&#39;, function () {
});

var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document$1, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains$1, expando = &#39;sizzle&#39; + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
    if (a === b) {
      hasDuplicate = true;
    }
    return 0;
  }, strundefined = typeof undefined, MAX_NEGATIVE = 1 &lt;&lt; 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push$1 = arr.push, slice$1 = arr.slice, indexOf$1 = arr.indexOf || function (elem) {
    var i = 0, len = this.length;
    for (; i &lt; len; i++) {
      if (this[i] === elem) {
        return i;
      }
    }
    return -1;
  }, booleans = &#39;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&#39;, whitespace = &#39;[\\x20\\t\\r\\n\\f]&#39;, identifier = &#39;(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+&#39;, attributes = &#39;\\[&#39; + whitespace + &#39;*(&#39; + identifier + &#39;)(?:&#39; + whitespace + &#39;*([*^$|!~]?=)&#39; + whitespace + &#39;*(?:\&#39;((?:\\\\.|[^\\\\\&#39;])*)\&#39;|&quot;((?:\\\\.|[^\\\\&quot;])*)&quot;|(&#39; + identifier + &#39;))|)&#39; + whitespace + &#39;*\\]&#39;, pseudos = &#39;:(&#39; + identifier + &#39;)(?:\\((&#39; + &#39;(\&#39;((?:\\\\.|[^\\\\\&#39;])*)\&#39;|&quot;((?:\\\\.|[^\\\\&quot;])*)&quot;)|&#39; + &#39;((?:\\\\.|[^\\\\()[\\]]|&#39; + attributes + &#39;)*)|&#39; + &#39;.*&#39; + &#39;)\\)|)&#39;, rtrim = new RegExp(&#39;^&#39; + whitespace + &#39;+|((?:^|[^\\\\])(?:\\\\.)*)&#39; + whitespace + &#39;+$&#39;, &#39;g&#39;), rcomma = new RegExp(&#39;^&#39; + whitespace + &#39;*,&#39; + whitespace + &#39;*&#39;), rcombinators = new RegExp(&#39;^&#39; + whitespace + &#39;*([&gt;+~]|&#39; + whitespace + &#39;)&#39; + whitespace + &#39;*&#39;), rattributeQuotes = new RegExp(&#39;=&#39; + whitespace + &#39;*([^\\]\&#39;&quot;]*?)&#39; + whitespace + &#39;*\\]&#39;, &#39;g&#39;), rpseudo = new RegExp(pseudos), ridentifier = new RegExp(&#39;^&#39; + identifier + &#39;$&#39;), matchExpr = {
    ID: new RegExp(&#39;^#(&#39; + identifier + &#39;)&#39;),
    CLASS: new RegExp(&#39;^\\.(&#39; + identifier + &#39;)&#39;),
    TAG: new RegExp(&#39;^(&#39; + identifier + &#39;|[*])&#39;),
    ATTR: new RegExp(&#39;^&#39; + attributes),
    PSEUDO: new RegExp(&#39;^&#39; + pseudos),
    CHILD: new RegExp(&#39;^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(&#39; + whitespace + &#39;*(even|odd|(([+-]|)(\\d*)n|)&#39; + whitespace + &#39;*(?:([+-]|)&#39; + whitespace + &#39;*(\\d+)|))&#39; + whitespace + &#39;*\\)|)&#39;, &#39;i&#39;),
    bool: new RegExp(&#39;^(?:&#39; + booleans + &#39;)$&#39;, &#39;i&#39;),
    needsContext: new RegExp(&#39;^&#39; + whitespace + &#39;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&#39; + whitespace + &#39;*((?:-\\d)?\\d*)&#39; + whitespace + &#39;*\\)|)(?=[^-]|$)&#39;, &#39;i&#39;)
  }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /&#39;|\\/g, runescape = new RegExp(&#39;\\\\([\\da-f]{1,6}&#39; + whitespace + &#39;?|(&#39; + whitespace + &#39;)|.)&#39;, &#39;ig&#39;), funescape = function (_, escaped, escapedWhitespace) {
    var high = &#39;0x&#39; + escaped - 65536;
    return high !== high || escapedWhitespace ? escaped : high &lt; 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high &gt;&gt; 10 | 55296, high &amp; 1023 | 56320);
  };
try {
  push$1.apply(arr = slice$1.call(preferredDoc.childNodes), preferredDoc.childNodes);
  arr[preferredDoc.childNodes.length].nodeType;
} catch (e) {
  push$1 = {
    apply: arr.length ? function (target, els) {
      push_native.apply(target, slice$1.call(els));
    } : function (target, els) {
      var j = target.length, i = 0;
      while (target[j++] = els[i++]) {
      }
      target.length = j - 1;
    }
  };
}
var Sizzle = function (selector, context, results, seed) {
  var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
  if ((context ? context.ownerDocument || context : preferredDoc) !== document$1) {
    setDocument(context);
  }
  context = context || document$1;
  results = results || [];
  if (!selector || typeof selector !== &#39;string&#39;) {
    return results;
  }
  if ((nodeType = context.nodeType) !== 1 &amp;&amp; nodeType !== 9) {
    return [];
  }
  if (documentIsHTML &amp;&amp; !seed) {
    if (match = rquickExpr.exec(selector)) {
      if (m = match[1]) {
        if (nodeType === 9) {
          elem = context.getElementById(m);
          if (elem &amp;&amp; elem.parentNode) {
            if (elem.id === m) {
              results.push(elem);
              return results;
            }
          } else {
            return results;
          }
        } else {
          if (context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById(m)) &amp;&amp; contains$1(context, elem) &amp;&amp; elem.id === m) {
            results.push(elem);
            return results;
          }
        }
      } else if (match[2]) {
        push$1.apply(results, context.getElementsByTagName(selector));
        return results;
      } else if ((m = match[3]) &amp;&amp; support.getElementsByClassName) {
        push$1.apply(results, context.getElementsByClassName(m));
        return results;
      }
    }
    if (support.qsa &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test(selector))) {
      nid = old = expando;
      newContext = context;
      newSelector = nodeType === 9 &amp;&amp; selector;
      if (nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &#39;object&#39;) {
        groups = tokenize(selector);
        if (old = context.getAttribute(&#39;id&#39;)) {
          nid = old.replace(rescape, &#39;\\$&amp;&#39;);
        } else {
          context.setAttribute(&#39;id&#39;, nid);
        }
        nid = &#39;[id=\&#39;&#39; + nid + &#39;\&#39;] &#39;;
        i = groups.length;
        while (i--) {
          groups[i] = nid + toSelector(groups[i]);
        }
        newContext = rsibling.test(selector) &amp;&amp; testContext(context.parentNode) || context;
        newSelector = groups.join(&#39;,&#39;);
      }
      if (newSelector) {
        try {
          push$1.apply(results, newContext.querySelectorAll(newSelector));
          return results;
        } catch (qsaError) {
        } finally {
          if (!old) {
            context.removeAttribute(&#39;id&#39;);
          }
        }
      }
    }
  }
  return select(selector.replace(rtrim, &#39;$1&#39;), context, results, seed);
};
function createCache() {
  var keys = [];
  function cache(key, value) {
    if (keys.push(key + &#39; &#39;) &gt; Expr.cacheLength) {
      delete cache[keys.shift()];
    }
    return cache[key + &#39; &#39;] = value;
  }
  return cache;
}
function markFunction(fn) {
  fn[expando] = true;
  return fn;
}
function siblingCheck(a, b) {
  var cur = b &amp;&amp; a, diff = cur &amp;&amp; a.nodeType === 1 &amp;&amp; b.nodeType === 1 &amp;&amp; (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
  if (diff) {
    return diff;
  }
  if (cur) {
    while (cur = cur.nextSibling) {
      if (cur === b) {
        return -1;
      }
    }
  }
  return a ? 1 : -1;
}
function createInputPseudo(type) {
  return function (elem) {
    var name$$1 = elem.nodeName.toLowerCase();
    return name$$1 === &#39;input&#39; &amp;&amp; elem.type === type;
  };
}
function createButtonPseudo(type) {
  return function (elem) {
    var name$$1 = elem.nodeName.toLowerCase();
    return (name$$1 === &#39;input&#39; || name$$1 === &#39;button&#39;) &amp;&amp; elem.type === type;
  };
}
function createPositionalPseudo(fn) {
  return markFunction(function (argument) {
    argument = +argument;
    return markFunction(function (seed, matches) {
      var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
      while (i--) {
        if (seed[j = matchIndexes[i]]) {
          seed[j] = !(matches[j] = seed[j]);
        }
      }
    });
  });
}
function testContext(context) {
  return context &amp;&amp; typeof context.getElementsByTagName !== strundefined &amp;&amp; context;
}
support = Sizzle.support = {};
isXML = Sizzle.isXML = function (elem) {
  var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
  return documentElement ? documentElement.nodeName !== &#39;HTML&#39; : false;
};
setDocument = Sizzle.setDocument = function (node) {
  var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent$$1 = doc.defaultView;
  function getTop(win) {
    try {
      return win.top;
    } catch (ex) {
    }
    return null;
  }
  if (doc === document$1 || doc.nodeType !== 9 || !doc.documentElement) {
    return document$1;
  }
  document$1 = doc;
  docElem = doc.documentElement;
  documentIsHTML = !isXML(doc);
  if (parent$$1 &amp;&amp; parent$$1 !== getTop(parent$$1)) {
    if (parent$$1.addEventListener) {
      parent$$1.addEventListener(&#39;unload&#39;, function () {
        setDocument();
      }, false);
    } else if (parent$$1.attachEvent) {
      parent$$1.attachEvent(&#39;onunload&#39;, function () {
        setDocument();
      });
    }
  }
  support.attributes = true;
  support.getElementsByTagName = true;
  support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
  support.getById = true;
  Expr.find.ID = function (id, context) {
    if (typeof context.getElementById !== strundefined &amp;&amp; documentIsHTML) {
      var m = context.getElementById(id);
      return m &amp;&amp; m.parentNode ? [m] : [];
    }
  };
  Expr.filter.ID = function (id) {
    var attrId = id.replace(runescape, funescape);
    return function (elem) {
      return elem.getAttribute(&#39;id&#39;) === attrId;
    };
  };
  Expr.find.TAG = support.getElementsByTagName ? function (tag, context) {
    if (typeof context.getElementsByTagName !== strundefined) {
      return context.getElementsByTagName(tag);
    }
  } : function (tag, context) {
    var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
    if (tag === &#39;*&#39;) {
      while (elem = results[i++]) {
        if (elem.nodeType === 1) {
          tmp.push(elem);
        }
      }
      return tmp;
    }
    return results;
  };
  Expr.find.CLASS = support.getElementsByClassName &amp;&amp; function (className, context) {
    if (documentIsHTML) {
      return context.getElementsByClassName(className);
    }
  };
  rbuggyMatches = [];
  rbuggyQSA = [];
  support.disconnectedMatch = true;
  rbuggyQSA = rbuggyQSA.length &amp;&amp; new RegExp(rbuggyQSA.join(&#39;|&#39;));
  rbuggyMatches = rbuggyMatches.length &amp;&amp; new RegExp(rbuggyMatches.join(&#39;|&#39;));
  hasCompare = rnative.test(docElem.compareDocumentPosition);
  contains$1 = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
    var adown = a.nodeType === 9 ? a.documentElement : a, bup = b &amp;&amp; b.parentNode;
    return a === bup || !!(bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (adown.contains ? adown.contains(bup) : a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition(bup) &amp; 16));
  } : function (a, b) {
    if (b) {
      while (b = b.parentNode) {
        if (b === a) {
          return true;
        }
      }
    }
    return false;
  };
  sortOrder = hasCompare ? function (a, b) {
    if (a === b) {
      hasDuplicate = true;
      return 0;
    }
    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
    if (compare) {
      return compare;
    }
    compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
    if (compare &amp; 1 || !support.sortDetached &amp;&amp; b.compareDocumentPosition(a) === compare) {
      if (a === doc || a.ownerDocument === preferredDoc &amp;&amp; contains$1(preferredDoc, a)) {
        return -1;
      }
      if (b === doc || b.ownerDocument === preferredDoc &amp;&amp; contains$1(preferredDoc, b)) {
        return 1;
      }
      return sortInput ? indexOf$1.call(sortInput, a) - indexOf$1.call(sortInput, b) : 0;
    }
    return compare &amp; 4 ? -1 : 1;
  } : function (a, b) {
    if (a === b) {
      hasDuplicate = true;
      return 0;
    }
    var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
    if (!aup || !bup) {
      return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf$1.call(sortInput, a) - indexOf$1.call(sortInput, b) : 0;
    } else if (aup === bup) {
      return siblingCheck(a, b);
    }
    cur = a;
    while (cur = cur.parentNode) {
      ap.unshift(cur);
    }
    cur = b;
    while (cur = cur.parentNode) {
      bp.unshift(cur);
    }
    while (ap[i] === bp[i]) {
      i++;
    }
    return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
  };
  return doc;
};
Sizzle.matches = function (expr, elements) {
  return Sizzle(expr, null, null, elements);
};
Sizzle.matchesSelector = function (elem, expr) {
  if ((elem.ownerDocument || elem) !== document$1) {
    setDocument(elem);
  }
  expr = expr.replace(rattributeQuotes, &#39;=\&#39;$1\&#39;]&#39;);
  if (support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp; (!rbuggyMatches || !rbuggyMatches.test(expr)) &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test(expr))) {
    try {
      var ret = matches.call(elem, expr);
      if (ret || support.disconnectedMatch || elem.document &amp;&amp; elem.document.nodeType !== 11) {
        return ret;
      }
    } catch (e) {
    }
  }
  return Sizzle(expr, document$1, null, [elem]).length &gt; 0;
};
Sizzle.contains = function (context, elem) {
  if ((context.ownerDocument || context) !== document$1) {
    setDocument(context);
  }
  return contains$1(context, elem);
};
Sizzle.attr = function (elem, name$$1) {
  if ((elem.ownerDocument || elem) !== document$1) {
    setDocument(elem);
  }
  var fn = Expr.attrHandle[name$$1.toLowerCase()], val = fn &amp;&amp; hasOwn.call(Expr.attrHandle, name$$1.toLowerCase()) ? fn(elem, name$$1, !documentIsHTML) : undefined;
  return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name$$1) : (val = elem.getAttributeNode(name$$1)) &amp;&amp; val.specified ? val.value : null;
};
Sizzle.error = function (msg) {
  throw new Error(&#39;Syntax error, unrecognized expression: &#39; + msg);
};
Sizzle.uniqueSort = function (results) {
  var elem, duplicates = [], j = 0, i = 0;
  hasDuplicate = !support.detectDuplicates;
  sortInput = !support.sortStable &amp;&amp; results.slice(0);
  results.sort(sortOrder);
  if (hasDuplicate) {
    while (elem = results[i++]) {
      if (elem === results[i]) {
        j = duplicates.push(i);
      }
    }
    while (j--) {
      results.splice(duplicates[j], 1);
    }
  }
  sortInput = null;
  return results;
};
getText = Sizzle.getText = function (elem) {
  var node, ret = &#39;&#39;, i = 0, nodeType = elem.nodeType;
  if (!nodeType) {
    while (node = elem[i++]) {
      ret += getText(node);
    }
  } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
    if (typeof elem.textContent === &#39;string&#39;) {
      return elem.textContent;
    } else {
      for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
        ret += getText(elem);
      }
    }
  } else if (nodeType === 3 || nodeType === 4) {
    return elem.nodeValue;
  }
  return ret;
};
Expr = Sizzle.selectors = {
  cacheLength: 50,
  createPseudo: markFunction,
  match: matchExpr,
  attrHandle: {},
  find: {},
  relative: {
    &#39;&gt;&#39;: {
      dir: &#39;parentNode&#39;,
      first: true
    },
    &#39; &#39;: { dir: &#39;parentNode&#39; },
    &#39;+&#39;: {
      dir: &#39;previousSibling&#39;,
      first: true
    },
    &#39;~&#39;: { dir: &#39;previousSibling&#39; }
  },
  preFilter: {
    ATTR: function (match) {
      match[1] = match[1].replace(runescape, funescape);
      match[3] = (match[3] || match[4] || match[5] || &#39;&#39;).replace(runescape, funescape);
      if (match[2] === &#39;~=&#39;) {
        match[3] = &#39; &#39; + match[3] + &#39; &#39;;
      }
      return match.slice(0, 4);
    },
    CHILD: function (match) {
      match[1] = match[1].toLowerCase();
      if (match[1].slice(0, 3) === &#39;nth&#39;) {
        if (!match[3]) {
          Sizzle.error(match[0]);
        }
        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === &#39;even&#39; || match[3] === &#39;odd&#39;));
        match[5] = +(match[7] + match[8] || match[3] === &#39;odd&#39;);
      } else if (match[3]) {
        Sizzle.error(match[0]);
      }
      return match;
    },
    PSEUDO: function (match) {
      var excess, unquoted = !match[6] &amp;&amp; match[2];
      if (matchExpr.CHILD.test(match[0])) {
        return null;
      }
      if (match[3]) {
        match[2] = match[4] || match[5] || &#39;&#39;;
      } else if (unquoted &amp;&amp; rpseudo.test(unquoted) &amp;&amp; (excess = tokenize(unquoted, true)) &amp;&amp; (excess = unquoted.indexOf(&#39;)&#39;, unquoted.length - excess) - unquoted.length)) {
        match[0] = match[0].slice(0, excess);
        match[2] = unquoted.slice(0, excess);
      }
      return match.slice(0, 3);
    }
  },
  filter: {
    TAG: function (nodeNameSelector) {
      var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
      return nodeNameSelector === &#39;*&#39; ? function () {
        return true;
      } : function (elem) {
        return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
      };
    },
    CLASS: function (className) {
      var pattern = classCache[className + &#39; &#39;];
      return pattern || (pattern = new RegExp(&#39;(^|&#39; + whitespace + &#39;)&#39; + className + &#39;(&#39; + whitespace + &#39;|$)&#39;)) &amp;&amp; classCache(className, function (elem) {
        return pattern.test(typeof elem.className === &#39;string&#39; &amp;&amp; elem.className || typeof elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(&#39;class&#39;) || &#39;&#39;);
      });
    },
    ATTR: function (name$$1, operator, check) {
      return function (elem) {
        var result = Sizzle.attr(elem, name$$1);
        if (result == null) {
          return operator === &#39;!=&#39;;
        }
        if (!operator) {
          return true;
        }
        result += &#39;&#39;;
        return operator === &#39;=&#39; ? result === check : operator === &#39;!=&#39; ? result !== check : operator === &#39;^=&#39; ? check &amp;&amp; result.indexOf(check) === 0 : operator === &#39;*=&#39; ? check &amp;&amp; result.indexOf(check) &gt; -1 : operator === &#39;$=&#39; ? check &amp;&amp; result.slice(-check.length) === check : operator === &#39;~=&#39; ? (&#39; &#39; + result + &#39; &#39;).indexOf(check) &gt; -1 : operator === &#39;|=&#39; ? result === check || result.slice(0, check.length + 1) === check + &#39;-&#39; : false;
      };
    },
    CHILD: function (type, what, argument, first, last) {
      var simple = type.slice(0, 3) !== &#39;nth&#39;, forward = type.slice(-4) !== &#39;last&#39;, ofType = what === &#39;of-type&#39;;
      return first === 1 &amp;&amp; last === 0 ? function (elem) {
        return !!elem.parentNode;
      } : function (elem, context, xml) {
        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? &#39;nextSibling&#39; : &#39;previousSibling&#39;, parent$$1 = elem.parentNode, name$$1 = ofType &amp;&amp; elem.nodeName.toLowerCase(), useCache = !xml &amp;&amp; !ofType;
        if (parent$$1) {
          if (simple) {
            while (dir) {
              node = elem;
              while (node = node[dir]) {
                if (ofType ? node.nodeName.toLowerCase() === name$$1 : node.nodeType === 1) {
                  return false;
                }
              }
              start = dir = type === &#39;only&#39; &amp;&amp; !start &amp;&amp; &#39;nextSibling&#39;;
            }
            return true;
          }
          start = [forward ? parent$$1.firstChild : parent$$1.lastChild];
          if (forward &amp;&amp; useCache) {
            outerCache = parent$$1[expando] || (parent$$1[expando] = {});
            cache = outerCache[type] || [];
            nodeIndex = cache[0] === dirruns &amp;&amp; cache[1];
            diff = cache[0] === dirruns &amp;&amp; cache[2];
            node = nodeIndex &amp;&amp; parent$$1.childNodes[nodeIndex];
            while (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] || (diff = nodeIndex = 0) || start.pop()) {
              if (node.nodeType === 1 &amp;&amp; ++diff &amp;&amp; node === elem) {
                outerCache[type] = [
                  dirruns,
                  nodeIndex,
                  diff
                ];
                break;
              }
            }
          } else if (useCache &amp;&amp; (cache = (elem[expando] || (elem[expando] = {}))[type]) &amp;&amp; cache[0] === dirruns) {
            diff = cache[1];
          } else {
            while (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[dir] || (diff = nodeIndex = 0) || start.pop()) {
              if ((ofType ? node.nodeName.toLowerCase() === name$$1 : node.nodeType === 1) &amp;&amp; ++diff) {
                if (useCache) {
                  (node[expando] || (node[expando] = {}))[type] = [
                    dirruns,
                    diff
                  ];
                }
                if (node === elem) {
                  break;
                }
              }
            }
          }
          diff -= last;
          return diff === first || diff % first === 0 &amp;&amp; diff / first &gt;= 0;
        }
      };
    },
    PSEUDO: function (pseudo, argument) {
      var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(&#39;unsupported pseudo: &#39; + pseudo);
      if (fn[expando]) {
        return fn(argument);
      }
      if (fn.length &gt; 1) {
        args = [
          pseudo,
          pseudo,
          &#39;&#39;,
          argument
        ];
        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
          var idx, matched = fn(seed, argument), i = matched.length;
          while (i--) {
            idx = indexOf$1.call(seed, matched[i]);
            seed[idx] = !(matches[idx] = matched[i]);
          }
        }) : function (elem) {
          return fn(elem, 0, args);
        };
      }
      return fn;
    }
  },
  pseudos: {
    not: markFunction(function (selector) {
      var input = [], results = [], matcher = compile(selector.replace(rtrim, &#39;$1&#39;));
      return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
        while (i--) {
          if (elem = unmatched[i]) {
            seed[i] = !(matches[i] = elem);
          }
        }
      }) : function (elem, context, xml) {
        input[0] = elem;
        matcher(input, null, xml, results);
        return !results.pop();
      };
    }),
    has: markFunction(function (selector) {
      return function (elem) {
        return Sizzle(selector, elem).length &gt; 0;
      };
    }),
    contains: markFunction(function (text) {
      text = text.replace(runescape, funescape);
      return function (elem) {
        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) &gt; -1;
      };
    }),
    lang: markFunction(function (lang) {
      if (!ridentifier.test(lang || &#39;&#39;)) {
        Sizzle.error(&#39;unsupported lang: &#39; + lang);
      }
      lang = lang.replace(runescape, funescape).toLowerCase();
      return function (elem) {
        var elemLang;
        do {
          if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(&#39;xml:lang&#39;) || elem.getAttribute(&#39;lang&#39;)) {
            elemLang = elemLang.toLowerCase();
            return elemLang === lang || elemLang.indexOf(lang + &#39;-&#39;) === 0;
          }
        } while ((elem = elem.parentNode) &amp;&amp; elem.nodeType === 1);
        return false;
      };
    }),
    target: function (elem) {
      var hash = window.location &amp;&amp; window.location.hash;
      return hash &amp;&amp; hash.slice(1) === elem.id;
    },
    root: function (elem) {
      return elem === docElem;
    },
    focus: function (elem) {
      return elem === document$1.activeElement &amp;&amp; (!document$1.hasFocus || document$1.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex);
    },
    enabled: function (elem) {
      return elem.disabled === false;
    },
    disabled: function (elem) {
      return elem.disabled === true;
    },
    checked: function (elem) {
      var nodeName = elem.nodeName.toLowerCase();
      return nodeName === &#39;input&#39; &amp;&amp; !!elem.checked || nodeName === &#39;option&#39; &amp;&amp; !!elem.selected;
    },
    selected: function (elem) {
      if (elem.parentNode) {
        elem.parentNode.selectedIndex;
      }
      return elem.selected === true;
    },
    empty: function (elem) {
      for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
        if (elem.nodeType &lt; 6) {
          return false;
        }
      }
      return true;
    },
    parent: function (elem) {
      return !Expr.pseudos.empty(elem);
    },
    header: function (elem) {
      return rheader.test(elem.nodeName);
    },
    input: function (elem) {
      return rinputs.test(elem.nodeName);
    },
    button: function (elem) {
      var name$$1 = elem.nodeName.toLowerCase();
      return name$$1 === &#39;input&#39; &amp;&amp; elem.type === &#39;button&#39; || name$$1 === &#39;button&#39;;
    },
    text: function (elem) {
      var attr;
      return elem.nodeName.toLowerCase() === &#39;input&#39; &amp;&amp; elem.type === &#39;text&#39; &amp;&amp; ((attr = elem.getAttribute(&#39;type&#39;)) == null || attr.toLowerCase() === &#39;text&#39;);
    },
    first: createPositionalPseudo(function () {
      return [0];
    }),
    last: createPositionalPseudo(function (matchIndexes, length$$1) {
      return [length$$1 - 1];
    }),
    eq: createPositionalPseudo(function (matchIndexes, length$$1, argument) {
      return [argument &lt; 0 ? argument + length$$1 : argument];
    }),
    even: createPositionalPseudo(function (matchIndexes, length$$1) {
      var i = 0;
      for (; i &lt; length$$1; i += 2) {
        matchIndexes.push(i);
      }
      return matchIndexes;
    }),
    odd: createPositionalPseudo(function (matchIndexes, length$$1) {
      var i = 1;
      for (; i &lt; length$$1; i += 2) {
        matchIndexes.push(i);
      }
      return matchIndexes;
    }),
    lt: createPositionalPseudo(function (matchIndexes, length$$1, argument) {
      var i = argument &lt; 0 ? argument + length$$1 : argument;
      for (; --i &gt;= 0;) {
        matchIndexes.push(i);
      }
      return matchIndexes;
    }),
    gt: createPositionalPseudo(function (matchIndexes, length$$1, argument) {
      var i = argument &lt; 0 ? argument + length$$1 : argument;
      for (; ++i &lt; length$$1;) {
        matchIndexes.push(i);
      }
      return matchIndexes;
    })
  }
};
Expr.pseudos.nth = Expr.pseudos.eq;
for (i in {
    radio: true,
    checkbox: true,
    file: true,
    password: true,
    image: true
  }) {
  Expr.pseudos[i] = createInputPseudo(i);
}
for (i in {
    submit: true,
    reset: true
  }) {
  Expr.pseudos[i] = createButtonPseudo(i);
}
function setFilters() {
}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();
tokenize = Sizzle.tokenize = function (selector, parseOnly) {
  var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + &#39; &#39;];
  if (cached) {
    return parseOnly ? 0 : cached.slice(0);
  }
  soFar = selector;
  groups = [];
  preFilters = Expr.preFilter;
  while (soFar) {
    if (!matched || (match = rcomma.exec(soFar))) {
      if (match) {
        soFar = soFar.slice(match[0].length) || soFar;
      }
      groups.push(tokens = []);
    }
    matched = false;
    if (match = rcombinators.exec(soFar)) {
      matched = match.shift();
      tokens.push({
        value: matched,
        type: match[0].replace(rtrim, &#39; &#39;)
      });
      soFar = soFar.slice(matched.length);
    }
    for (type in Expr.filter) {
      if ((match = matchExpr[type].exec(soFar)) &amp;&amp; (!preFilters[type] || (match = preFilters[type](match)))) {
        matched = match.shift();
        tokens.push({
          value: matched,
          type: type,
          matches: match
        });
        soFar = soFar.slice(matched.length);
      }
    }
    if (!matched) {
      break;
    }
  }
  return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
};
function toSelector(tokens) {
  var i = 0, len = tokens.length, selector = &#39;&#39;;
  for (; i &lt; len; i++) {
    selector += tokens[i].value;
  }
  return selector;
}
function addCombinator(matcher, combinator, base) {
  var dir = combinator.dir, checkNonElements = base &amp;&amp; dir === &#39;parentNode&#39;, doneName = done++;
  return combinator.first ? function (elem, context, xml) {
    while (elem = elem[dir]) {
      if (elem.nodeType === 1 || checkNonElements) {
        return matcher(elem, context, xml);
      }
    }
  } : function (elem, context, xml) {
    var oldCache, outerCache, newCache = [
        dirruns,
        doneName
      ];
    if (xml) {
      while (elem = elem[dir]) {
        if (elem.nodeType === 1 || checkNonElements) {
          if (matcher(elem, context, xml)) {
            return true;
          }
        }
      }
    } else {
      while (elem = elem[dir]) {
        if (elem.nodeType === 1 || checkNonElements) {
          outerCache = elem[expando] || (elem[expando] = {});
          if ((oldCache = outerCache[dir]) &amp;&amp; oldCache[0] === dirruns &amp;&amp; oldCache[1] === doneName) {
            return newCache[2] = oldCache[2];
          } else {
            outerCache[dir] = newCache;
            if (newCache[2] = matcher(elem, context, xml)) {
              return true;
            }
          }
        }
      }
    }
  };
}
function elementMatcher(matchers) {
  return matchers.length &gt; 1 ? function (elem, context, xml) {
    var i = matchers.length;
    while (i--) {
      if (!matchers[i](elem, context, xml)) {
        return false;
      }
    }
    return true;
  } : matchers[0];
}
function multipleContexts(selector, contexts, results) {
  var i = 0, len = contexts.length;
  for (; i &lt; len; i++) {
    Sizzle(selector, contexts[i], results);
  }
  return results;
}
function condense(unmatched, map, filter, context, xml) {
  var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
  for (; i &lt; len; i++) {
    if (elem = unmatched[i]) {
      if (!filter || filter(elem, context, xml)) {
        newUnmatched.push(elem);
        if (mapped) {
          map.push(i);
        }
      }
    }
  }
  return newUnmatched;
}
function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
  if (postFilter &amp;&amp; !postFilter[expando]) {
    postFilter = setMatcher(postFilter);
  }
  if (postFinder &amp;&amp; !postFinder[expando]) {
    postFinder = setMatcher(postFinder, postSelector);
  }
  return markFunction(function (seed, results, context, xml) {
    var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || &#39;*&#39;, context.nodeType ? [context] : context, []), matcherIn = preFilter &amp;&amp; (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
    if (matcher) {
      matcher(matcherIn, matcherOut, context, xml);
    }
    if (postFilter) {
      temp = condense(matcherOut, postMap);
      postFilter(temp, [], context, xml);
      i = temp.length;
      while (i--) {
        if (elem = temp[i]) {
          matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
        }
      }
    }
    if (seed) {
      if (postFinder || preFilter) {
        if (postFinder) {
          temp = [];
          i = matcherOut.length;
          while (i--) {
            if (elem = matcherOut[i]) {
              temp.push(matcherIn[i] = elem);
            }
          }
          postFinder(null, matcherOut = [], temp, xml);
        }
        i = matcherOut.length;
        while (i--) {
          if ((elem = matcherOut[i]) &amp;&amp; (temp = postFinder ? indexOf$1.call(seed, elem) : preMap[i]) &gt; -1) {
            seed[temp] = !(results[temp] = elem);
          }
        }
      }
    } else {
      matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
      if (postFinder) {
        postFinder(null, results, matcherOut, xml);
      } else {
        push$1.apply(results, matcherOut);
      }
    }
  });
}
function matcherFromTokens(tokens) {
  var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[&#39; &#39;], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
      return elem === checkContext;
    }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
      return indexOf$1.call(checkContext, elem) &gt; -1;
    }, implicitRelative, true), matchers = [function (elem, context, xml) {
        return !leadingRelative &amp;&amp; (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
      }];
  for (; i &lt; len; i++) {
    if (matcher = Expr.relative[tokens[i].type]) {
      matchers = [addCombinator(elementMatcher(matchers), matcher)];
    } else {
      matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
      if (matcher[expando]) {
        j = ++i;
        for (; j &lt; len; j++) {
          if (Expr.relative[tokens[j].type]) {
            break;
          }
        }
        return setMatcher(i &gt; 1 &amp;&amp; elementMatcher(matchers), i &gt; 1 &amp;&amp; toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === &#39; &#39; ? &#39;*&#39; : &#39;&#39; })).replace(rtrim, &#39;$1&#39;), matcher, i &lt; j &amp;&amp; matcherFromTokens(tokens.slice(i, j)), j &lt; len &amp;&amp; matcherFromTokens(tokens = tokens.slice(j)), j &lt; len &amp;&amp; toSelector(tokens));
      }
      matchers.push(matcher);
    }
  }
  return elementMatcher(matchers);
}
function matcherFromGroupMatchers(elementMatchers, setMatchers) {
  var bySet = setMatchers.length &gt; 0, byElement = elementMatchers.length &gt; 0, superMatcher = function (seed, context, xml, results, outermost) {
      var elem, j, matcher, matchedCount = 0, i = &#39;0&#39;, unmatched = seed &amp;&amp; [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement &amp;&amp; Expr.find.TAG(&#39;*&#39;, outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
      if (outermost) {
        outermostContext = context !== document$1 &amp;&amp; context;
      }
      for (; i !== len &amp;&amp; (elem = elems[i]) != null; i++) {
        if (byElement &amp;&amp; elem) {
          j = 0;
          while (matcher = elementMatchers[j++]) {
            if (matcher(elem, context, xml)) {
              results.push(elem);
              break;
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
          }
        }
        if (bySet) {
          if (elem = !matcher &amp;&amp; elem) {
            matchedCount--;
          }
          if (seed) {
            unmatched.push(elem);
          }
        }
      }
      matchedCount += i;
      if (bySet &amp;&amp; i !== matchedCount) {
        j = 0;
        while (matcher = setMatchers[j++]) {
          matcher(unmatched, setMatched, context, xml);
        }
        if (seed) {
          if (matchedCount &gt; 0) {
            while (i--) {
              if (!(unmatched[i] || setMatched[i])) {
                setMatched[i] = pop.call(results);
              }
            }
          }
          setMatched = condense(setMatched);
        }
        push$1.apply(results, setMatched);
        if (outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp; matchedCount + setMatchers.length &gt; 1) {
          Sizzle.uniqueSort(results);
        }
      }
      if (outermost) {
        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      }
      return unmatched;
    };
  return bySet ? markFunction(superMatcher) : superMatcher;
}
compile = Sizzle.compile = function (selector, match) {
  var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + &#39; &#39;];
  if (!cached) {
    if (!match) {
      match = tokenize(selector);
    }
    i = match.length;
    while (i--) {
      cached = matcherFromTokens(match[i]);
      if (cached[expando]) {
        setMatchers.push(cached);
      } else {
        elementMatchers.push(cached);
      }
    }
    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
    cached.selector = selector;
  }
  return cached;
};
select = Sizzle.select = function (selector, context, results, seed) {
  var i, tokens, token, type, find, compiled = typeof selector === &#39;function&#39; &amp;&amp; selector, match = !seed &amp;&amp; tokenize(selector = compiled.selector || selector);
  results = results || [];
  if (match.length === 1) {
    tokens = match[0] = match[0].slice(0);
    if (tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &#39;ID&#39; &amp;&amp; support.getById &amp;&amp; context.nodeType === 9 &amp;&amp; documentIsHTML &amp;&amp; Expr.relative[tokens[1].type]) {
      context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0];
      if (!context) {
        return results;
      } else if (compiled) {
        context = context.parentNode;
      }
      selector = selector.slice(tokens.shift().value.length);
    }
    i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
    while (i--) {
      token = tokens[i];
      if (Expr.relative[type = token.type]) {
        break;
      }
      if (find = Expr.find[type]) {
        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) &amp;&amp; testContext(context.parentNode) || context)) {
          tokens.splice(i, 1);
          selector = seed.length &amp;&amp; toSelector(tokens);
          if (!selector) {
            push$1.apply(results, seed);
            return results;
          }
          break;
        }
      }
    }
  }
  (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) &amp;&amp; testContext(context.parentNode) || context);
  return results;
};
support.sortStable = expando.split(&#39;&#39;).sort(sortOrder).join(&#39;&#39;) === expando;
support.detectDuplicates = !!hasDuplicate;
setDocument();
support.sortDetached = true;

var isArray$1 = Array.isArray;
var toArray = function (obj) {
  var array = obj, i, l;
  if (!isArray$1(obj)) {
    array = [];
    for (i = 0, l = obj.length; i &lt; l; i++) {
      array[i] = obj[i];
    }
  }
  return array;
};
var each$1 = function (o, cb, s) {
  var n, l;
  if (!o) {
    return 0;
  }
  s = s || o;
  if (o.length !== undefined) {
    for (n = 0, l = o.length; n &lt; l; n++) {
      if (cb.call(s, o[n], n, o) === false) {
        return 0;
      }
    }
  } else {
    for (n in o) {
      if (o.hasOwnProperty(n)) {
        if (cb.call(s, o[n], n, o) === false) {
          return 0;
        }
      }
    }
  }
  return 1;
};
var map$1 = function (array, callback) {
  var out = [];
  each$1(array, function (item, index) {
    out.push(callback(item, index, array));
  });
  return out;
};
var filter$1 = function (a, f) {
  var o = [];
  each$1(a, function (v, index) {
    if (!f || f(v, index, a)) {
      o.push(v);
    }
  });
  return o;
};
var indexOf$2 = function (a, v) {
  var i, l;
  if (a) {
    for (i = 0, l = a.length; i &lt; l; i++) {
      if (a[i] === v) {
        return i;
      }
    }
  }
  return -1;
};
var reduce = function (collection, iteratee, accumulator, thisArg) {
  var i = 0;
  if (arguments.length &lt; 3) {
    accumulator = collection[0];
  }
  for (; i &lt; collection.length; i++) {
    accumulator = iteratee.call(thisArg, accumulator, collection[i], i);
  }
  return accumulator;
};
var findIndex$1 = function (array, predicate, thisArg) {
  var i, l;
  for (i = 0, l = array.length; i &lt; l; i++) {
    if (predicate.call(thisArg, array[i], i, array)) {
      return i;
    }
  }
  return -1;
};
var find$1 = function (array, predicate, thisArg) {
  var idx = findIndex$1(array, predicate, thisArg);
  if (idx !== -1) {
    return array[idx];
  }
  return undefined;
};
var last$1 = function (collection) {
  return collection[collection.length - 1];
};
var ArrUtils = {
  isArray: isArray$1,
  toArray: toArray,
  each: each$1,
  map: map$1,
  filter: filter$1,
  indexOf: indexOf$2,
  reduce: reduce,
  findIndex: findIndex$1,
  find: find$1,
  last: last$1
};

var whiteSpaceRegExp = /^\s*|\s*$/g;
var trim = function (str) {
  return str === null || str === undefined ? &#39;&#39; : (&#39;&#39; + str).replace(whiteSpaceRegExp, &#39;&#39;);
};
var is = function (obj, type) {
  if (!type) {
    return obj !== undefined;
  }
  if (type === &#39;array&#39; &amp;&amp; ArrUtils.isArray(obj)) {
    return true;
  }
  return typeof obj === type;
};
var makeMap = function (items, delim, map) {
  var i;
  items = items || [];
  delim = delim || &#39;,&#39;;
  if (typeof items === &#39;string&#39;) {
    items = items.split(delim);
  }
  map = map || {};
  i = items.length;
  while (i--) {
    map[items[i]] = {};
  }
  return map;
};
var hasOwnProperty = function (obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
var create = function (s, p, root) {
  var self$$1 = this;
  var sp, ns, cn, scn, c, de = 0;
  s = /^((static) )?([\w.]+)(:([\w.]+))?/.exec(s);
  cn = s[3].match(/(^|\.)(\w+)$/i)[2];
  ns = self$$1.createNS(s[3].replace(/\.\w+$/, &#39;&#39;), root);
  if (ns[cn]) {
    return;
  }
  if (s[2] === &#39;static&#39;) {
    ns[cn] = p;
    if (this.onCreate) {
      this.onCreate(s[2], s[3], ns[cn]);
    }
    return;
  }
  if (!p[cn]) {
    p[cn] = function () {
    };
    de = 1;
  }
  ns[cn] = p[cn];
  self$$1.extend(ns[cn].prototype, p);
  if (s[5]) {
    sp = self$$1.resolve(s[5]).prototype;
    scn = s[5].match(/\.(\w+)$/i)[1];
    c = ns[cn];
    if (de) {
      ns[cn] = function () {
        return sp[scn].apply(this, arguments);
      };
    } else {
      ns[cn] = function () {
        this.parent = sp[scn];
        return c.apply(this, arguments);
      };
    }
    ns[cn].prototype[cn] = ns[cn];
    self$$1.each(sp, function (f, n) {
      ns[cn].prototype[n] = sp[n];
    });
    self$$1.each(p, function (f, n) {
      if (sp[n]) {
        ns[cn].prototype[n] = function () {
          this.parent = sp[n];
          return f.apply(this, arguments);
        };
      } else {
        if (n !== cn) {
          ns[cn].prototype[n] = f;
        }
      }
    });
  }
  self$$1.each(p.static, function (f, n) {
    ns[cn][n] = f;
  });
};
var extend = function (obj, ext) {
  var x = [];
  for (var _i = 2; _i &lt; arguments.length; _i++) {
    x[_i - 2] = arguments[_i];
  }
  var i, l, name$$1;
  var args = arguments;
  var value;
  for (i = 1, l = args.length; i &lt; l; i++) {
    ext = args[i];
    for (name$$1 in ext) {
      if (ext.hasOwnProperty(name$$1)) {
        value = ext[name$$1];
        if (value !== undefined) {
          obj[name$$1] = value;
        }
      }
    }
  }
  return obj;
};
var walk = function (o, f, n, s) {
  s = s || this;
  if (o) {
    if (n) {
      o = o[n];
    }
    ArrUtils.each(o, function (o, i) {
      if (f.call(s, o, i, n) === false) {
        return false;
      }
      walk(o, f, n, s);
    });
  }
};
var createNS = function (n, o) {
  var i, v;
  o = o || window;
  n = n.split(&#39;.&#39;);
  for (i = 0; i &lt; n.length; i++) {
    v = n[i];
    if (!o[v]) {
      o[v] = {};
    }
    o = o[v];
  }
  return o;
};
var resolve$1 = function (n, o) {
  var i, l;
  o = o || window;
  n = n.split(&#39;.&#39;);
  for (i = 0, l = n.length; i &lt; l; i++) {
    o = o[n[i]];
    if (!o) {
      break;
    }
  }
  return o;
};
var explode = function (s, d) {
  if (!s || is(s, &#39;array&#39;)) {
    return s;
  }
  return ArrUtils.map(s.split(d || &#39;,&#39;), trim);
};
var _addCacheSuffix = function (url) {
  var cacheSuffix = Env.cacheSuffix;
  if (cacheSuffix) {
    url += (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + cacheSuffix;
  }
  return url;
};
var Tools = {
  trim: trim,
  isArray: ArrUtils.isArray,
  is: is,
  toArray: ArrUtils.toArray,
  makeMap: makeMap,
  each: ArrUtils.each,
  map: ArrUtils.map,
  grep: ArrUtils.filter,
  inArray: ArrUtils.indexOf,
  hasOwn: hasOwnProperty,
  extend: extend,
  create: create,
  walk: walk,
  createNS: createNS,
  resolve: resolve$1,
  explode: explode,
  _addCacheSuffix: _addCacheSuffix
};

var doc = document, push$2 = Array.prototype.push, slice$2 = Array.prototype.slice;
var rquickExpr$1 = /^(?:[^#&lt;]*(&lt;[\w\W]+&gt;)[^&gt;]*$|#([\w\-]*)$)/;
var Event$$1 = EventUtils.Event;
var skipUniques = Tools.makeMap(&#39;children,contents,next,prev&#39;);
var isDefined = function (obj) {
  return typeof obj !== &#39;undefined&#39;;
};
var isString$1 = function (obj) {
  return typeof obj === &#39;string&#39;;
};
var isWindow = function (obj) {
  return obj &amp;&amp; obj === obj.window;
};
var createFragment = function (html, fragDoc) {
  var frag, node, container;
  fragDoc = fragDoc || doc;
  container = fragDoc.createElement(&#39;div&#39;);
  frag = fragDoc.createDocumentFragment();
  container.innerHTML = html;
  while (node = container.firstChild) {
    frag.appendChild(node);
  }
  return frag;
};
var domManipulate = function (targetNodes, sourceItem, callback, reverse) {
  var i;
  if (isString$1(sourceItem)) {
    sourceItem = createFragment(sourceItem, getElementDocument(targetNodes[0]));
  } else if (sourceItem.length &amp;&amp; !sourceItem.nodeType) {
    sourceItem = DomQuery.makeArray(sourceItem);
    if (reverse) {
      for (i = sourceItem.length - 1; i &gt;= 0; i--) {
        domManipulate(targetNodes, sourceItem[i], callback, reverse);
      }
    } else {
      for (i = 0; i &lt; sourceItem.length; i++) {
        domManipulate(targetNodes, sourceItem[i], callback, reverse);
      }
    }
    return targetNodes;
  }
  if (sourceItem.nodeType) {
    i = targetNodes.length;
    while (i--) {
      callback.call(targetNodes[i], sourceItem);
    }
  }
  return targetNodes;
};
var hasClass = function (node, className) {
  return node &amp;&amp; className &amp;&amp; (&#39; &#39; + node.className + &#39; &#39;).indexOf(&#39; &#39; + className + &#39; &#39;) !== -1;
};
var wrap = function (elements, wrapper, all) {
  var lastParent, newWrapper;
  wrapper = DomQuery(wrapper)[0];
  elements.each(function () {
    var self$$1 = this;
    if (!all || lastParent !== self$$1.parentNode) {
      lastParent = self$$1.parentNode;
      newWrapper = wrapper.cloneNode(false);
      self$$1.parentNode.insertBefore(newWrapper, self$$1);
      newWrapper.appendChild(self$$1);
    } else {
      newWrapper.appendChild(self$$1);
    }
  });
  return elements;
};
var numericCssMap = Tools.makeMap(&#39;fillOpacity fontWeight lineHeight opacity orphans widows zIndex zoom&#39;, &#39; &#39;);
var booleanMap = Tools.makeMap(&#39;checked compact declare defer disabled ismap multiple nohref noshade nowrap readonly selected&#39;, &#39; &#39;);
var propFix = {
  for: &#39;htmlFor&#39;,
  class: &#39;className&#39;,
  readonly: &#39;readOnly&#39;
};
var cssFix = { float: &#39;cssFloat&#39; };
var attrHooks = {}, cssHooks = {};
var DomQuery = function (selector, context) {
  return new DomQuery.fn.init(selector, context);
};
var inArray = function (item, array) {
  var i;
  if (array.indexOf) {
    return array.indexOf(item);
  }
  i = array.length;
  while (i--) {
    if (array[i] === item) {
      return i;
    }
  }
  return -1;
};
var whiteSpaceRegExp$1 = /^\s*|\s*$/g;
var trim$1 = function (str) {
  return str === null || str === undefined ? &#39;&#39; : (&#39;&#39; + str).replace(whiteSpaceRegExp$1, &#39;&#39;);
};
var each$2 = function (obj, callback) {
  var length$$1, key, i, value;
  if (obj) {
    length$$1 = obj.length;
    if (length$$1 === undefined) {
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          value = obj[key];
          if (callback.call(value, key, value) === false) {
            break;
          }
        }
      }
    } else {
      for (i = 0; i &lt; length$$1; i++) {
        value = obj[i];
        if (callback.call(value, i, value) === false) {
          break;
        }
      }
    }
  }
  return obj;
};
var grep = function (array, callback) {
  var out = [];
  each$2(array, function (i, item) {
    if (callback(item, i)) {
      out.push(item);
    }
  });
  return out;
};
var getElementDocument = function (element) {
  if (!element) {
    return doc;
  }
  if (element.nodeType === 9) {
    return element;
  }
  return element.ownerDocument;
};
DomQuery.fn = DomQuery.prototype = {
  constructor: DomQuery,
  selector: &#39;&#39;,
  context: null,
  length: 0,
  init: function (selector, context) {
    var self$$1 = this;
    var match, node;
    if (!selector) {
      return self$$1;
    }
    if (selector.nodeType) {
      self$$1.context = self$$1[0] = selector;
      self$$1.length = 1;
      return self$$1;
    }
    if (context &amp;&amp; context.nodeType) {
      self$$1.context = context;
    } else {
      if (context) {
        return DomQuery(selector).attr(context);
      }
      self$$1.context = context = document;
    }
    if (isString$1(selector)) {
      self$$1.selector = selector;
      if (selector.charAt(0) === &#39;&lt;&#39; &amp;&amp; selector.charAt(selector.length - 1) === &#39;&gt;&#39; &amp;&amp; selector.length &gt;= 3) {
        match = [
          null,
          selector,
          null
        ];
      } else {
        match = rquickExpr$1.exec(selector);
      }
      if (match) {
        if (match[1]) {
          node = createFragment(selector, getElementDocument(context)).firstChild;
          while (node) {
            push$2.call(self$$1, node);
            node = node.nextSibling;
          }
        } else {
          node = getElementDocument(context).getElementById(match[2]);
          if (!node) {
            return self$$1;
          }
          if (node.id !== match[2]) {
            return self$$1.find(selector);
          }
          self$$1.length = 1;
          self$$1[0] = node;
        }
      } else {
        return DomQuery(context).find(selector);
      }
    } else {
      this.add(selector, false);
    }
    return self$$1;
  },
  toArray: function () {
    return Tools.toArray(this);
  },
  add: function (items, sort) {
    var self$$1 = this;
    var nodes, i;
    if (isString$1(items)) {
      return self$$1.add(DomQuery(items));
    }
    if (sort !== false) {
      nodes = DomQuery.unique(self$$1.toArray().concat(DomQuery.makeArray(items)));
      self$$1.length = nodes.length;
      for (i = 0; i &lt; nodes.length; i++) {
        self$$1[i] = nodes[i];
      }
    } else {
      push$2.apply(self$$1, DomQuery.makeArray(items));
    }
    return self$$1;
  },
  attr: function (name$$1, value) {
    var self$$1 = this;
    var hook;
    if (typeof name$$1 === &#39;object&#39;) {
      each$2(name$$1, function (name$$1, value) {
        self$$1.attr(name$$1, value);
      });
    } else if (isDefined(value)) {
      this.each(function () {
        var hook;
        if (this.nodeType === 1) {
          hook = attrHooks[name$$1];
          if (hook &amp;&amp; hook.set) {
            hook.set(this, value);
            return;
          }
          if (value === null) {
            this.removeAttribute(name$$1, 2);
          } else {
            this.setAttribute(name$$1, value, 2);
          }
        }
      });
    } else {
      if (self$$1[0] &amp;&amp; self$$1[0].nodeType === 1) {
        hook = attrHooks[name$$1];
        if (hook &amp;&amp; hook.get) {
          return hook.get(self$$1[0], name$$1);
        }
        if (booleanMap[name$$1]) {
          return self$$1.prop(name$$1) ? name$$1 : undefined;
        }
        value = self$$1[0].getAttribute(name$$1, 2);
        if (value === null) {
          value = undefined;
        }
      }
      return value;
    }
    return self$$1;
  },
  removeAttr: function (name$$1) {
    return this.attr(name$$1, null);
  },
  prop: function (name$$1, value) {
    var self$$1 = this;
    name$$1 = propFix[name$$1] || name$$1;
    if (typeof name$$1 === &#39;object&#39;) {
      each$2(name$$1, function (name$$1, value) {
        self$$1.prop(name$$1, value);
      });
    } else if (isDefined(value)) {
      this.each(function () {
        if (this.nodeType === 1) {
          this[name$$1] = value;
        }
      });
    } else {
      if (self$$1[0] &amp;&amp; self$$1[0].nodeType &amp;&amp; name$$1 in self$$1[0]) {
        return self$$1[0][name$$1];
      }
      return value;
    }
    return self$$1;
  },
  css: function (name$$1, value) {
    var self$$1 = this;
    var elm, hook;
    var camel = function (name$$1) {
      return name$$1.replace(/-(\D)/g, function (a, b) {
        return b.toUpperCase();
      });
    };
    var dashed = function (name$$1) {
      return name$$1.replace(/[A-Z]/g, function (a) {
        return &#39;-&#39; + a;
      });
    };
    if (typeof name$$1 === &#39;object&#39;) {
      each$2(name$$1, function (name$$1, value) {
        self$$1.css(name$$1, value);
      });
    } else {
      if (isDefined(value)) {
        name$$1 = camel(name$$1);
        if (typeof value === &#39;number&#39; &amp;&amp; !numericCssMap[name$$1]) {
          value = value.toString() + &#39;px&#39;;
        }
        self$$1.each(function () {
          var style = this.style;
          hook = cssHooks[name$$1];
          if (hook &amp;&amp; hook.set) {
            hook.set(this, value);
            return;
          }
          try {
            this.style[cssFix[name$$1] || name$$1] = value;
          } catch (ex) {
          }
          if (value === null || value === &#39;&#39;) {
            if (style.removeProperty) {
              style.removeProperty(dashed(name$$1));
            } else {
              style.removeAttribute(name$$1);
            }
          }
        });
      } else {
        elm = self$$1[0];
        hook = cssHooks[name$$1];
        if (hook &amp;&amp; hook.get) {
          return hook.get(elm);
        }
        if (elm.ownerDocument.defaultView) {
          try {
            return elm.ownerDocument.defaultView.getComputedStyle(elm, null).getPropertyValue(dashed(name$$1));
          } catch (ex) {
            return undefined;
          }
        } else if (elm.currentStyle) {
          return elm.currentStyle[camel(name$$1)];
        } else {
          return &#39;&#39;;
        }
      }
    }
    return self$$1;
  },
  remove: function () {
    var self$$1 = this;
    var node, i = this.length;
    while (i--) {
      node = self$$1[i];
      Event$$1.clean(node);
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }
    return this;
  },
  empty: function () {
    var self$$1 = this;
    var node, i = this.length;
    while (i--) {
      node = self$$1[i];
      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }
    }
    return this;
  },
  html: function (value) {
    var self$$1 = this;
    var i;
    if (isDefined(value)) {
      i = self$$1.length;
      try {
        while (i--) {
          self$$1[i].innerHTML = value;
        }
      } catch (ex) {
        DomQuery(self$$1[i]).empty().append(value);
      }
      return self$$1;
    }
    return self$$1[0] ? self$$1[0].innerHTML : &#39;&#39;;
  },
  text: function (value) {
    var self$$1 = this;
    var i;
    if (isDefined(value)) {
      i = self$$1.length;
      while (i--) {
        if (&#39;innerText&#39; in self$$1[i]) {
          self$$1[i].innerText = value;
        } else {
          self$$1[0].textContent = value;
        }
      }
      return self$$1;
    }
    return self$$1[0] ? self$$1[0].innerText || self$$1[0].textContent : &#39;&#39;;
  },
  append: function () {
    return domManipulate(this, arguments, function (node) {
      if (this.nodeType === 1 || this.host &amp;&amp; this.host.nodeType === 1) {
        this.appendChild(node);
      }
    });
  },
  prepend: function () {
    return domManipulate(this, arguments, function (node) {
      if (this.nodeType === 1 || this.host &amp;&amp; this.host.nodeType === 1) {
        this.insertBefore(node, this.firstChild);
      }
    }, true);
  },
  before: function () {
    var self$$1 = this;
    if (self$$1[0] &amp;&amp; self$$1[0].parentNode) {
      return domManipulate(self$$1, arguments, function (node) {
        this.parentNode.insertBefore(node, this);
      });
    }
    return self$$1;
  },
  after: function () {
    var self$$1 = this;
    if (self$$1[0] &amp;&amp; self$$1[0].parentNode) {
      return domManipulate(self$$1, arguments, function (node) {
        this.parentNode.insertBefore(node, this.nextSibling);
      }, true);
    }
    return self$$1;
  },
  appendTo: function (val) {
    DomQuery(val).append(this);
    return this;
  },
  prependTo: function (val) {
    DomQuery(val).prepend(this);
    return this;
  },
  replaceWith: function (content) {
    return this.before(content).remove();
  },
  wrap: function (content) {
    return wrap(this, content);
  },
  wrapAll: function (content) {
    return wrap(this, content, true);
  },
  wrapInner: function (content) {
    this.each(function () {
      DomQuery(this).contents().wrapAll(content);
    });
    return this;
  },
  unwrap: function () {
    return this.parent().each(function () {
      DomQuery(this).replaceWith(this.childNodes);
    });
  },
  clone: function () {
    var result = [];
    this.each(function () {
      result.push(this.cloneNode(true));
    });
    return DomQuery(result);
  },
  addClass: function (className) {
    return this.toggleClass(className, true);
  },
  removeClass: function (className) {
    return this.toggleClass(className, false);
  },
  toggleClass: function (className, state) {
    var self$$1 = this;
    if (typeof className !== &#39;string&#39;) {
      return self$$1;
    }
    if (className.indexOf(&#39; &#39;) !== -1) {
      each$2(className.split(&#39; &#39;), function () {
        self$$1.toggleClass(this, state);
      });
    } else {
      self$$1.each(function (index, node) {
        var existingClassName, classState;
        classState = hasClass(node, className);
        if (classState !== state) {
          existingClassName = node.className;
          if (classState) {
            node.className = trim$1((&#39; &#39; + existingClassName + &#39; &#39;).replace(&#39; &#39; + className + &#39; &#39;, &#39; &#39;));
          } else {
            node.className += existingClassName ? &#39; &#39; + className : className;
          }
        }
      });
    }
    return self$$1;
  },
  hasClass: function (className) {
    return hasClass(this[0], className);
  },
  each: function (callback) {
    return each$2(this, callback);
  },
  on: function (name$$1, callback) {
    return this.each(function () {
      Event$$1.bind(this, name$$1, callback);
    });
  },
  off: function (name$$1, callback) {
    return this.each(function () {
      Event$$1.unbind(this, name$$1, callback);
    });
  },
  trigger: function (name$$1) {
    return this.each(function () {
      if (typeof name$$1 === &#39;object&#39;) {
        Event$$1.fire(this, name$$1.type, name$$1);
      } else {
        Event$$1.fire(this, name$$1);
      }
    });
  },
  show: function () {
    return this.css(&#39;display&#39;, &#39;&#39;);
  },
  hide: function () {
    return this.css(&#39;display&#39;, &#39;none&#39;);
  },
  slice: function () {
    return new DomQuery(slice$2.apply(this, arguments));
  },
  eq: function (index) {
    return index === -1 ? this.slice(index) : this.slice(index, +index + 1);
  },
  first: function () {
    return this.eq(0);
  },
  last: function () {
    return this.eq(-1);
  },
  find: function (selector) {
    var i, l;
    var ret = [];
    for (i = 0, l = this.length; i &lt; l; i++) {
      DomQuery.find(selector, this[i], ret);
    }
    return DomQuery(ret);
  },
  filter: function (selector) {
    if (typeof selector === &#39;function&#39;) {
      return DomQuery(grep(this.toArray(), function (item, i) {
        return selector(i, item);
      }));
    }
    return DomQuery(DomQuery.filter(selector, this.toArray()));
  },
  closest: function (selector) {
    var result = [];
    if (selector instanceof DomQuery) {
      selector = selector[0];
    }
    this.each(function (i, node) {
      while (node) {
        if (typeof selector === &#39;string&#39; &amp;&amp; DomQuery(node).is(selector)) {
          result.push(node);
          break;
        } else if (node === selector) {
          result.push(node);
          break;
        }
        node = node.parentNode;
      }
    });
    return DomQuery(result);
  },
  offset: function (offset) {
    var elm, doc, docElm;
    var x = 0, y = 0, pos;
    if (!offset) {
      elm = this[0];
      if (elm) {
        doc = elm.ownerDocument;
        docElm = doc.documentElement;
        if (elm.getBoundingClientRect) {
          pos = elm.getBoundingClientRect();
          x = pos.left + (docElm.scrollLeft || doc.body.scrollLeft) - docElm.clientLeft;
          y = pos.top + (docElm.scrollTop || doc.body.scrollTop) - docElm.clientTop;
        }
      }
      return {
        left: x,
        top: y
      };
    }
    return this.css(offset);
  },
  push: push$2,
  sort: [].sort,
  splice: [].splice
};
Tools.extend(DomQuery, {
  extend: Tools.extend,
  makeArray: function (object) {
    if (isWindow(object) || object.nodeType) {
      return [object];
    }
    return Tools.toArray(object);
  },
  inArray: inArray,
  isArray: Tools.isArray,
  each: each$2,
  trim: trim$1,
  grep: grep,
  find: Sizzle,
  expr: Sizzle.selectors,
  unique: Sizzle.uniqueSort,
  text: Sizzle.getText,
  contains: Sizzle.contains,
  filter: function (expr, elems, not) {
    var i = elems.length;
    if (not) {
      expr = &#39;:not(&#39; + expr + &#39;)&#39;;
    }
    while (i--) {
      if (elems[i].nodeType !== 1) {
        elems.splice(i, 1);
      }
    }
    if (elems.length === 1) {
      elems = DomQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [];
    } else {
      elems = DomQuery.find.matches(expr, elems);
    }
    return elems;
  }
});
var dir = function (el, prop, until) {
  var matched = [];
  var cur = el[prop];
  if (typeof until !== &#39;string&#39; &amp;&amp; until instanceof DomQuery) {
    until = until[0];
  }
  while (cur &amp;&amp; cur.nodeType !== 9) {
    if (until !== undefined) {
      if (cur === until) {
        break;
      }
      if (typeof until === &#39;string&#39; &amp;&amp; DomQuery(cur).is(until)) {
        break;
      }
    }
    if (cur.nodeType === 1) {
      matched.push(cur);
    }
    cur = cur[prop];
  }
  return matched;
};
var sibling = function (node, siblingName, nodeType, until) {
  var result = [];
  if (until instanceof DomQuery) {
    until = until[0];
  }
  for (; node; node = node[siblingName]) {
    if (nodeType &amp;&amp; node.nodeType !== nodeType) {
      continue;
    }
    if (until !== undefined) {
      if (node === until) {
        break;
      }
      if (typeof until === &#39;string&#39; &amp;&amp; DomQuery(node).is(until)) {
        break;
      }
    }
    result.push(node);
  }
  return result;
};
var firstSibling = function (node, siblingName, nodeType) {
  for (node = node[siblingName]; node; node = node[siblingName]) {
    if (node.nodeType === nodeType) {
      return node;
    }
  }
  return null;
};
each$2({
  parent: function (node) {
    var parent$$1 = node.parentNode;
    return parent$$1 &amp;&amp; parent$$1.nodeType !== 11 ? parent$$1 : null;
  },
  parents: function (node) {
    return dir(node, &#39;parentNode&#39;);
  },
  next: function (node) {
    return firstSibling(node, &#39;nextSibling&#39;, 1);
  },
  prev: function (node) {
    return firstSibling(node, &#39;previousSibling&#39;, 1);
  },
  children: function (node) {
    return sibling(node.firstChild, &#39;nextSibling&#39;, 1);
  },
  contents: function (node) {
    return Tools.toArray((node.nodeName === &#39;iframe&#39; ? node.contentDocument || node.contentWindow.document : node).childNodes);
  }
}, function (name$$1, fn) {
  DomQuery.fn[name$$1] = function (selector) {
    var self$$1 = this;
    var result = [];
    self$$1.each(function () {
      var nodes = fn.call(result, this, selector, result);
      if (nodes) {
        if (DomQuery.isArray(nodes)) {
          result.push.apply(result, nodes);
        } else {
          result.push(nodes);
        }
      }
    });
    if (this.length &gt; 1) {
      if (!skipUniques[name$$1]) {
        result = DomQuery.unique(result);
      }
      if (name$$1.indexOf(&#39;parents&#39;) === 0) {
        result = result.reverse();
      }
    }
    result = DomQuery(result);
    if (selector) {
      return result.filter(selector);
    }
    return result;
  };
});
each$2({
  parentsUntil: function (node, until) {
    return dir(node, &#39;parentNode&#39;, until);
  },
  nextUntil: function (node, until) {
    return sibling(node, &#39;nextSibling&#39;, 1, until).slice(1);
  },
  prevUntil: function (node, until) {
    return sibling(node, &#39;previousSibling&#39;, 1, until).slice(1);
  }
}, function (name$$1, fn) {
  DomQuery.fn[name$$1] = function (selector, filter) {
    var self$$1 = this;
    var result = [];
    self$$1.each(function () {
      var nodes = fn.call(result, this, selector, result);
      if (nodes) {
        if (DomQuery.isArray(nodes)) {
          result.push.apply(result, nodes);
        } else {
          result.push(nodes);
        }
      }
    });
    if (this.length &gt; 1) {
      result = DomQuery.unique(result);
      if (name$$1.indexOf(&#39;parents&#39;) === 0 || name$$1 === &#39;prevUntil&#39;) {
        result = result.reverse();
      }
    }
    result = DomQuery(result);
    if (filter) {
      return result.filter(filter);
    }
    return result;
  };
});
DomQuery.fn.is = function (selector) {
  return !!selector &amp;&amp; this.filter(selector).length &gt; 0;
};
DomQuery.fn.init.prototype = DomQuery.fn;
DomQuery.overrideDefaults = function (callback) {
  var defaults;
  var sub = function (selector, context) {
    defaults = defaults || callback();
    if (arguments.length === 0) {
      selector = defaults.element;
    }
    if (!context) {
      context = defaults.context;
    }
    return new sub.fn.init(selector, context);
  };
  DomQuery.extend(sub, this);
  return sub;
};
var appendHooks = function (targetHooks, prop, hooks) {
  each$2(hooks, function (name$$1, func) {
    targetHooks[name$$1] = targetHooks[name$$1] || {};
    targetHooks[name$$1][prop] = func;
  });
};
if (Env.ie &amp;&amp; Env.ie &lt; 8) {
  appendHooks(attrHooks, &#39;get&#39;, {
    maxlength: function (elm) {
      var value = elm.maxLength;
      if (value === 2147483647) {
        return undefined;
      }
      return value;
    },
    size: function (elm) {
      var value = elm.size;
      if (value === 20) {
        return undefined;
      }
      return value;
    },
    class: function (elm) {
      return elm.className;
    },
    style: function (elm) {
      var value = elm.style.cssText;
      if (value.length === 0) {
        return undefined;
      }
      return value;
    }
  });
  appendHooks(attrHooks, &#39;set&#39;, {
    class: function (elm, value) {
      elm.className = value;
    },
    style: function (elm, value) {
      elm.style.cssText = value;
    }
  });
}
if (Env.ie &amp;&amp; Env.ie &lt; 9) {
  cssFix.float = &#39;styleFloat&#39;;
  appendHooks(cssHooks, &#39;set&#39;, {
    opacity: function (elm, value) {
      var style = elm.style;
      if (value === null || value === &#39;&#39;) {
        style.removeAttribute(&#39;filter&#39;);
      } else {
        style.zoom = 1;
        style.filter = &#39;alpha(opacity=&#39; + value * 100 + &#39;)&#39;;
      }
    }
  });
}
DomQuery.attrHooks = attrHooks;
DomQuery.cssHooks = cssHooks;

var cached = function (f) {
  var called = false;
  var r;
  return function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!called) {
      called = true;
      r = f.apply(null, args);
    }
    return r;
  };
};

var firstMatch = function (regexes, s) {
  for (var i = 0; i &lt; regexes.length; i++) {
    var x = regexes[i];
    if (x.test(s))
      return x;
  }
  return undefined;
};
var find$2 = function (regexes, agent) {
  var r = firstMatch(regexes, agent);
  if (!r)
    return {
      major: 0,
      minor: 0
    };
  var group = function (i) {
    return Number(agent.replace(r, &#39;$&#39; + i));
  };
  return nu(group(1), group(2));
};
var detect = function (versionRegexes, agent) {
  var cleanedAgent = String(agent).toLowerCase();
  if (versionRegexes.length === 0)
    return unknown();
  return find$2(versionRegexes, cleanedAgent);
};
var unknown = function () {
  return nu(0, 0);
};
var nu = function (major, minor) {
  return {
    major: major,
    minor: minor
  };
};
var Version = {
  nu: nu,
  detect: detect,
  unknown: unknown
};

var edge = &#39;Edge&#39;;
var chrome = &#39;Chrome&#39;;
var ie$1 = &#39;IE&#39;;
var opera$1 = &#39;Opera&#39;;
var firefox = &#39;Firefox&#39;;
var safari = &#39;Safari&#39;;
var isBrowser = function (name, current) {
  return function () {
    return current === name;
  };
};
var unknown$1 = function () {
  return nu$1({
    current: undefined,
    version: Version.unknown()
  });
};
var nu$1 = function (info) {
  var current = info.current;
  var version = info.version;
  return {
    current: current,
    version: version,
    isEdge: isBrowser(edge, current),
    isChrome: isBrowser(chrome, current),
    isIE: isBrowser(ie$1, current),
    isOpera: isBrowser(opera$1, current),
    isFirefox: isBrowser(firefox, current),
    isSafari: isBrowser(safari, current)
  };
};
var Browser = {
  unknown: unknown$1,
  nu: nu$1,
  edge: constant(edge),
  chrome: constant(chrome),
  ie: constant(ie$1),
  opera: constant(opera$1),
  firefox: constant(firefox),
  safari: constant(safari)
};

var windows = &#39;Windows&#39;;
var ios = &#39;iOS&#39;;
var android$1 = &#39;Android&#39;;
var linux = &#39;Linux&#39;;
var osx = &#39;OSX&#39;;
var solaris = &#39;Solaris&#39;;
var freebsd = &#39;FreeBSD&#39;;
var isOS = function (name, current) {
  return function () {
    return current === name;
  };
};
var unknown$2 = function () {
  return nu$2({
    current: undefined,
    version: Version.unknown()
  });
};
var nu$2 = function (info) {
  var current = info.current;
  var version = info.version;
  return {
    current: current,
    version: version,
    isWindows: isOS(windows, current),
    isiOS: isOS(ios, current),
    isAndroid: isOS(android$1, current),
    isOSX: isOS(osx, current),
    isLinux: isOS(linux, current),
    isSolaris: isOS(solaris, current),
    isFreeBSD: isOS(freebsd, current)
  };
};
var OperatingSystem = {
  unknown: unknown$2,
  nu: nu$2,
  windows: constant(windows),
  ios: constant(ios),
  android: constant(android$1),
  linux: constant(linux),
  osx: constant(osx),
  solaris: constant(solaris),
  freebsd: constant(freebsd)
};

var DeviceType = function (os, browser, userAgent) {
  var isiPad = os.isiOS() &amp;&amp; /ipad/i.test(userAgent) === true;
  var isiPhone = os.isiOS() &amp;&amp; !isiPad;
  var isAndroid3 = os.isAndroid() &amp;&amp; os.version.major === 3;
  var isAndroid4 = os.isAndroid() &amp;&amp; os.version.major === 4;
  var isTablet = isiPad || isAndroid3 || isAndroid4 &amp;&amp; /mobile/i.test(userAgent) === true;
  var isTouch = os.isiOS() || os.isAndroid();
  var isPhone = isTouch &amp;&amp; !isTablet;
  var iOSwebview = browser.isSafari() &amp;&amp; os.isiOS() &amp;&amp; /safari/i.test(userAgent) === false;
  return {
    isiPad: constant(isiPad),
    isiPhone: constant(isiPhone),
    isTablet: constant(isTablet),
    isPhone: constant(isPhone),
    isTouch: constant(isTouch),
    isAndroid: os.isAndroid,
    isiOS: os.isiOS,
    isWebView: constant(iOSwebview)
  };
};

var detect$1 = function (candidates, userAgent) {
  var agent = String(userAgent).toLowerCase();
  return find(candidates, function (candidate) {
    return candidate.search(agent);
  });
};
var detectBrowser = function (browsers, userAgent) {
  return detect$1(browsers, userAgent).map(function (browser) {
    var version = Version.detect(browser.versionRegexes, userAgent);
    return {
      current: browser.name,
      version: version
    };
  });
};
var detectOs = function (oses, userAgent) {
  return detect$1(oses, userAgent).map(function (os) {
    var version = Version.detect(os.versionRegexes, userAgent);
    return {
      current: os.name,
      version: version
    };
  });
};
var UaString = {
  detectBrowser: detectBrowser,
  detectOs: detectOs
};

var contains$2 = function (str, substr) {
  return str.indexOf(substr) !== -1;
};
var trim$2 = function (str) {
  return str.replace(/^\s+|\s+$/g, &#39;&#39;);
};
var lTrim = function (str) {
  return str.replace(/^\s+/g, &#39;&#39;);
};
var rTrim = function (str) {
  return str.replace(/\s+$/g, &#39;&#39;);
};

var normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
var checkContains = function (target) {
  return function (uastring) {
    return contains$2(uastring, target);
  };
};
var browsers = [
  {
    name: &#39;Edge&#39;,
    versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
    search: function (uastring) {
      var monstrosity = contains$2(uastring, &#39;edge/&#39;) &amp;&amp; contains$2(uastring, &#39;chrome&#39;) &amp;&amp; contains$2(uastring, &#39;safari&#39;) &amp;&amp; contains$2(uastring, &#39;applewebkit&#39;);
      return monstrosity;
    }
  },
  {
    name: &#39;Chrome&#39;,
    versionRegexes: [
      /.*?chrome\/([0-9]+)\.([0-9]+).*/,
      normalVersionRegex
    ],
    search: function (uastring) {
      return contains$2(uastring, &#39;chrome&#39;) &amp;&amp; !contains$2(uastring, &#39;chromeframe&#39;);
    }
  },
  {
    name: &#39;IE&#39;,
    versionRegexes: [
      /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
      /.*?rv:([0-9]+)\.([0-9]+).*/
    ],
    search: function (uastring) {
      return contains$2(uastring, &#39;msie&#39;) || contains$2(uastring, &#39;trident&#39;);
    }
  },
  {
    name: &#39;Opera&#39;,
    versionRegexes: [
      normalVersionRegex,
      /.*?opera\/([0-9]+)\.([0-9]+).*/
    ],
    search: checkContains(&#39;opera&#39;)
  },
  {
    name: &#39;Firefox&#39;,
    versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
    search: checkContains(&#39;firefox&#39;)
  },
  {
    name: &#39;Safari&#39;,
    versionRegexes: [
      normalVersionRegex,
      /.*?cpu os ([0-9]+)_([0-9]+).*/
    ],
    search: function (uastring) {
      return (contains$2(uastring, &#39;safari&#39;) || contains$2(uastring, &#39;mobile/&#39;)) &amp;&amp; contains$2(uastring, &#39;applewebkit&#39;);
    }
  }
];
var oses = [
  {
    name: &#39;Windows&#39;,
    search: checkContains(&#39;win&#39;),
    versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
  },
  {
    name: &#39;iOS&#39;,
    search: function (uastring) {
      return contains$2(uastring, &#39;iphone&#39;) || contains$2(uastring, &#39;ipad&#39;);
    },
    versionRegexes: [
      /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
      /.*cpu os ([0-9]+)_([0-9]+).*/,
      /.*cpu iphone os ([0-9]+)_([0-9]+).*/
    ]
  },
  {
    name: &#39;Android&#39;,
    search: checkContains(&#39;android&#39;),
    versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
  },
  {
    name: &#39;OSX&#39;,
    search: checkContains(&#39;os x&#39;),
    versionRegexes: [/.*?os\ x\ ?([0-9]+)_([0-9]+).*/]
  },
  {
    name: &#39;Linux&#39;,
    search: checkContains(&#39;linux&#39;),
    versionRegexes: []
  },
  {
    name: &#39;Solaris&#39;,
    search: checkContains(&#39;sunos&#39;),
    versionRegexes: []
  },
  {
    name: &#39;FreeBSD&#39;,
    search: checkContains(&#39;freebsd&#39;),
    versionRegexes: []
  }
];
var PlatformInfo = {
  browsers: constant(browsers),
  oses: constant(oses)
};

var detect$2 = function (userAgent) {
  var browsers = PlatformInfo.browsers();
  var oses = PlatformInfo.oses();
  var browser = UaString.detectBrowser(browsers, userAgent).fold(Browser.unknown, Browser.nu);
  var os = UaString.detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
  var deviceType = DeviceType(os, browser, userAgent);
  return {
    browser: browser,
    os: os,
    deviceType: deviceType
  };
};
var PlatformDetection = { detect: detect$2 };

var detect$3 = cached(function () {
  var userAgent = navigator.userAgent;
  return PlatformDetection.detect(userAgent);
});
var PlatformDetection$1 = { detect: detect$3 };

var fromHtml = function (html, scope) {
  var doc = scope || document;
  var div = doc.createElement(&#39;div&#39;);
  div.innerHTML = html;
  if (!div.hasChildNodes() || div.childNodes.length &gt; 1) {
    console.error(&#39;HTML does not have a single root node&#39;, html);
    throw &#39;HTML must have a single root node&#39;;
  }
  return fromDom(div.childNodes[0]);
};
var fromTag = function (tag, scope) {
  var doc = scope || document;
  var node = doc.createElement(tag);
  return fromDom(node);
};
var fromText = function (text, scope) {
  var doc = scope || document;
  var node = doc.createTextNode(text);
  return fromDom(node);
};
var fromDom = function (node) {
  if (node === null || node === undefined)
    throw new Error(&#39;Node cannot be null or undefined&#39;);
  return { dom: constant(node) };
};
var fromPoint = function (docElm, x, y) {
  var doc = docElm.dom();
  return Option.from(doc.elementFromPoint(x, y)).map(fromDom);
};
var Element$$1 = {
  fromHtml: fromHtml,
  fromTag: fromTag,
  fromText: fromText,
  fromDom: fromDom,
  fromPoint: fromPoint
};

var ATTRIBUTE = Node.ATTRIBUTE_NODE;
var CDATA_SECTION = Node.CDATA_SECTION_NODE;
var COMMENT = Node.COMMENT_NODE;
var DOCUMENT = Node.DOCUMENT_NODE;
var DOCUMENT_TYPE = Node.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT = Node.DOCUMENT_FRAGMENT_NODE;
var ELEMENT = Node.ELEMENT_NODE;
var TEXT = Node.TEXT_NODE;
var PROCESSING_INSTRUCTION = Node.PROCESSING_INSTRUCTION_NODE;
var ENTITY_REFERENCE = Node.ENTITY_REFERENCE_NODE;
var ENTITY = Node.ENTITY_NODE;
var NOTATION = Node.NOTATION_NODE;

var name = function (element) {
  var r = element.dom().nodeName;
  return r.toLowerCase();
};
var type = function (element) {
  return element.dom().nodeType;
};
var isType$1 = function (t) {
  return function (element) {
    return type(element) === t;
  };
};
var isElement = isType$1(ELEMENT);
var isText = isType$1(TEXT);

var keys = Object.keys;
var hasOwnProperty$1 = Object.hasOwnProperty;
var each$3 = function (obj, f) {
  var props = keys(obj);
  for (var k = 0, len = props.length; k &lt; len; k++) {
    var i = props[k];
    var x = obj[i];
    f(x, i, obj);
  }
};
var map$2 = function (obj, f) {
  return tupleMap(obj, function (x, i, obj) {
    return {
      k: i,
      v: f(x, i, obj)
    };
  });
};
var tupleMap = function (obj, f) {
  var r = {};
  each$3(obj, function (x, i) {
    var tuple = f(x, i, obj);
    r[tuple.k] = tuple.v;
  });
  return r;
};
var bifilter = function (obj, pred) {
  var t = {};
  var f = {};
  each$3(obj, function (x, i) {
    var branch = pred(x, i) ? t : f;
    branch[i] = x;
  });
  return {
    t: t,
    f: f
  };
};
var has = function (obj, key) {
  return hasOwnProperty$1.call(obj, key);
};

var rawSet = function (dom, key, value$$1) {
  if (isString(value$$1) || isBoolean(value$$1) || isNumber(value$$1)) {
    dom.setAttribute(key, value$$1 + &#39;&#39;);
  } else {
    console.error(&#39;Invalid call to Attr.set. Key &#39;, key, &#39;:: Value &#39;, value$$1, &#39;:: Element &#39;, dom);
    throw new Error(&#39;Attribute value was not simple&#39;);
  }
};
var set = function (element, key, value$$1) {
  rawSet(element.dom(), key, value$$1);
};
var setAll = function (element, attrs) {
  var dom = element.dom();
  each$3(attrs, function (v, k) {
    rawSet(dom, k, v);
  });
};
var get$1 = function (element, key) {
  var v = element.dom().getAttribute(key);
  return v === null ? undefined : v;
};
var has$1 = function (element, key) {
  var dom = element.dom();
  return dom &amp;&amp; dom.hasAttribute ? dom.hasAttribute(key) : false;
};
var remove = function (element, key) {
  element.dom().removeAttribute(key);
};

var inBody = function (element) {
  var dom = isText(element) ? element.dom().parentNode : element.dom();
  return dom !== undefined &amp;&amp; dom !== null &amp;&amp; dom.ownerDocument.body.contains(dom);
};

var isSupported = function (dom) {
  return dom.style !== undefined;
};

var internalSet = function (dom, property, value$$1) {
  if (!isString(value$$1)) {
    console.error(&#39;Invalid call to CSS.set. Property &#39;, property, &#39;:: Value &#39;, value$$1, &#39;:: Element &#39;, dom);
    throw new Error(&#39;CSS value must be a string: &#39; + value$$1);
  }
  if (isSupported(dom))
    dom.style.setProperty(property, value$$1);
};
var setAll$1 = function (element, css) {
  var dom = element.dom();
  each$3(css, function (v, k) {
    internalSet(dom, k, v);
  });
};
var get$2 = function (element, property) {
  var dom = element.dom();
  var styles = window.getComputedStyle(dom);
  var r = styles.getPropertyValue(property);
  var v = r === &#39;&#39; &amp;&amp; !inBody(element) ? getUnsafeProperty(dom, property) : r;
  return v === null ? undefined : v;
};
var getUnsafeProperty = function (dom, property) {
  return isSupported(dom) ? dom.style.getPropertyValue(property) : &#39;&#39;;
};
var getRaw = function (element, property) {
  var dom = element.dom();
  var raw = getUnsafeProperty(dom, property);
  return Option.from(raw).filter(function (r) {
    return r.length &gt; 0;
  });
};

var Immutable = function () {
  var fields = [];
  for (var _i = 0; _i &lt; arguments.length; _i++) {
    fields[_i] = arguments[_i];
  }
  return function () {
    var values = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    if (fields.length !== values.length) {
      throw new Error(&#39;Wrong number of arguments to struct. Expected &quot;[&#39; + fields.length + &#39;]&quot;, got &#39; + values.length + &#39; arguments&#39;);
    }
    var struct = {};
    each(fields, function (name, i) {
      struct[name] = constant(values[i]);
    });
    return struct;
  };
};

var toArray$1 = function (target, f) {
  var r = [];
  var recurse = function (e) {
    r.push(e);
    return f(e);
  };
  var cur = f(target);
  do {
    cur = cur.bind(recurse);
  } while (cur.isSome());
  return r;
};
var Recurse = { toArray: toArray$1 };

var node = function () {
  var f = Global$1.getOrDie(&#39;Node&#39;);
  return f;
};
var compareDocumentPosition = function (a, b, match) {
  return (a.compareDocumentPosition(b) &amp; match) !== 0;
};
var documentPositionPreceding = function (a, b) {
  return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_PRECEDING);
};
var documentPositionContainedBy = function (a, b) {
  return compareDocumentPosition(a, b, node().DOCUMENT_POSITION_CONTAINED_BY);
};
var Node$1 = {
  documentPositionPreceding: documentPositionPreceding,
  documentPositionContainedBy: documentPositionContainedBy
};

var ELEMENT$1 = ELEMENT;
var DOCUMENT$1 = DOCUMENT;
var is$1 = function (element, selector) {
  var elem = element.dom();
  if (elem.nodeType !== ELEMENT$1)
    return false;
  else if (elem.matches !== undefined)
    return elem.matches(selector);
  else if (elem.msMatchesSelector !== undefined)
    return elem.msMatchesSelector(selector);
  else if (elem.webkitMatchesSelector !== undefined)
    return elem.webkitMatchesSelector(selector);
  else if (elem.mozMatchesSelector !== undefined)
    return elem.mozMatchesSelector(selector);
  else
    throw new Error(&#39;Browser lacks native selectors&#39;);
};
var bypassSelector = function (dom) {
  return dom.nodeType !== ELEMENT$1 &amp;&amp; dom.nodeType !== DOCUMENT$1 || dom.childElementCount === 0;
};
var all = function (selector, scope) {
  var base = scope === undefined ? document : scope.dom();
  return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), Element$$1.fromDom);
};
var one = function (selector, scope) {
  var base = scope === undefined ? document : scope.dom();
  return bypassSelector(base) ? Option.none() : Option.from(base.querySelector(selector)).map(Element$$1.fromDom);
};

var eq = function (e1, e2) {
  return e1.dom() === e2.dom();
};
var regularContains = function (e1, e2) {
  var d1 = e1.dom(), d2 = e2.dom();
  return d1 === d2 ? false : d1.contains(d2);
};
var ieContains = function (e1, e2) {
  return Node$1.documentPositionContainedBy(e1.dom(), e2.dom());
};
var browser = PlatformDetection$1.detect().browser;
var contains$3 = browser.isIE() ? ieContains : regularContains;

var owner = function (element) {
  return Element$$1.fromDom(element.dom().ownerDocument);
};
var documentElement = function (element) {
  return Element$$1.fromDom(element.dom().ownerDocument.documentElement);
};
var defaultView = function (element) {
  var el = element.dom();
  var defaultView = el.ownerDocument.defaultView;
  return Element$$1.fromDom(defaultView);
};
var parent = function (element) {
  var dom = element.dom();
  return Option.from(dom.parentNode).map(Element$$1.fromDom);
};
var parents = function (element, isRoot) {
  var stop = isFunction(isRoot) ? isRoot : constant(false);
  var dom = element.dom();
  var ret = [];
  while (dom.parentNode !== null &amp;&amp; dom.parentNode !== undefined) {
    var rawParent = dom.parentNode;
    var parent = Element$$1.fromDom(rawParent);
    ret.push(parent);
    if (stop(parent) === true)
      break;
    else
      dom = rawParent;
  }
  return ret;
};
var prevSibling = function (element) {
  var dom = element.dom();
  return Option.from(dom.previousSibling).map(Element$$1.fromDom);
};
var nextSibling = function (element) {
  var dom = element.dom();
  return Option.from(dom.nextSibling).map(Element$$1.fromDom);
};
var prevSiblings = function (element) {
  return reverse(Recurse.toArray(element, prevSibling));
};
var nextSiblings = function (element) {
  return Recurse.toArray(element, nextSibling);
};
var children = function (element) {
  var dom = element.dom();
  return map(dom.childNodes, Element$$1.fromDom);
};
var child = function (element, index) {
  var children = element.dom().childNodes;
  return Option.from(children[index]).map(Element$$1.fromDom);
};
var firstChild = function (element) {
  return child(element, 0);
};
var lastChild = function (element) {
  return child(element, element.dom().childNodes.length - 1);
};
var childNodesCount = function (element) {
  return element.dom().childNodes.length;
};
var spot = Immutable(&#39;element&#39;, &#39;offset&#39;);

var browser$1 = PlatformDetection$1.detect().browser;
var firstElement = function (nodes) {
  return find(nodes, isElement);
};
var getTableCaptionDeltaY = function (elm) {
  if (browser$1.isFirefox() &amp;&amp; name(elm) === &#39;table&#39;) {
    return firstElement(children(elm)).filter(function (elm) {
      return name(elm) === &#39;caption&#39;;
    }).bind(function (caption) {
      return firstElement(nextSiblings(caption)).map(function (body) {
        var bodyTop = body.dom().offsetTop;
        var captionTop = caption.dom().offsetTop;
        var captionHeight = caption.dom().offsetHeight;
        return bodyTop &lt;= captionTop ? -captionHeight : 0;
      });
    }).getOr(0);
  } else {
    return 0;
  }
};
var getPos = function (body, elm, rootElm) {
  var x = 0, y = 0, offsetParent$$1;
  var doc = body.ownerDocument;
  var pos;
  rootElm = rootElm ? rootElm : body;
  if (elm) {
    if (rootElm === body &amp;&amp; elm.getBoundingClientRect &amp;&amp; get$2(Element$$1.fromDom(body), &#39;position&#39;) === &#39;static&#39;) {
      pos = elm.getBoundingClientRect();
      x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
      y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
      return {
        x: x,
        y: y
      };
    }
    offsetParent$$1 = elm;
    while (offsetParent$$1 &amp;&amp; offsetParent$$1 !== rootElm &amp;&amp; offsetParent$$1.nodeType) {
      x += offsetParent$$1.offsetLeft || 0;
      y += offsetParent$$1.offsetTop || 0;
      offsetParent$$1 = offsetParent$$1.offsetParent;
    }
    offsetParent$$1 = elm.parentNode;
    while (offsetParent$$1 &amp;&amp; offsetParent$$1 !== rootElm &amp;&amp; offsetParent$$1.nodeType) {
      x -= offsetParent$$1.scrollLeft || 0;
      y -= offsetParent$$1.scrollTop || 0;
      offsetParent$$1 = offsetParent$$1.parentNode;
    }
    y += getTableCaptionDeltaY(Element$$1.fromDom(elm));
  }
  return {
    x: x,
    y: y
  };
};
var Position = { getPos: getPos };

var nu$3 = function (baseFn) {
  var data = Option.none();
  var callbacks = [];
  var map$$1 = function (f) {
    return nu$3(function (nCallback) {
      get(function (data) {
        nCallback(f(data));
      });
    });
  };
  var get = function (nCallback) {
    if (isReady())
      call(nCallback);
    else
      callbacks.push(nCallback);
  };
  var set = function (x) {
    data = Option.some(x);
    run(callbacks);
    callbacks = [];
  };
  var isReady = function () {
    return data.isSome();
  };
  var run = function (cbs) {
    each(cbs, call);
  };
  var call = function (cb) {
    data.each(function (x) {
      setTimeout(function () {
        cb(x);
      }, 0);
    });
  };
  baseFn(set);
  return {
    get: get,
    map: map$$1,
    isReady: isReady
  };
};
var pure$1 = function (a) {
  return nu$3(function (callback) {
    callback(a);
  });
};
var LazyValue = {
  nu: nu$3,
  pure: pure$1
};

var bounce = function (f) {
  return function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var me = this;
    setTimeout(function () {
      f.apply(me, args);
    }, 0);
  };
};

var nu$4 = function (baseFn) {
  var get = function (callback) {
    baseFn(bounce(callback));
  };
  var map = function (fab) {
    return nu$4(function (callback) {
      get(function (a) {
        var value = fab(a);
        callback(value);
      });
    });
  };
  var bind = function (aFutureB) {
    return nu$4(function (callback) {
      get(function (a) {
        aFutureB(a).get(callback);
      });
    });
  };
  var anonBind = function (futureB) {
    return nu$4(function (callback) {
      get(function (a) {
        futureB.get(callback);
      });
    });
  };
  var toLazy = function () {
    return LazyValue.nu(get);
  };
  var toCached = function () {
    var cache = null;
    return nu$4(function (callback) {
      if (cache === null) {
        cache = toLazy();
      }
      cache.get(callback);
    });
  };
  return {
    map: map,
    bind: bind,
    anonBind: anonBind,
    toLazy: toLazy,
    toCached: toCached,
    get: get
  };
};
var pure$2 = function (a) {
  return nu$4(function (callback) {
    callback(a);
  });
};
var Future = {
  nu: nu$4,
  pure: pure$2
};

var par = function (asyncValues, nu) {
  return nu(function (callback) {
    var r = [];
    var count = 0;
    var cb = function (i) {
      return function (value) {
        r[i] = value;
        count++;
        if (count &gt;= asyncValues.length) {
          callback(r);
        }
      };
    };
    if (asyncValues.length === 0) {
      callback([]);
    } else {
      each(asyncValues, function (asyncValue, i) {
        asyncValue.get(cb(i));
      });
    }
  });
};

var par$1 = function (futures) {
  return par(futures, Future.nu);
};

var value$1 = function (o) {
  var is = function (v) {
    return o === v;
  };
  var or = function (opt) {
    return value$1(o);
  };
  var orThunk = function (f) {
    return value$1(o);
  };
  var map = function (f) {
    return value$1(f(o));
  };
  var each = function (f) {
    f(o);
  };
  var bind = function (f) {
    return f(o);
  };
  var fold = function (_, onValue) {
    return onValue(o);
  };
  var exists = function (f) {
    return f(o);
  };
  var forall = function (f) {
    return f(o);
  };
  var toOption = function () {
    return Option.some(o);
  };
  return {
    is: is,
    isValue: always,
    isError: never,
    getOr: constant(o),
    getOrThunk: constant(o),
    getOrDie: constant(o),
    or: or,
    orThunk: orThunk,
    fold: fold,
    map: map,
    each: each,
    bind: bind,
    exists: exists,
    forall: forall,
    toOption: toOption
  };
};
var error = function (message) {
  var getOrThunk = function (f) {
    return f();
  };
  var getOrDie = function () {
    return die(String(message))();
  };
  var or = function (opt) {
    return opt;
  };
  var orThunk = function (f) {
    return f();
  };
  var map = function (f) {
    return error(message);
  };
  var bind = function (f) {
    return error(message);
  };
  var fold = function (onError, _) {
    return onError(message);
  };
  return {
    is: never,
    isValue: never,
    isError: always,
    getOr: identity,
    getOrThunk: getOrThunk,
    getOrDie: getOrDie,
    or: or,
    orThunk: orThunk,
    fold: fold,
    map: map,
    each: noop,
    bind: bind,
    exists: never,
    forall: always,
    toOption: Option.none
  };
};
var Result = {
  value: value$1,
  error: error
};

function StyleSheetLoader(document$$1, settings) {
  if (settings === void 0) {
    settings = {};
  }
  var idCount = 0;
  var loadedStates = {};
  var maxLoadTime;
  maxLoadTime = settings.maxLoadTime || 5000;
  var appendToHead = function (node) {
    document$$1.getElementsByTagName(&#39;head&#39;)[0].appendChild(node);
  };
  var load = function (url, loadedCallback, errorCallback) {
    var link, style, startTime, state;
    var passed = function () {
      var callbacks = state.passed;
      var i = callbacks.length;
      while (i--) {
        callbacks[i]();
      }
      state.status = 2;
      state.passed = [];
      state.failed = [];
    };
    var failed = function () {
      var callbacks = state.failed;
      var i = callbacks.length;
      while (i--) {
        callbacks[i]();
      }
      state.status = 3;
      state.passed = [];
      state.failed = [];
    };
    var isOldWebKit = function () {
      var webKitChunks = navigator.userAgent.match(/WebKit\/(\d*)/);
      return !!(webKitChunks &amp;&amp; parseInt(webKitChunks[1], 10) &lt; 536);
    };
    var wait = function (testCallback, waitCallback) {
      if (!testCallback()) {
        if (new Date().getTime() - startTime &lt; maxLoadTime) {
          Delay.setTimeout(waitCallback);
        } else {
          failed();
        }
      }
    };
    var waitForWebKitLinkLoaded = function () {
      wait(function () {
        var styleSheets = document$$1.styleSheets;
        var styleSheet, i = styleSheets.length, owner;
        while (i--) {
          styleSheet = styleSheets[i];
          owner = styleSheet.ownerNode ? styleSheet.ownerNode : styleSheet.owningElement;
          if (owner &amp;&amp; owner.id === link.id) {
            passed();
            return true;
          }
        }
      }, waitForWebKitLinkLoaded);
    };
    var waitForGeckoLinkLoaded = function () {
      wait(function () {
        try {
          var cssRules = style.sheet.cssRules;
          passed();
          return !!cssRules;
        } catch (ex) {
        }
      }, waitForGeckoLinkLoaded);
    };
    url = Tools._addCacheSuffix(url);
    if (!loadedStates[url]) {
      state = {
        passed: [],
        failed: []
      };
      loadedStates[url] = state;
    } else {
      state = loadedStates[url];
    }
    if (loadedCallback) {
      state.passed.push(loadedCallback);
    }
    if (errorCallback) {
      state.failed.push(errorCallback);
    }
    if (state.status === 1) {
      return;
    }
    if (state.status === 2) {
      passed();
      return;
    }
    if (state.status === 3) {
      failed();
      return;
    }
    state.status = 1;
    link = document$$1.createElement(&#39;link&#39;);
    link.rel = &#39;stylesheet&#39;;
    link.type = &#39;text/css&#39;;
    link.id = &#39;u&#39; + idCount++;
    link.async = false;
    link.defer = false;
    startTime = new Date().getTime();
    if (settings.contentCssCors) {
      link.crossOrigin = &#39;anonymous&#39;;
    }
    if (&#39;onload&#39; in link &amp;&amp; !isOldWebKit()) {
      link.onload = waitForWebKitLinkLoaded;
      link.onerror = failed;
    } else {
      if (navigator.userAgent.indexOf(&#39;Firefox&#39;) &gt; 0) {
        style = document$$1.createElement(&#39;style&#39;);
        style.textContent = &#39;@import &quot;&#39; + url + &#39;&quot;&#39;;
        waitForGeckoLinkLoaded();
        appendToHead(style);
        return;
      }
      waitForWebKitLinkLoaded();
    }
    appendToHead(link);
    link.href = url;
  };
  var loadF = function (url) {
    return Future.nu(function (resolve) {
      load(url, compose(resolve, constant(Result.value(url))), compose(resolve, constant(Result.error(url))));
    });
  };
  var unbox = function (result) {
    return result.fold(identity, identity);
  };
  var loadAll = function (urls, success, failure) {
    par$1(map(urls, loadF)).get(function (result) {
      var parts = partition(result, function (r) {
        return r.isValue();
      });
      if (parts.fail.length &gt; 0) {
        failure(parts.fail.map(unbox));
      } else {
        success(parts.pass.map(unbox));
      }
    });
  };
  return {
    load: load,
    loadAll: loadAll
  };
}

function TreeWalker (startNode, rootNode) {
  var node = startNode;
  var findSibling = function (node, startName, siblingName, shallow) {
    var sibling, parent;
    if (node) {
      if (!shallow &amp;&amp; node[startName]) {
        return node[startName];
      }
      if (node !== rootNode) {
        sibling = node[siblingName];
        if (sibling) {
          return sibling;
        }
        for (parent = node.parentNode; parent &amp;&amp; parent !== rootNode; parent = parent.parentNode) {
          sibling = parent[siblingName];
          if (sibling) {
            return sibling;
          }
        }
      }
    }
  };
  var findPreviousNode = function (node, startName, siblingName, shallow) {
    var sibling, parent, child;
    if (node) {
      sibling = node[siblingName];
      if (rootNode &amp;&amp; sibling === rootNode) {
        return;
      }
      if (sibling) {
        if (!shallow) {
          for (child = sibling[startName]; child; child = child[startName]) {
            if (!child[startName]) {
              return child;
            }
          }
        }
        return sibling;
      }
      parent = node.parentNode;
      if (parent &amp;&amp; parent !== rootNode) {
        return parent;
      }
    }
  };
  this.current = function () {
    return node;
  };
  this.next = function (shallow) {
    node = findSibling(node, &#39;firstChild&#39;, &#39;nextSibling&#39;, shallow);
    return node;
  };
  this.prev = function (shallow) {
    node = findSibling(node, &#39;lastChild&#39;, &#39;previousSibling&#39;, shallow);
    return node;
  };
  this.prev2 = function (shallow) {
    node = findPreviousNode(node, &#39;lastChild&#39;, &#39;previousSibling&#39;, shallow);
    return node;
  };
}

var blocks = [
  &#39;article&#39;,
  &#39;aside&#39;,
  &#39;details&#39;,
  &#39;div&#39;,
  &#39;dt&#39;,
  &#39;figcaption&#39;,
  &#39;footer&#39;,
  &#39;form&#39;,
  &#39;fieldset&#39;,
  &#39;header&#39;,
  &#39;hgroup&#39;,
  &#39;html&#39;,
  &#39;main&#39;,
  &#39;nav&#39;,
  &#39;section&#39;,
  &#39;summary&#39;,
  &#39;body&#39;,
  &#39;p&#39;,
  &#39;dl&#39;,
  &#39;multicol&#39;,
  &#39;dd&#39;,
  &#39;figure&#39;,
  &#39;address&#39;,
  &#39;center&#39;,
  &#39;blockquote&#39;,
  &#39;h1&#39;,
  &#39;h2&#39;,
  &#39;h3&#39;,
  &#39;h4&#39;,
  &#39;h5&#39;,
  &#39;h6&#39;,
  &#39;listing&#39;,
  &#39;xmp&#39;,
  &#39;pre&#39;,
  &#39;plaintext&#39;,
  &#39;menu&#39;,
  &#39;dir&#39;,
  &#39;ul&#39;,
  &#39;ol&#39;,
  &#39;li&#39;,
  &#39;hr&#39;,
  &#39;table&#39;,
  &#39;tbody&#39;,
  &#39;thead&#39;,
  &#39;tfoot&#39;,
  &#39;th&#39;,
  &#39;tr&#39;,
  &#39;td&#39;,
  &#39;caption&#39;
];
var voids = [
  &#39;area&#39;,
  &#39;base&#39;,
  &#39;basefont&#39;,
  &#39;br&#39;,
  &#39;col&#39;,
  &#39;frame&#39;,
  &#39;hr&#39;,
  &#39;img&#39;,
  &#39;input&#39;,
  &#39;isindex&#39;,
  &#39;link&#39;,
  &#39;meta&#39;,
  &#39;param&#39;,
  &#39;embed&#39;,
  &#39;source&#39;,
  &#39;wbr&#39;,
  &#39;track&#39;
];
var tableCells = [
  &#39;td&#39;,
  &#39;th&#39;
];
var tableSections = [
  &#39;thead&#39;,
  &#39;tbody&#39;,
  &#39;tfoot&#39;
];
var textBlocks = [
  &#39;h1&#39;,
  &#39;h2&#39;,
  &#39;h3&#39;,
  &#39;h4&#39;,
  &#39;h5&#39;,
  &#39;h6&#39;,
  &#39;p&#39;,
  &#39;div&#39;,
  &#39;address&#39;,
  &#39;pre&#39;,
  &#39;form&#39;,
  &#39;blockquote&#39;,
  &#39;center&#39;,
  &#39;dir&#39;,
  &#39;fieldset&#39;,
  &#39;header&#39;,
  &#39;footer&#39;,
  &#39;article&#39;,
  &#39;section&#39;,
  &#39;hgroup&#39;,
  &#39;aside&#39;,
  &#39;nav&#39;,
  &#39;figure&#39;
];
var headings = [
  &#39;h1&#39;,
  &#39;h2&#39;,
  &#39;h3&#39;,
  &#39;h4&#39;,
  &#39;h5&#39;,
  &#39;h6&#39;
];
var listItems = [
  &#39;li&#39;,
  &#39;dd&#39;,
  &#39;dt&#39;
];
var lists = [
  &#39;ul&#39;,
  &#39;ol&#39;,
  &#39;dl&#39;
];
var wsElements = [
  &#39;pre&#39;,
  &#39;script&#39;,
  &#39;textarea&#39;,
  &#39;style&#39;
];
var lazyLookup = function (items) {
  var lookup;
  return function (node) {
    lookup = lookup ? lookup : mapToObject(items, constant(true));
    return lookup.hasOwnProperty(name(node));
  };
};
var isHeading = lazyLookup(headings);
var isBlock = lazyLookup(blocks);
var isInline = function (node) {
  return isElement(node) &amp;&amp; !isBlock(node);
};
var isBr = function (node) {
  return isElement(node) &amp;&amp; name(node) === &#39;br&#39;;
};
var isTextBlock = lazyLookup(textBlocks);
var isList = lazyLookup(lists);
var isListItem = lazyLookup(listItems);
var isVoid = lazyLookup(voids);
var isTableSection = lazyLookup(tableSections);
var isTableCell = lazyLookup(tableCells);
var isWsPreserveElement = lazyLookup(wsElements);

var isNodeType = function (type) {
  return function (node) {
    return !!node &amp;&amp; node.nodeType === type;
  };
};
var isElement$1 = isNodeType(1);
var matchNodeNames = function (names) {
  var items = names.toLowerCase().split(&#39; &#39;);
  return function (node) {
    var i, name;
    if (node &amp;&amp; node.nodeType) {
      name = node.nodeName.toLowerCase();
      for (i = 0; i &lt; items.length; i++) {
        if (name === items[i]) {
          return true;
        }
      }
    }
    return false;
  };
};
var matchStyleValues = function (name, values) {
  var items = values.toLowerCase().split(&#39; &#39;);
  return function (node) {
    var i, cssValue;
    if (isElement$1(node)) {
      for (i = 0; i &lt; items.length; i++) {
        var computed = node.ownerDocument.defaultView.getComputedStyle(node, null);
        cssValue = computed ? computed.getPropertyValue(name) : null;
        if (cssValue === items[i]) {
          return true;
        }
      }
    }
    return false;
  };
};
var hasPropValue = function (propName, propValue) {
  return function (node) {
    return isElement$1(node) &amp;&amp; node[propName] === propValue;
  };
};
var hasAttribute = function (attrName, attrValue) {
  return function (node) {
    return isElement$1(node) &amp;&amp; node.hasAttribute(attrName);
  };
};
var hasAttributeValue = function (attrName, attrValue) {
  return function (node) {
    return isElement$1(node) &amp;&amp; node.getAttribute(attrName) === attrValue;
  };
};
var isBogus = function (node) {
  return isElement$1(node) &amp;&amp; node.hasAttribute(&#39;data-mce-bogus&#39;);
};
var isBogusAll = function (node) {
  return isElement$1(node) &amp;&amp; node.getAttribute(&#39;data-mce-bogus&#39;) === &#39;all&#39;;
};
var isTable = function (node) {
  return isElement$1(node) &amp;&amp; node.tagName === &#39;TABLE&#39;;
};
var hasContentEditableState = function (value) {
  return function (node) {
    if (isElement$1(node)) {
      if (node.contentEditable === value) {
        return true;
      }
      if (node.getAttribute(&#39;data-mce-contenteditable&#39;) === value) {
        return true;
      }
    }
    return false;
  };
};
var isText$1 = isNodeType(3);
var isComment$1 = isNodeType(8);
var isDocument$1 = isNodeType(9);
var isBr$1 = matchNodeNames(&#39;br&#39;);
var isContentEditableTrue = hasContentEditableState(&#39;true&#39;);
var isContentEditableFalse = hasContentEditableState(&#39;false&#39;);
var NodeType = {
  isText: isText$1,
  isElement: isElement$1,
  isComment: isComment$1,
  isDocument: isDocument$1,
  isBr: isBr$1,
  isContentEditableTrue: isContentEditableTrue,
  isContentEditableFalse: isContentEditableFalse,
  matchNodeNames: matchNodeNames,
  hasPropValue: hasPropValue,
  hasAttribute: hasAttribute,
  hasAttributeValue: hasAttributeValue,
  matchStyleValues: matchStyleValues,
  isBogus: isBogus,
  isBogusAll: isBogusAll,
  isTable: isTable
};

var surroundedBySpans = function (node) {
  var previousIsSpan = node.previousSibling &amp;&amp; node.previousSibling.nodeName === &#39;SPAN&#39;;
  var nextIsSpan = node.nextSibling &amp;&amp; node.nextSibling.nodeName === &#39;SPAN&#39;;
  return previousIsSpan &amp;&amp; nextIsSpan;
};
var isBookmarkNode = function (node) {
  return node &amp;&amp; node.tagName === &#39;SPAN&#39; &amp;&amp; node.getAttribute(&#39;data-mce-type&#39;) === &#39;bookmark&#39;;
};
var trimNode = function (dom, node) {
  var i, children = node.childNodes;
  if (NodeType.isElement(node) &amp;&amp; isBookmarkNode(node)) {
    return;
  }
  for (i = children.length - 1; i &gt;= 0; i--) {
    trimNode(dom, children[i]);
  }
  if (NodeType.isDocument(node) === false) {
    if (NodeType.isText(node) &amp;&amp; node.nodeValue.length &gt; 0) {
      var trimmedLength = Tools.trim(node.nodeValue).length;
      if (dom.isBlock(node.parentNode) || trimmedLength &gt; 0) {
        return;
      }
      if (trimmedLength === 0 &amp;&amp; surroundedBySpans(node)) {
        return;
      }
    } else if (NodeType.isElement(node)) {
      children = node.childNodes;
      if (children.length === 1 &amp;&amp; isBookmarkNode(children[0])) {
        node.parentNode.insertBefore(children[0], node);
      }
      if (children.length || isVoid(Element$$1.fromDom(node))) {
        return;
      }
    }
    dom.remove(node);
  }
  return node;
};
var TrimNode = { trimNode: trimNode };

var makeMap$1 = Tools.makeMap;
var namedEntities, baseEntities, reverseEntities;
var attrsCharsRegExp = /[&amp;&lt;&gt;\&quot;\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var textCharsRegExp = /[&lt;&gt;&amp;\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var rawCharsRegExp = /[&lt;&gt;&amp;\&quot;\&#39;]/g;
var entityRegExp = /&amp;#([a-z0-9]+);?|&amp;([a-z0-9]+);/gi;
var asciiMap = {
  128: &#39;\u20AC&#39;,
  130: &#39;\u201A&#39;,
  131: &#39;\u0192&#39;,
  132: &#39;\u201E&#39;,
  133: &#39;\u2026&#39;,
  134: &#39;\u2020&#39;,
  135: &#39;\u2021&#39;,
  136: &#39;\u02c6&#39;,
  137: &#39;\u2030&#39;,
  138: &#39;\u0160&#39;,
  139: &#39;\u2039&#39;,
  140: &#39;\u0152&#39;,
  142: &#39;\u017d&#39;,
  145: &#39;\u2018&#39;,
  146: &#39;\u2019&#39;,
  147: &#39;\u201C&#39;,
  148: &#39;\u201D&#39;,
  149: &#39;\u2022&#39;,
  150: &#39;\u2013&#39;,
  151: &#39;\u2014&#39;,
  152: &#39;\u02DC&#39;,
  153: &#39;\u2122&#39;,
  154: &#39;\u0161&#39;,
  155: &#39;\u203A&#39;,
  156: &#39;\u0153&#39;,
  158: &#39;\u017e&#39;,
  159: &#39;\u0178&#39;
};
baseEntities = {
  &#39;&quot;&#39;: &#39;&amp;quot;&#39;,
  &#39;\&#39;&#39;: &#39;&amp;#39;&#39;,
  &#39;&lt;&#39;: &#39;&amp;lt;&#39;,
  &#39;&gt;&#39;: &#39;&amp;gt;&#39;,
  &#39;&amp;&#39;: &#39;&amp;amp;&#39;,
  &#39;`&#39;: &#39;&amp;#96;&#39;
};
reverseEntities = {
  &#39;&amp;lt;&#39;: &#39;&lt;&#39;,
  &#39;&amp;gt;&#39;: &#39;&gt;&#39;,
  &#39;&amp;amp;&#39;: &#39;&amp;&#39;,
  &#39;&amp;quot;&#39;: &#39;&quot;&#39;,
  &#39;&amp;apos;&#39;: &#39;\&#39;&#39;
};
var nativeDecode = function (text) {
  var elm;
  elm = Element$$1.fromTag(&#39;div&#39;).dom();
  elm.innerHTML = text;
  return elm.textContent || elm.innerText || text;
};
var buildEntitiesLookup = function (items, radix) {
  var i, chr, entity;
  var lookup = {};
  if (items) {
    items = items.split(&#39;,&#39;);
    radix = radix || 10;
    for (i = 0; i &lt; items.length; i += 2) {
      chr = String.fromCharCode(parseInt(items[i], radix));
      if (!baseEntities[chr]) {
        entity = &#39;&amp;&#39; + items[i + 1] + &#39;;&#39;;
        lookup[chr] = entity;
        lookup[entity] = chr;
      }
    }
    return lookup;
  }
};
namedEntities = buildEntitiesLookup(&#39;50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,&#39; + &#39;5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,&#39; + &#39;5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,&#39; + &#39;5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,&#39; + &#39;68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,&#39; + &#39;6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,&#39; + &#39;6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,&#39; + &#39;75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,&#39; + &#39;7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,&#39; + &#39;7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,&#39; + &#39;sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,&#39; + &#39;st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,&#39; + &#39;t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,&#39; + &#39;tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,&#39; + &#39;u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,&#39; + &#39;81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,&#39; + &#39;8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,&#39; + &#39;8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,&#39; + &#39;8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,&#39; + &#39;8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,&#39; + &#39;nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,&#39; + &#39;rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,&#39; + &#39;Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,&#39; + &#39;80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,&#39; + &#39;811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro&#39;, 32);
var encodeRaw = function (text, attr) {
  return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
    return baseEntities[chr] || chr;
  });
};
var encodeAllRaw = function (text) {
  return (&#39;&#39; + text).replace(rawCharsRegExp, function (chr) {
    return baseEntities[chr] || chr;
  });
};
var encodeNumeric = function (text, attr) {
  return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
    if (chr.length &gt; 1) {
      return &#39;&amp;#&#39; + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + &#39;;&#39;;
    }
    return baseEntities[chr] || &#39;&amp;#&#39; + chr.charCodeAt(0) + &#39;;&#39;;
  });
};
var encodeNamed = function (text, attr, entities) {
  entities = entities || namedEntities;
  return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
    return baseEntities[chr] || entities[chr] || chr;
  });
};
var getEncodeFunc = function (name, entities) {
  var entitiesMap = buildEntitiesLookup(entities) || namedEntities;
  var encodeNamedAndNumeric = function (text, attr) {
    return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
      if (baseEntities[chr] !== undefined) {
        return baseEntities[chr];
      }
      if (entitiesMap[chr] !== undefined) {
        return entitiesMap[chr];
      }
      if (chr.length &gt; 1) {
        return &#39;&amp;#&#39; + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + &#39;;&#39;;
      }
      return &#39;&amp;#&#39; + chr.charCodeAt(0) + &#39;;&#39;;
    });
  };
  var encodeCustomNamed = function (text, attr) {
    return encodeNamed(text, attr, entitiesMap);
  };
  var nameMap = makeMap$1(name.replace(/\+/g, &#39;,&#39;));
  if (nameMap.named &amp;&amp; nameMap.numeric) {
    return encodeNamedAndNumeric;
  }
  if (nameMap.named) {
    if (entities) {
      return encodeCustomNamed;
    }
    return encodeNamed;
  }
  if (nameMap.numeric) {
    return encodeNumeric;
  }
  return encodeRaw;
};
var decode = function (text) {
  return text.replace(entityRegExp, function (all, numeric) {
    if (numeric) {
      if (numeric.charAt(0).toLowerCase() === &#39;x&#39;) {
        numeric = parseInt(numeric.substr(1), 16);
      } else {
        numeric = parseInt(numeric, 10);
      }
      if (numeric &gt; 65535) {
        numeric -= 65536;
        return String.fromCharCode(55296 + (numeric &gt;&gt; 10), 56320 + (numeric &amp; 1023));
      }
      return asciiMap[numeric] || String.fromCharCode(numeric);
    }
    return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
  });
};
var Entities = {
  encodeRaw: encodeRaw,
  encodeAllRaw: encodeAllRaw,
  encodeNumeric: encodeNumeric,
  encodeNamed: encodeNamed,
  getEncodeFunc: getEncodeFunc,
  decode: decode
};

var mapCache = {}, dummyObj = {};
var makeMap$2 = Tools.makeMap, each$4 = Tools.each, extend$1 = Tools.extend, explode$1 = Tools.explode, inArray$1 = Tools.inArray;
var split = function (items, delim) {
  items = Tools.trim(items);
  return items ? items.split(delim || &#39; &#39;) : [];
};
var compileSchema = function (type) {
  var schema = {};
  var globalAttributes, blockContent;
  var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
  var add = function (name, attributes, children) {
    var ni, attributesOrder, element;
    var arrayToMap = function (array, obj) {
      var map = {};
      var i, l;
      for (i = 0, l = array.length; i &lt; l; i++) {
        map[array[i]] = obj || {};
      }
      return map;
    };
    children = children || [];
    attributes = attributes || &#39;&#39;;
    if (typeof children === &#39;string&#39;) {
      children = split(children);
    }
    name = split(name);
    ni = name.length;
    while (ni--) {
      attributesOrder = split([
        globalAttributes,
        attributes
      ].join(&#39; &#39;));
      element = {
        attributes: arrayToMap(attributesOrder),
        attributesOrder: attributesOrder,
        children: arrayToMap(children, dummyObj)
      };
      schema[name[ni]] = element;
    }
  };
  var addAttrs = function (name, attributes) {
    var ni, schemaItem, i, l;
    name = split(name);
    ni = name.length;
    attributes = split(attributes);
    while (ni--) {
      schemaItem = schema[name[ni]];
      for (i = 0, l = attributes.length; i &lt; l; i++) {
        schemaItem.attributes[attributes[i]] = {};
        schemaItem.attributesOrder.push(attributes[i]);
      }
    }
  };
  if (mapCache[type]) {
    return mapCache[type];
  }
  globalAttributes = &#39;id accesskey class dir lang style tabindex title role&#39;;
  blockContent = &#39;address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul&#39;;
  phrasingContent = &#39;a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd &#39; + &#39;label map noscript object q s samp script select small span strong sub sup &#39; + &#39;textarea u var #text #comment&#39;;
  if (type !== &#39;html4&#39;) {
    globalAttributes += &#39; contenteditable contextmenu draggable dropzone &#39; + &#39;hidden spellcheck translate&#39;;
    blockContent += &#39; article aside details dialog figure main header footer hgroup section nav&#39;;
    phrasingContent += &#39; audio canvas command datalist mark meter output picture &#39; + &#39;progress time wbr video ruby bdi keygen&#39;;
  }
  if (type !== &#39;html5-strict&#39;) {
    globalAttributes += &#39; xml:lang&#39;;
    html4PhrasingContent = &#39;acronym applet basefont big font strike tt&#39;;
    phrasingContent = [
      phrasingContent,
      html4PhrasingContent
    ].join(&#39; &#39;);
    each$4(split(html4PhrasingContent), function (name) {
      add(name, &#39;&#39;, phrasingContent);
    });
    html4BlockContent = &#39;center dir isindex noframes&#39;;
    blockContent = [
      blockContent,
      html4BlockContent
    ].join(&#39; &#39;);
    flowContent = [
      blockContent,
      phrasingContent
    ].join(&#39; &#39;);
    each$4(split(html4BlockContent), function (name) {
      add(name, &#39;&#39;, flowContent);
    });
  }
  flowContent = flowContent || [
    blockContent,
    phrasingContent
  ].join(&#39; &#39;);
  add(&#39;html&#39;, &#39;manifest&#39;, &#39;head body&#39;);
  add(&#39;head&#39;, &#39;&#39;, &#39;bitters command link meta noscript script style title&#39;);
  add(&#39;title hr noscript br&#39;);
  add(&#39;base&#39;, &#39;href target&#39;);
  add(&#39;link&#39;, &#39;href rel media hreflang type sizes hreflang&#39;);
  add(&#39;meta&#39;, &#39;name http-equiv content charset&#39;);
  add(&#39;style&#39;, &#39;media type scoped&#39;);
  add(&#39;script&#39;, &#39;src async defer type charset&#39;);
  add(&#39;body&#39;, &#39;onafterprint onbeforeprint onbeforeunload onblur onerror onfocus &#39; + &#39;onhashchange onload onmessage onoffline ononline onpagehide onpageshow &#39; + &#39;onpopstate onresize onscroll onstorage onunload&#39;, flowContent);
  add(&#39;address dt dd div caption&#39;, &#39;&#39;, flowContent);
  add(&#39;h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn&#39;, &#39;&#39;, phrasingContent);
  add(&#39;blockquote&#39;, &#39;cite&#39;, flowContent);
  add(&#39;ol&#39;, &#39;reversed start type&#39;, &#39;li&#39;);
  add(&#39;ul&#39;, &#39;&#39;, &#39;li&#39;);
  add(&#39;li&#39;, &#39;value&#39;, flowContent);
  add(&#39;dl&#39;, &#39;&#39;, &#39;dt dd&#39;);
  add(&#39;a&#39;, &#39;href target rel media hreflang type&#39;, phrasingContent);
  add(&#39;q&#39;, &#39;cite&#39;, phrasingContent);
  add(&#39;ins del&#39;, &#39;cite datetime&#39;, flowContent);
  add(&#39;img&#39;, &#39;src sizes srcset alt usemap ismap width height&#39;);
  add(&#39;iframe&#39;, &#39;src name width height&#39;, flowContent);
  add(&#39;embed&#39;, &#39;src type width height&#39;);
  add(&#39;object&#39;, &#39;data type typemustmatch name usemap form width height&#39;, [
    flowContent,
    &#39;param&#39;
  ].join(&#39; &#39;));
  add(&#39;param&#39;, &#39;name value&#39;);
  add(&#39;map&#39;, &#39;name&#39;, [
    flowContent,
    &#39;area&#39;
  ].join(&#39; &#39;));
  add(&#39;area&#39;, &#39;alt coords shape href target rel media hreflang type&#39;);
  add(&#39;table&#39;, &#39;border&#39;, &#39;caption colgroup thead tfoot tbody tr&#39; + (type === &#39;html4&#39; ? &#39; col&#39; : &#39;&#39;));
  add(&#39;colgroup&#39;, &#39;span&#39;, &#39;col&#39;);
  add(&#39;col&#39;, &#39;span&#39;);
  add(&#39;tbody thead tfoot&#39;, &#39;&#39;, &#39;tr&#39;);
  add(&#39;tr&#39;, &#39;&#39;, &#39;td th&#39;);
  add(&#39;td&#39;, &#39;colspan rowspan headers&#39;, flowContent);
  add(&#39;th&#39;, &#39;colspan rowspan headers scope abbr&#39;, flowContent);
  add(&#39;form&#39;, &#39;accept-charset action autocomplete enctype method name novalidate target&#39;, flowContent);
  add(&#39;fieldset&#39;, &#39;disabled form name&#39;, [
    flowContent,
    &#39;legend&#39;
  ].join(&#39; &#39;));
  add(&#39;label&#39;, &#39;form for&#39;, phrasingContent);
  add(&#39;input&#39;, &#39;accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate &#39; + &#39;formtarget height list max maxlength min multiple name pattern readonly required size src step type value width&#39;);
  add(&#39;button&#39;, &#39;disabled form formaction formenctype formmethod formnovalidate formtarget name type value&#39;, type === &#39;html4&#39; ? flowContent : phrasingContent);
  add(&#39;select&#39;, &#39;disabled form multiple name required size&#39;, &#39;option optgroup&#39;);
  add(&#39;optgroup&#39;, &#39;disabled label&#39;, &#39;option&#39;);
  add(&#39;option&#39;, &#39;disabled label selected value&#39;);
  add(&#39;textarea&#39;, &#39;cols dirname disabled form maxlength name readonly required rows wrap&#39;);
  add(&#39;menu&#39;, &#39;type label&#39;, [
    flowContent,
    &#39;li&#39;
  ].join(&#39; &#39;));
  add(&#39;noscript&#39;, &#39;&#39;, flowContent);
  if (type !== &#39;html4&#39;) {
    add(&#39;wbr&#39;);
    add(&#39;ruby&#39;, &#39;&#39;, [
      phrasingContent,
      &#39;rt rp&#39;
    ].join(&#39; &#39;));
    add(&#39;figcaption&#39;, &#39;&#39;, flowContent);
    add(&#39;mark rt rp summary bdi&#39;, &#39;&#39;, phrasingContent);
    add(&#39;canvas&#39;, &#39;width height&#39;, flowContent);
    add(&#39;video&#39;, &#39;src crossorigin poster preload autoplay mediagroup loop &#39; + &#39;muted controls width height buffered&#39;, [
      flowContent,
      &#39;track source&#39;
    ].join(&#39; &#39;));
    add(&#39;audio&#39;, &#39;src crossorigin preload autoplay mediagroup loop muted controls &#39; + &#39;buffered volume&#39;, [
      flowContent,
      &#39;track source&#39;
    ].join(&#39; &#39;));
    add(&#39;picture&#39;, &#39;&#39;, &#39;img source&#39;);
    add(&#39;source&#39;, &#39;src srcset type media sizes&#39;);
    add(&#39;track&#39;, &#39;kind src srclang label default&#39;);
    add(&#39;datalist&#39;, &#39;&#39;, [
      phrasingContent,
      &#39;option&#39;
    ].join(&#39; &#39;));
    add(&#39;article section nav aside main header footer&#39;, &#39;&#39;, flowContent);
    add(&#39;hgroup&#39;, &#39;&#39;, &#39;h1 h2 h3 h4 h5 h6&#39;);
    add(&#39;figure&#39;, &#39;&#39;, [
      flowContent,
      &#39;figcaption&#39;
    ].join(&#39; &#39;));
    add(&#39;time&#39;, &#39;datetime&#39;, phrasingContent);
    add(&#39;dialog&#39;, &#39;open&#39;, flowContent);
    add(&#39;command&#39;, &#39;type label icon disabled checked radiogroup command&#39;);
    add(&#39;output&#39;, &#39;for form name&#39;, phrasingContent);
    add(&#39;progress&#39;, &#39;value max&#39;, phrasingContent);
    add(&#39;meter&#39;, &#39;value min max low high optimum&#39;, phrasingContent);
    add(&#39;details&#39;, &#39;open&#39;, [
      flowContent,
      &#39;summary&#39;
    ].join(&#39; &#39;));
    add(&#39;keygen&#39;, &#39;autofocus challenge disabled form keytype name&#39;);
  }
  if (type !== &#39;html5-strict&#39;) {
    addAttrs(&#39;script&#39;, &#39;language xml:space&#39;);
    addAttrs(&#39;style&#39;, &#39;xml:space&#39;);
    addAttrs(&#39;object&#39;, &#39;declare classid code codebase codetype archive standby align border hspace vspace&#39;);
    addAttrs(&#39;embed&#39;, &#39;align name hspace vspace&#39;);
    addAttrs(&#39;param&#39;, &#39;valuetype type&#39;);
    addAttrs(&#39;a&#39;, &#39;charset name rev shape coords&#39;);
    addAttrs(&#39;br&#39;, &#39;clear&#39;);
    addAttrs(&#39;applet&#39;, &#39;codebase archive code object alt name width height align hspace vspace&#39;);
    addAttrs(&#39;img&#39;, &#39;name longdesc align border hspace vspace&#39;);
    addAttrs(&#39;iframe&#39;, &#39;longdesc frameborder marginwidth marginheight scrolling align&#39;);
    addAttrs(&#39;font basefont&#39;, &#39;size color face&#39;);
    addAttrs(&#39;input&#39;, &#39;usemap align&#39;);
    addAttrs(&#39;select&#39;, &#39;onchange&#39;);
    addAttrs(&#39;textarea&#39;);
    addAttrs(&#39;h1 h2 h3 h4 h5 h6 div p legend caption&#39;, &#39;align&#39;);
    addAttrs(&#39;ul&#39;, &#39;type compact&#39;);
    addAttrs(&#39;li&#39;, &#39;type&#39;);
    addAttrs(&#39;ol dl menu dir&#39;, &#39;compact&#39;);
    addAttrs(&#39;pre&#39;, &#39;width xml:space&#39;);
    addAttrs(&#39;hr&#39;, &#39;align noshade size width&#39;);
    addAttrs(&#39;isindex&#39;, &#39;prompt&#39;);
    addAttrs(&#39;table&#39;, &#39;summary width frame rules cellspacing cellpadding align bgcolor&#39;);
    addAttrs(&#39;col&#39;, &#39;width align char charoff valign&#39;);
    addAttrs(&#39;colgroup&#39;, &#39;width align char charoff valign&#39;);
    addAttrs(&#39;thead&#39;, &#39;align char charoff valign&#39;);
    addAttrs(&#39;tr&#39;, &#39;align char charoff valign bgcolor&#39;);
    addAttrs(&#39;th&#39;, &#39;axis align char charoff valign nowrap bgcolor width height&#39;);
    addAttrs(&#39;form&#39;, &#39;accept&#39;);
    addAttrs(&#39;td&#39;, &#39;abbr axis scope align char charoff valign nowrap bgcolor width height&#39;);
    addAttrs(&#39;tfoot&#39;, &#39;align char charoff valign&#39;);
    addAttrs(&#39;tbody&#39;, &#39;align char charoff valign&#39;);
    addAttrs(&#39;area&#39;, &#39;nohref&#39;);
    addAttrs(&#39;body&#39;, &#39;background bgcolor text link vlink alink&#39;);
  }
  if (type !== &#39;html4&#39;) {
    addAttrs(&#39;input button select textarea&#39;, &#39;autofocus&#39;);
    addAttrs(&#39;input textarea&#39;, &#39;placeholder&#39;);
    addAttrs(&#39;a&#39;, &#39;download&#39;);
    addAttrs(&#39;link script img&#39;, &#39;crossorigin&#39;);
    addAttrs(&#39;iframe&#39;, &#39;sandbox seamless allowfullscreen&#39;);
  }
  each$4(split(&#39;a form meter progress dfn&#39;), function (name) {
    if (schema[name]) {
      delete schema[name].children[name];
    }
  });
  delete schema.caption.children.table;
  delete schema.script;
  mapCache[type] = schema;
  return schema;
};
var compileElementMap = function (value, mode) {
  var styles;
  if (value) {
    styles = {};
    if (typeof value === &#39;string&#39;) {
      value = { &#39;*&#39;: value };
    }
    each$4(value, function (value, key) {
      styles[key] = styles[key.toUpperCase()] = mode === &#39;map&#39; ? makeMap$2(value, /[, ]/) : explode$1(value, /[, ]/);
    });
  }
  return styles;
};
function Schema(settings) {
  var elements = {};
  var children = {};
  var patternElements = [];
  var validStyles;
  var invalidStyles;
  var schemaItems;
  var whiteSpaceElementsMap, selfClosingElementsMap, shortEndedElementsMap, boolAttrMap, validClasses;
  var blockElementsMap, nonEmptyElementsMap, moveCaretBeforeOnEnterElementsMap, textBlockElementsMap, textInlineElementsMap;
  var customElementsMap = {}, specialElements = {};
  var createLookupTable = function (option, defaultValue, extendWith) {
    var value = settings[option];
    if (!value) {
      value = mapCache[option];
      if (!value) {
        value = makeMap$2(defaultValue, &#39; &#39;, makeMap$2(defaultValue.toUpperCase(), &#39; &#39;));
        value = extend$1(value, extendWith);
        mapCache[option] = value;
      }
    } else {
      value = makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));
    }
    return value;
  };
  settings = settings || {};
  schemaItems = compileSchema(settings.schema);
  if (settings.verify_html === false) {
    settings.valid_elements = &#39;*[*]&#39;;
  }
  validStyles = compileElementMap(settings.valid_styles);
  invalidStyles = compileElementMap(settings.invalid_styles, &#39;map&#39;);
  validClasses = compileElementMap(settings.valid_classes, &#39;map&#39;);
  whiteSpaceElementsMap = createLookupTable(&#39;whitespace_elements&#39;, &#39;pre script noscript style textarea video audio iframe object code&#39;);
  selfClosingElementsMap = createLookupTable(&#39;self_closing_elements&#39;, &#39;colgroup dd dt li option p td tfoot th thead tr&#39;);
  shortEndedElementsMap = createLookupTable(&#39;short_ended_elements&#39;, &#39;area bitters basefont br col frame hr img input isindex link &#39; + &#39;meta param embed source wbr track&#39;);
  boolAttrMap = createLookupTable(&#39;boolean_attributes&#39;, &#39;checked compact declare defer disabled ismap multiple nohref noresize &#39; + &#39;noshade nowrap readonly selected autoplay loop controls&#39;);
  nonEmptyElementsMap = createLookupTable(&#39;non_empty_elements&#39;, &#39;td th iframe video audio object &#39; + &#39;script pre code&#39;, shortEndedElementsMap);
  moveCaretBeforeOnEnterElementsMap = createLookupTable(&#39;move_caret_before_on_enter_elements&#39;, &#39;table&#39;, nonEmptyElementsMap);
  textBlockElementsMap = createLookupTable(&#39;text_block_elements&#39;, &#39;h1 h2 h3 h4 h5 h6 p div address pre form &#39; + &#39;blockquote center dir fieldset header footer article section hgroup aside main nav figure&#39;);
  blockElementsMap = createLookupTable(&#39;block_elements&#39;, &#39;hr table tbody thead tfoot &#39; + &#39;th tr td li ol ul caption dl dt dd noscript menu isindex option &#39; + &#39;datalist select optgroup figcaption details summary&#39;, textBlockElementsMap);
  textInlineElementsMap = createLookupTable(&#39;text_inline_elements&#39;, &#39;span strong b em i font strike u var cite &#39; + &#39;dfn code mark q sup sub samp&#39;);
  each$4((settings.special || &#39;script noscript noframes noembed title style textarea xmp&#39;).split(&#39; &#39;), function (name) {
    specialElements[name] = new RegExp(&#39;&lt;/&#39; + name + &#39;[^&gt;]*&gt;&#39;, &#39;gi&#39;);
  });
  var patternToRegExp = function (str) {
    return new RegExp(&#39;^&#39; + str.replace(/([?+*])/g, &#39;.$1&#39;) + &#39;$&#39;);
  };
  var addValidElements = function (validElements) {
    var ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, key, value;
    var elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)\])?$/, attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=:&lt;]+)?(?:([=:&lt;])(.*))?$/, hasPatternsRegExp = /[*?+]/;
    if (validElements) {
      validElements = split(validElements, &#39;,&#39;);
      if (elements[&#39;@&#39;]) {
        globalAttributes = elements[&#39;@&#39;].attributes;
        globalAttributesOrder = elements[&#39;@&#39;].attributesOrder;
      }
      for (ei = 0, el = validElements.length; ei &lt; el; ei++) {
        matches = elementRuleRegExp.exec(validElements[ei]);
        if (matches) {
          prefix = matches[1];
          elementName = matches[2];
          outputName = matches[3];
          attrData = matches[5];
          attributes = {};
          attributesOrder = [];
          element = {
            attributes: attributes,
            attributesOrder: attributesOrder
          };
          if (prefix === &#39;#&#39;) {
            element.paddEmpty = true;
          }
          if (prefix === &#39;-&#39;) {
            element.removeEmpty = true;
          }
          if (matches[4] === &#39;!&#39;) {
            element.removeEmptyAttrs = true;
          }
          if (globalAttributes) {
            for (key in globalAttributes) {
              attributes[key] = globalAttributes[key];
            }
            attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
          }
          if (attrData) {
            attrData = split(attrData, &#39;|&#39;);
            for (ai = 0, al = attrData.length; ai &lt; al; ai++) {
              matches = attrRuleRegExp.exec(attrData[ai]);
              if (matches) {
                attr = {};
                attrType = matches[1];
                attrName = matches[2].replace(/[\\:]:/g, &#39;:&#39;);
                prefix = matches[3];
                value = matches[4];
                if (attrType === &#39;!&#39;) {
                  element.attributesRequired = element.attributesRequired || [];
                  element.attributesRequired.push(attrName);
                  attr.required = true;
                }
                if (attrType === &#39;-&#39;) {
                  delete attributes[attrName];
                  attributesOrder.splice(inArray$1(attributesOrder, attrName), 1);
                  continue;
                }
                if (prefix) {
                  if (prefix === &#39;=&#39;) {
                    element.attributesDefault = element.attributesDefault || [];
                    element.attributesDefault.push({
                      name: attrName,
                      value: value
                    });
                    attr.defaultValue = value;
                  }
                  if (prefix === &#39;:&#39;) {
                    element.attributesForced = element.attributesForced || [];
                    element.attributesForced.push({
                      name: attrName,
                      value: value
                    });
                    attr.forcedValue = value;
                  }
                  if (prefix === &#39;&lt;&#39;) {
                    attr.validValues = makeMap$2(value, &#39;?&#39;);
                  }
                }
                if (hasPatternsRegExp.test(attrName)) {
                  element.attributePatterns = element.attributePatterns || [];
                  attr.pattern = patternToRegExp(attrName);
                  element.attributePatterns.push(attr);
                } else {
                  if (!attributes[attrName]) {
                    attributesOrder.push(attrName);
                  }
                  attributes[attrName] = attr;
                }
              }
            }
          }
          if (!globalAttributes &amp;&amp; elementName === &#39;@&#39;) {
            globalAttributes = attributes;
            globalAttributesOrder = attributesOrder;
          }
          if (outputName) {
            element.outputName = elementName;
            elements[outputName] = element;
          }
          if (hasPatternsRegExp.test(elementName)) {
            element.pattern = patternToRegExp(elementName);
            patternElements.push(element);
          } else {
            elements[elementName] = element;
          }
        }
      }
    }
  };
  var setValidElements = function (validElements) {
    elements = {};
    patternElements = [];
    addValidElements(validElements);
    each$4(schemaItems, function (element, name) {
      children[name] = element.children;
    });
  };
  var addCustomElements = function (customElements) {
    var customElementRegExp = /^(~)?(.+)$/;
    if (customElements) {
      mapCache.text_block_elements = mapCache.block_elements = null;
      each$4(split(customElements, &#39;,&#39;), function (rule) {
        var matches = customElementRegExp.exec(rule), inline = matches[1] === &#39;~&#39;, cloneName = inline ? &#39;span&#39; : &#39;div&#39;, name = matches[2];
        children[name] = children[cloneName];
        customElementsMap[name] = cloneName;
        if (!inline) {
          blockElementsMap[name.toUpperCase()] = {};
          blockElementsMap[name] = {};
        }
        if (!elements[name]) {
          var customRule = elements[cloneName];
          customRule = extend$1({}, customRule);
          delete customRule.removeEmptyAttrs;
          delete customRule.removeEmpty;
          elements[name] = customRule;
        }
        each$4(children, function (element, elmName) {
          if (element[cloneName]) {
            children[elmName] = element = extend$1({}, children[elmName]);
            element[name] = element[cloneName];
          }
        });
      });
    }
  };
  var addValidChildren = function (validChildren) {
    var childRuleRegExp = /^([+\-]?)(\w+)\[([^\]]+)\]$/;
    mapCache[settings.schema] = null;
    if (validChildren) {
      each$4(split(validChildren, &#39;,&#39;), function (rule) {
        var matches = childRuleRegExp.exec(rule);
        var parent, prefix;
        if (matches) {
          prefix = matches[1];
          if (prefix) {
            parent = children[matches[2]];
          } else {
            parent = children[matches[2]] = { &#39;#comment&#39;: {} };
          }
          parent = children[matches[2]];
          each$4(split(matches[3], &#39;|&#39;), function (child) {
            if (prefix === &#39;-&#39;) {
              delete parent[child];
            } else {
              parent[child] = {};
            }
          });
        }
      });
    }
  };
  var getElementRule = function (name) {
    var element = elements[name], i;
    if (element) {
      return element;
    }
    i = patternElements.length;
    while (i--) {
      element = patternElements[i];
      if (element.pattern.test(name)) {
        return element;
      }
    }
  };
  if (!settings.valid_elements) {
    each$4(schemaItems, function (element, name) {
      elements[name] = {
        attributes: element.attributes,
        attributesOrder: element.attributesOrder
      };
      children[name] = element.children;
    });
    if (settings.schema !== &#39;html5&#39;) {
      each$4(split(&#39;strong/b em/i&#39;), function (item) {
        item = split(item, &#39;/&#39;);
        elements[item[1]].outputName = item[0];
      });
    }
    each$4(split(&#39;ol ul sub sup blockquote span font a table tbody tr strong em b i&#39;), function (name) {
      if (elements[name]) {
        elements[name].removeEmpty = true;
      }
    });
    each$4(split(&#39;p h1 h2 h3 h4 h5 h6 th td pre div address caption li&#39;), function (name) {
      elements[name].paddEmpty = true;
    });
    each$4(split(&#39;span&#39;), function (name) {
      elements[name].removeEmptyAttrs = true;
    });
  } else {
    setValidElements(settings.valid_elements);
  }
  addCustomElements(settings.custom_elements);
  addValidChildren(settings.valid_children);
  addValidElements(settings.extended_valid_elements);
  addValidChildren(&#39;+ol[ul|ol],+ul[ul|ol]&#39;);
  each$4({
    dd: &#39;dl&#39;,
    dt: &#39;dl&#39;,
    li: &#39;ul ol&#39;,
    td: &#39;tr&#39;,
    th: &#39;tr&#39;,
    tr: &#39;tbody thead tfoot&#39;,
    tbody: &#39;table&#39;,
    thead: &#39;table&#39;,
    tfoot: &#39;table&#39;,
    legend: &#39;fieldset&#39;,
    area: &#39;map&#39;,
    param: &#39;video audio object&#39;
  }, function (parents, item) {
    if (elements[item]) {
      elements[item].parentsRequired = split(parents);
    }
  });
  if (settings.invalid_elements) {
    each$4(explode$1(settings.invalid_elements), function (item) {
      if (elements[item]) {
        delete elements[item];
      }
    });
  }
  if (!getElementRule(&#39;span&#39;)) {
    addValidElements(&#39;span[!data-mce-type|*]&#39;);
  }
  var getValidStyles = function () {
    return validStyles;
  };
  var getInvalidStyles = function () {
    return invalidStyles;
  };
  var getValidClasses = function () {
    return validClasses;
  };
  var getBoolAttrs = function () {
    return boolAttrMap;
  };
  var getBlockElements = function () {
    return blockElementsMap;
  };
  var getTextBlockElements = function () {
    return textBlockElementsMap;
  };
  var getTextInlineElements = function () {
    return textInlineElementsMap;
  };
  var getShortEndedElements = function () {
    return shortEndedElementsMap;
  };
  var getSelfClosingElements = function () {
    return selfClosingElementsMap;
  };
  var getNonEmptyElements = function () {
    return nonEmptyElementsMap;
  };
  var getMoveCaretBeforeOnEnterElements = function () {
    return moveCaretBeforeOnEnterElementsMap;
  };
  var getWhiteSpaceElements = function () {
    return whiteSpaceElementsMap;
  };
  var getSpecialElements = function () {
    return specialElements;
  };
  var isValidChild = function (name, child) {
    var parent = children[name.toLowerCase()];
    return !!(parent &amp;&amp; parent[child.toLowerCase()]);
  };
  var isValid = function (name, attr) {
    var attrPatterns, i;
    var rule = getElementRule(name);
    if (rule) {
      if (attr) {
        if (rule.attributes[attr]) {
          return true;
        }
        attrPatterns = rule.attributePatterns;
        if (attrPatterns) {
          i = attrPatterns.length;
          while (i--) {
            if (attrPatterns[i].pattern.test(name)) {
              return true;
            }
          }
        }
      } else {
        return true;
      }
    }
    return false;
  };
  var getCustomElements = function () {
    return customElementsMap;
  };
  return {
    children: children,
    elements: elements,
    getValidStyles: getValidStyles,
    getValidClasses: getValidClasses,
    getBlockElements: getBlockElements,
    getInvalidStyles: getInvalidStyles,
    getShortEndedElements: getShortEndedElements,
    getTextBlockElements: getTextBlockElements,
    getTextInlineElements: getTextInlineElements,
    getBoolAttrs: getBoolAttrs,
    getElementRule: getElementRule,
    getSelfClosingElements: getSelfClosingElements,
    getNonEmptyElements: getNonEmptyElements,
    getMoveCaretBeforeOnEnterElements: getMoveCaretBeforeOnEnterElements,
    getWhiteSpaceElements: getWhiteSpaceElements,
    getSpecialElements: getSpecialElements,
    isValidChild: isValidChild,
    isValid: isValid,
    getCustomElements: getCustomElements,
    addValidElements: addValidElements,
    setValidElements: setValidElements,
    addCustomElements: addCustomElements,
    addValidChildren: addValidChildren
  };
}

var toHex = function (match, r, g, b) {
  var hex = function (val) {
    val = parseInt(val, 10).toString(16);
    return val.length &gt; 1 ? val : &#39;0&#39; + val;
  };
  return &#39;#&#39; + hex(r) + hex(g) + hex(b);
};
function Styles(settings, schema) {
  var rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
  var urlOrStrRegExp = /(?:url(?:(?:\(\s*\&quot;([^\&quot;]+)\&quot;\s*\))|(?:\(\s*\&#39;([^\&#39;]+)\&#39;\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\&#39;([^\&#39;]+)\&#39;)|(?:\&quot;([^\&quot;]+)\&quot;)/gi;
  var styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
  var trimRightRegExp = /\s+$/;
  var i;
  var encodingLookup = {};
  var encodingItems;
  var validStyles;
  var invalidStyles;
  var invisibleChar = &#39;\uFEFF&#39;;
  settings = settings || {};
  if (schema) {
    validStyles = schema.getValidStyles();
    invalidStyles = schema.getInvalidStyles();
  }
  encodingItems = (&#39;\\&quot; \\\&#39; \\; \\: ; : &#39; + invisibleChar).split(&#39; &#39;);
  for (i = 0; i &lt; encodingItems.length; i++) {
    encodingLookup[encodingItems[i]] = invisibleChar + i;
    encodingLookup[invisibleChar + i] = encodingItems[i];
  }
  return {
    toHex: function (color) {
      return color.replace(rgbRegExp, toHex);
    },
    parse: function (css) {
      var styles = {};
      var matches, name, value, isEncoded;
      var urlConverter = settings.url_converter;
      var urlConverterScope = settings.url_converter_scope || this;
      var compress = function (prefix, suffix, noJoin) {
        var top, right, bottom, left;
        top = styles[prefix + &#39;-top&#39; + suffix];
        if (!top) {
          return;
        }
        right = styles[prefix + &#39;-right&#39; + suffix];
        if (!right) {
          return;
        }
        bottom = styles[prefix + &#39;-bottom&#39; + suffix];
        if (!bottom) {
          return;
        }
        left = styles[prefix + &#39;-left&#39; + suffix];
        if (!left) {
          return;
        }
        var box = [
          top,
          right,
          bottom,
          left
        ];
        i = box.length - 1;
        while (i--) {
          if (box[i] !== box[i + 1]) {
            break;
          }
        }
        if (i &gt; -1 &amp;&amp; noJoin) {
          return;
        }
        styles[prefix + suffix] = i === -1 ? box[0] : box.join(&#39; &#39;);
        delete styles[prefix + &#39;-top&#39; + suffix];
        delete styles[prefix + &#39;-right&#39; + suffix];
        delete styles[prefix + &#39;-bottom&#39; + suffix];
        delete styles[prefix + &#39;-left&#39; + suffix];
      };
      var canCompress = function (key) {
        var value = styles[key], i;
        if (!value) {
          return;
        }
        value = value.split(&#39; &#39;);
        i = value.length;
        while (i--) {
          if (value[i] !== value[0]) {
            return false;
          }
        }
        styles[key] = value[0];
        return true;
      };
      var compress2 = function (target, a, b, c) {
        if (!canCompress(a)) {
          return;
        }
        if (!canCompress(b)) {
          return;
        }
        if (!canCompress(c)) {
          return;
        }
        styles[target] = styles[a] + &#39; &#39; + styles[b] + &#39; &#39; + styles[c];
        delete styles[a];
        delete styles[b];
        delete styles[c];
      };
      var encode = function (str) {
        isEncoded = true;
        return encodingLookup[str];
      };
      var decode = function (str, keepSlashes) {
        if (isEncoded) {
          str = str.replace(/\uFEFF[0-9]/g, function (str) {
            return encodingLookup[str];
          });
        }
        if (!keepSlashes) {
          str = str.replace(/\\([\&#39;\&quot;;:])/g, &#39;$1&#39;);
        }
        return str;
      };
      var decodeSingleHexSequence = function (escSeq) {
        return String.fromCharCode(parseInt(escSeq.slice(1), 16));
      };
      var decodeHexSequences = function (value) {
        return value.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
      };
      var processUrl = function (match, url, url2, url3, str, str2) {
        str = str || str2;
        if (str) {
          str = decode(str);
          return &#39;\&#39;&#39; + str.replace(/\&#39;/g, &#39;\\\&#39;&#39;) + &#39;\&#39;&#39;;
        }
        url = decode(url || url2 || url3);
        if (!settings.allow_script_urls) {
          var scriptUrl = url.replace(/[\s\r\n]+/g, &#39;&#39;);
          if (/(java|vb)script:/i.test(scriptUrl)) {
            return &#39;&#39;;
          }
          if (!settings.allow_svg_data_urls &amp;&amp; /^data:image\/svg/i.test(scriptUrl)) {
            return &#39;&#39;;
          }
        }
        if (urlConverter) {
          url = urlConverter.call(urlConverterScope, url, &#39;style&#39;);
        }
        return &#39;url(\&#39;&#39; + url.replace(/\&#39;/g, &#39;\\\&#39;&#39;) + &#39;\&#39;)&#39;;
      };
      if (css) {
        css = css.replace(/[\u0000-\u001F]/g, &#39;&#39;);
        css = css.replace(/\\[\&quot;\&#39;;:\uFEFF]/g, encode).replace(/\&quot;[^\&quot;]+\&quot;|\&#39;[^\&#39;]+\&#39;/g, function (str) {
          return str.replace(/[;:]/g, encode);
        });
        while (matches = styleRegExp.exec(css)) {
          styleRegExp.lastIndex = matches.index + matches[0].length;
          name = matches[1].replace(trimRightRegExp, &#39;&#39;).toLowerCase();
          value = matches[2].replace(trimRightRegExp, &#39;&#39;);
          if (name &amp;&amp; value) {
            name = decodeHexSequences(name);
            value = decodeHexSequences(value);
            if (name.indexOf(invisibleChar) !== -1 || name.indexOf(&#39;&quot;&#39;) !== -1) {
              continue;
            }
            if (!settings.allow_script_urls &amp;&amp; (name === &#39;behavior&#39; || /expression\s*\(|\/\*|\*\//.test(value))) {
              continue;
            }
            if (name === &#39;font-weight&#39; &amp;&amp; value === &#39;700&#39;) {
              value = &#39;bold&#39;;
            } else if (name === &#39;color&#39; || name === &#39;background-color&#39;) {
              value = value.toLowerCase();
            }
            value = value.replace(rgbRegExp, toHex);
            value = value.replace(urlOrStrRegExp, processUrl);
            styles[name] = isEncoded ? decode(value, true) : value;
          }
        }
        compress(&#39;border&#39;, &#39;&#39;, true);
        compress(&#39;border&#39;, &#39;-width&#39;);
        compress(&#39;border&#39;, &#39;-color&#39;);
        compress(&#39;border&#39;, &#39;-style&#39;);
        compress(&#39;padding&#39;, &#39;&#39;);
        compress(&#39;margin&#39;, &#39;&#39;);
        compress2(&#39;border&#39;, &#39;border-width&#39;, &#39;border-style&#39;, &#39;border-color&#39;);
        if (styles.border === &#39;medium none&#39;) {
          delete styles.border;
        }
        if (styles[&#39;border-image&#39;] === &#39;none&#39;) {
          delete styles[&#39;border-image&#39;];
        }
      }
      return styles;
    },
    serialize: function (styles, elementName) {
      var css = &#39;&#39;, name, value;
      var serializeStyles = function (name) {
        var styleList, i, l, value;
        styleList = validStyles[name];
        if (styleList) {
          for (i = 0, l = styleList.length; i &lt; l; i++) {
            name = styleList[i];
            value = styles[name];
            if (value) {
              css += (css.length &gt; 0 ? &#39; &#39; : &#39;&#39;) + name + &#39;: &#39; + value + &#39;;&#39;;
            }
          }
        }
      };
      var isValid = function (name, elementName) {
        var styleMap;
        styleMap = invalidStyles[&#39;*&#39;];
        if (styleMap &amp;&amp; styleMap[name]) {
          return false;
        }
        styleMap = invalidStyles[elementName];
        if (styleMap &amp;&amp; styleMap[name]) {
          return false;
        }
        return true;
      };
      if (elementName &amp;&amp; validStyles) {
        serializeStyles(&#39;*&#39;);
        serializeStyles(elementName);
      } else {
        for (name in styles) {
          value = styles[name];
          if (value &amp;&amp; (!invalidStyles || isValid(name, elementName))) {
            css += (css.length &gt; 0 ? &#39; &#39; : &#39;&#39;) + name + &#39;: &#39; + value + &#39;;&#39;;
          }
        }
      }
      return css;
    }
  };
}

var each$5 = Tools.each;
var grep$1 = Tools.grep;
var isIE = Env.ie;
var simpleSelectorRe = /^([a-z0-9],?)+$/i;
var whiteSpaceRegExp$2 = /^[ \t\r\n]*$/;
var setupAttrHooks = function (styles, settings, getContext) {
  var attrHooks = {};
  var keepValues = settings.keep_values;
  var keepUrlHook = {
    set: function ($elm, value, name$$1) {
      if (settings.url_converter) {
        value = settings.url_converter.call(settings.url_converter_scope || getContext(), value, name$$1, $elm[0]);
      }
      $elm.attr(&#39;data-mce-&#39; + name$$1, value).attr(name$$1, value);
    },
    get: function ($elm, name$$1) {
      return $elm.attr(&#39;data-mce-&#39; + name$$1) || $elm.attr(name$$1);
    }
  };
  attrHooks = {
    style: {
      set: function ($elm, value) {
        if (value !== null &amp;&amp; typeof value === &#39;object&#39;) {
          $elm.css(value);
          return;
        }
        if (keepValues) {
          $elm.attr(&#39;data-mce-style&#39;, value);
        }
        $elm.attr(&#39;style&#39;, value);
      },
      get: function ($elm) {
        var value = $elm.attr(&#39;data-mce-style&#39;) || $elm.attr(&#39;style&#39;);
        value = styles.serialize(styles.parse(value), $elm[0].nodeName);
        return value;
      }
    }
  };
  if (keepValues) {
    attrHooks.href = attrHooks.src = keepUrlHook;
  }
  return attrHooks;
};
var updateInternalStyleAttr = function (styles, $elm) {
  var rawValue = $elm.attr(&#39;style&#39;);
  var value = styles.serialize(styles.parse(rawValue), $elm[0].nodeName);
  if (!value) {
    value = null;
  }
  $elm.attr(&#39;data-mce-style&#39;, value);
};
var findNodeIndex = function (node, normalized) {
  var idx = 0, lastNodeType, nodeType;
  if (node) {
    for (lastNodeType = node.nodeType, node = node.previousSibling; node; node = node.previousSibling) {
      nodeType = node.nodeType;
      if (normalized &amp;&amp; nodeType === 3) {
        if (nodeType === lastNodeType || !node.nodeValue.length) {
          continue;
        }
      }
      idx++;
      lastNodeType = nodeType;
    }
  }
  return idx;
};
function DOMUtils(doc, settings) {
  var _this = this;
  if (settings === void 0) {
    settings = {};
  }
  var attrHooks;
  var addedStyles = {};
  var win = window;
  var files = {};
  var counter = 0;
  var stdMode = true;
  var boxModel = true;
  var styleSheetLoader = StyleSheetLoader(doc, { contentCssCors: settings.contentCssCors });
  var boundEvents = [];
  var schema = settings.schema ? settings.schema : Schema({});
  var styles = Styles({
    url_converter: settings.url_converter,
    url_converter_scope: settings.url_converter_scope
  }, settings.schema);
  var events = settings.ownEvents ? new EventUtils(settings.proxy) : EventUtils.Event;
  var blockElementsMap = schema.getBlockElements();
  var $ = DomQuery.overrideDefaults(function () {
    return {
      context: doc,
      element: self$$1.getRoot()
    };
  });
  var isBlock = function (node) {
    if (typeof node === &#39;string&#39;) {
      return !!blockElementsMap[node];
    } else if (node) {
      var type = node.nodeType;
      if (type) {
        return !!(type === 1 &amp;&amp; blockElementsMap[node.nodeName]);
      }
    }
    return false;
  };
  var get = function (elm) {
    if (elm &amp;&amp; doc &amp;&amp; typeof elm === &#39;string&#39;) {
      var node = doc.getElementById(elm);
      if (node &amp;&amp; node.id !== elm) {
        return doc.getElementsByName(elm)[1];
      } else {
        return node;
      }
    }
    return elm;
  };
  var $$ = function (elm) {
    if (typeof elm === &#39;string&#39;) {
      elm = get(elm);
    }
    return $(elm);
  };
  var getAttrib = function (elm, name$$1, defaultVal) {
    var hook, value;
    var $elm = $$(elm);
    if ($elm.length) {
      hook = attrHooks[name$$1];
      if (hook &amp;&amp; hook.get) {
        value = hook.get($elm, name$$1);
      } else {
        value = $elm.attr(name$$1);
      }
    }
    if (typeof value === &#39;undefined&#39;) {
      value = defaultVal || &#39;&#39;;
    }
    return value;
  };
  var getAttribs = function (elm) {
    var node = get(elm);
    if (!node) {
      return [];
    }
    return node.attributes;
  };
  var setAttrib = function (elm, name$$1, value) {
    var originalValue, hook;
    if (value === &#39;&#39;) {
      value = null;
    }
    var $elm = $$(elm);
    originalValue = $elm.attr(name$$1);
    if (!$elm.length) {
      return;
    }
    hook = attrHooks[name$$1];
    if (hook &amp;&amp; hook.set) {
      hook.set($elm, value, name$$1);
    } else {
      $elm.attr(name$$1, value);
    }
    if (originalValue !== value &amp;&amp; settings.onSetAttrib) {
      settings.onSetAttrib({
        attrElm: $elm,
        attrName: name$$1,
        attrValue: value
      });
    }
  };
  var clone = function (node, deep) {
    if (!isIE || node.nodeType !== 1 || deep) {
      return node.cloneNode(deep);
    }
    if (!deep) {
      var clone_1 = doc.createElement(node.nodeName);
      each$5(getAttribs(node), function (attr) {
        setAttrib(clone_1, attr.nodeName, getAttrib(node, attr.nodeName));
      });
      return clone_1;
    }
    return null;
  };
  var getRoot = function () {
    return settings.root_element || doc.body;
  };
  var getViewPort = function (argWin) {
    var actWin = !argWin ? win : argWin;
    var doc = actWin.document;
    var rootElm = boxModel ? doc.documentElement : doc.body;
    return {
      x: actWin.pageXOffset || rootElm.scrollLeft,
      y: actWin.pageYOffset || rootElm.scrollTop,
      w: actWin.innerWidth || rootElm.clientWidth,
      h: actWin.innerHeight || rootElm.clientHeight
    };
  };
  var getPos = function (elm, rootElm) {
    return Position.getPos(doc.body, get(elm), rootElm);
  };
  var setStyle = function (elm, name$$1, value) {
    var $elm = $$(elm).css(name$$1, value);
    if (settings.update_styles) {
      updateInternalStyleAttr(styles, $elm);
    }
  };
  var setStyles = function (elm, stylesArg) {
    var $elm = $$(elm).css(stylesArg);
    if (settings.update_styles) {
      updateInternalStyleAttr(styles, $elm);
    }
  };
  var getStyle = function (elm, name$$1, computed) {
    var $elm = $$(elm);
    if (computed) {
      return $elm.css(name$$1);
    }
    name$$1 = name$$1.replace(/-(\D)/g, function (a, b) {
      return b.toUpperCase();
    });
    if (name$$1 === &#39;float&#39;) {
      name$$1 = Env.ie &amp;&amp; Env.ie &lt; 12 ? &#39;styleFloat&#39; : &#39;cssFloat&#39;;
    }
    return $elm[0] &amp;&amp; $elm[0].style ? $elm[0].style[name$$1] : undefined;
  };
  var getSize = function (elm) {
    var w, h;
    elm = get(elm);
    w = getStyle(elm, &#39;width&#39;);
    h = getStyle(elm, &#39;height&#39;);
    if (w.indexOf(&#39;px&#39;) === -1) {
      w = 0;
    }
    if (h.indexOf(&#39;px&#39;) === -1) {
      h = 0;
    }
    return {
      w: parseInt(w, 10) || elm.offsetWidth || elm.clientWidth,
      h: parseInt(h, 10) || elm.offsetHeight || elm.clientHeight
    };
  };
  var getRect = function (elm) {
    var pos, size;
    elm = get(elm);
    pos = getPos(elm);
    size = getSize(elm);
    return {
      x: pos.x,
      y: pos.y,
      w: size.w,
      h: size.h
    };
  };
  var is = function (elm, selector) {
    var i;
    if (!elm) {
      return false;
    }
    if (!Array.isArray(elm)) {
      if (selector === &#39;*&#39;) {
        return elm.nodeType === 1;
      }
      if (simpleSelectorRe.test(selector)) {
        var selectors = selector.toLowerCase().split(/,/);
        var elmName = elm.nodeName.toLowerCase();
        for (i = selectors.length - 1; i &gt;= 0; i--) {
          if (selectors[i] === elmName) {
            return true;
          }
        }
        return false;
      }
      if (elm.nodeType &amp;&amp; elm.nodeType !== 1) {
        return false;
      }
    }
    var elms = !Array.isArray(elm) ? [elm] : elm;
    return Sizzle(selector, elms[0].ownerDocument || elms[0], null, elms).length &gt; 0;
  };
  var getParents = function (elm, selector, root, collect) {
    var result = [];
    var selectorVal;
    var node = get(elm);
    collect = collect === undefined;
    root = root || (getRoot().nodeName !== &#39;BODY&#39; ? getRoot().parentNode : null);
    if (Tools.is(selector, &#39;string&#39;)) {
      selectorVal = selector;
      if (selector === &#39;*&#39;) {
        selector = function (node) {
          return node.nodeType === 1;
        };
      } else {
        selector = function (node) {
          return is(node, selectorVal);
        };
      }
    }
    while (node) {
      if (node === root || !node.nodeType || node.nodeType === 9) {
        break;
      }
      if (!selector || typeof selector === &#39;function&#39; &amp;&amp; selector(node)) {
        if (collect) {
          result.push(node);
        } else {
          return [node];
        }
      }
      node = node.parentNode;
    }
    return collect ? result : null;
  };
  var getParent = function (node, selector, root) {
    var parents = getParents(node, selector, root, false);
    return parents &amp;&amp; parents.length &gt; 0 ? parents[0] : null;
  };
  var _findSib = function (node, selector, name$$1) {
    var func = selector;
    if (node) {
      if (typeof selector === &#39;string&#39;) {
        func = function (node) {
          return is(node, selector);
        };
      }
      for (node = node[name$$1]; node; node = node[name$$1]) {
        if (typeof func === &#39;function&#39; &amp;&amp; func(node)) {
          return node;
        }
      }
    }
    return null;
  };
  var getNext = function (node, selector) {
    return _findSib(node, selector, &#39;nextSibling&#39;);
  };
  var getPrev = function (node, selector) {
    return _findSib(node, selector, &#39;previousSibling&#39;);
  };
  var select = function (selector, scope) {
    return Sizzle(selector, get(scope) || settings.root_element || doc, []);
  };
  var run = function (elm, func, scope) {
    var result;
    var node = typeof elm === &#39;string&#39; ? get(elm) : elm;
    if (!node) {
      return false;
    }
    if (Tools.isArray(node) &amp;&amp; (node.length || node.length === 0)) {
      result = [];
      each$5(node, function (elm, i) {
        if (elm) {
          if (typeof elm === &#39;string&#39;) {
            elm = get(elm);
          }
          result.push(func.call(scope, elm, i));
        }
      });
      return result;
    }
    var context = scope ? scope : _this;
    return func.call(context, node);
  };
  var setAttribs = function (elm, attrs) {
    $$(elm).each(function (i, node) {
      each$5(attrs, function (value, name$$1) {
        setAttrib(node, name$$1, value);
      });
    });
  };
  var setHTML = function (elm, html) {
    var $elm = $$(elm);
    if (isIE) {
      $elm.each(function (i, target) {
        if (target.canHaveHTML === false) {
          return;
        }
        while (target.firstChild) {
          target.removeChild(target.firstChild);
        }
        try {
          target.innerHTML = &#39;&lt;br&gt;&#39; + html;
          target.removeChild(target.firstChild);
        } catch (ex) {
          DomQuery(&#39;&lt;div&gt;&lt;/div&gt;&#39;).html(&#39;&lt;br&gt;&#39; + html).contents().slice(1).appendTo(target);
        }
        return html;
      });
    } else {
      $elm.html(html);
    }
  };
  var add = function (parentElm, name$$1, attrs, html, create) {
    return run(parentElm, function (parentElm) {
      var newElm = typeof name$$1 === &#39;string&#39; ? doc.createElement(name$$1) : name$$1;
      setAttribs(newElm, attrs);
      if (html) {
        if (typeof html !== &#39;string&#39; &amp;&amp; html.nodeType) {
          newElm.appendChild(html);
        } else if (typeof html === &#39;string&#39;) {
          setHTML(newElm, html);
        }
      }
      return !create ? parentElm.appendChild(newElm) : newElm;
    });
  };
  var create = function (name$$1, attrs, html) {
    return add(doc.createElement(name$$1), name$$1, attrs, html, true);
  };
  var decode = Entities.decode;
  var encode = Entities.encodeAllRaw;
  var createHTML = function (name$$1, attrs, html) {
    var outHtml = &#39;&#39;, key;
    outHtml += &#39;&lt;&#39; + name$$1;
    for (key in attrs) {
      if (attrs.hasOwnProperty(key) &amp;&amp; attrs[key] !== null &amp;&amp; typeof attrs[key] !== &#39;undefined&#39;) {
        outHtml += &#39; &#39; + key + &#39;=&quot;&#39; + encode(attrs[key]) + &#39;&quot;&#39;;
      }
    }
    if (typeof html !== &#39;undefined&#39;) {
      return outHtml + &#39;&gt;&#39; + html + &#39;&lt;/&#39; + name$$1 + &#39;&gt;&#39;;
    }
    return outHtml + &#39; /&gt;&#39;;
  };
  var createFragment = function (html) {
    var node;
    var container = doc.createElement(&#39;div&#39;);
    var frag = doc.createDocumentFragment();
    if (html) {
      container.innerHTML = html;
    }
    while (node = container.firstChild) {
      frag.appendChild(node);
    }
    return frag;
  };
  var remove = function (node, keepChildren) {
    var $node = $$(node);
    if (keepChildren) {
      $node.each(function () {
        var child;
        while (child = this.firstChild) {
          if (child.nodeType === 3 &amp;&amp; child.data.length === 0) {
            this.removeChild(child);
          } else {
            this.parentNode.insertBefore(child, this);
          }
        }
      }).remove();
    } else {
      $node.remove();
    }
    return $node.length &gt; 1 ? $node.toArray() : $node[0];
  };
  var removeAllAttribs = function (e) {
    return run(e, function (e) {
      var i;
      var attrs = e.attributes;
      for (i = attrs.length - 1; i &gt;= 0; i--) {
        e.removeAttributeNode(attrs.item(i));
      }
    });
  };
  var parseStyle = function (cssText) {
    return styles.parse(cssText);
  };
  var serializeStyle = function (stylesArg, name$$1) {
    return styles.serialize(stylesArg, name$$1);
  };
  var addStyle = function (cssText) {
    var head, styleElm;
    if (self$$1 !== DOMUtils.DOM &amp;&amp; doc === document) {
      if (addedStyles[cssText]) {
        return;
      }
      addedStyles[cssText] = true;
    }
    styleElm = doc.getElementById(&#39;mceDefaultStyles&#39;);
    if (!styleElm) {
      styleElm = doc.createElement(&#39;style&#39;);
      styleElm.id = &#39;mceDefaultStyles&#39;;
      styleElm.type = &#39;text/css&#39;;
      head = doc.getElementsByTagName(&#39;head&#39;)[0];
      if (head.firstChild) {
        head.insertBefore(styleElm, head.firstChild);
      } else {
        head.appendChild(styleElm);
      }
    }
    if (styleElm.styleSheet) {
      styleElm.styleSheet.cssText += cssText;
    } else {
      styleElm.appendChild(doc.createTextNode(cssText));
    }
  };
  var loadCSS = function (url) {
    var head;
    if (self$$1 !== DOMUtils.DOM &amp;&amp; doc === document) {
      DOMUtils.DOM.loadCSS(url);
      return;
    }
    if (!url) {
      url = &#39;&#39;;
    }
    head = doc.getElementsByTagName(&#39;head&#39;)[0];
    each$5(url.split(&#39;,&#39;), function (url) {
      var link;
      url = Tools._addCacheSuffix(url);
      if (files[url]) {
        return;
      }
      files[url] = true;
      link = create(&#39;link&#39;, {
        rel: &#39;stylesheet&#39;,
        href: url
      });
      head.appendChild(link);
    });
  };
  var toggleClass = function (elm, cls, state) {
    $$(elm).toggleClass(cls, state).each(function () {
      if (this.className === &#39;&#39;) {
        DomQuery(this).attr(&#39;class&#39;, null);
      }
    });
  };
  var addClass = function (elm, cls) {
    $$(elm).addClass(cls);
  };
  var removeClass = function (elm, cls) {
    toggleClass(elm, cls, false);
  };
  var hasClass = function (elm, cls) {
    return $$(elm).hasClass(cls);
  };
  var show = function (elm) {
    $$(elm).show();
  };
  var hide = function (elm) {
    $$(elm).hide();
  };
  var isHidden = function (elm) {
    return $$(elm).css(&#39;display&#39;) === &#39;none&#39;;
  };
  var uniqueId = function (prefix) {
    return (!prefix ? &#39;mce_&#39; : prefix) + counter++;
  };
  var getOuterHTML = function (elm) {
    var node = typeof elm === &#39;string&#39; ? get(elm) : elm;
    return NodeType.isElement(node) ? node.outerHTML : DomQuery(&#39;&lt;div&gt;&lt;/div&gt;&#39;).append(DomQuery(node).clone()).html();
  };
  var setOuterHTML = function (elm, html) {
    $$(elm).each(function () {
      try {
        if (&#39;outerHTML&#39; in this) {
          this.outerHTML = html;
          return;
        }
      } catch (ex) {
      }
      remove(DomQuery(this).html(html), true);
    });
  };
  var insertAfter = function (node, reference) {
    var referenceNode = get(reference);
    return run(node, function (node) {
      var parent$$1, nextSibling;
      parent$$1 = referenceNode.parentNode;
      nextSibling = referenceNode.nextSibling;
      if (nextSibling) {
        parent$$1.insertBefore(node, nextSibling);
      } else {
        parent$$1.appendChild(node);
      }
      return node;
    });
  };
  var replace = function (newElm, oldElm, keepChildren) {
    return run(oldElm, function (oldElm) {
      if (Tools.is(oldElm, &#39;array&#39;)) {
        newElm = newElm.cloneNode(true);
      }
      if (keepChildren) {
        each$5(grep$1(oldElm.childNodes), function (node) {
          newElm.appendChild(node);
        });
      }
      return oldElm.parentNode.replaceChild(newElm, oldElm);
    });
  };
  var rename = function (elm, name$$1) {
    var newElm;
    if (elm.nodeName !== name$$1.toUpperCase()) {
      newElm = create(name$$1);
      each$5(getAttribs(elm), function (attrNode) {
        setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
      });
      replace(newElm, elm, true);
    }
    return newElm || elm;
  };
  var findCommonAncestor = function (a, b) {
    var ps = a, pe;
    while (ps) {
      pe = b;
      while (pe &amp;&amp; ps !== pe) {
        pe = pe.parentNode;
      }
      if (ps === pe) {
        break;
      }
      ps = ps.parentNode;
    }
    if (!ps &amp;&amp; a.ownerDocument) {
      return a.ownerDocument.documentElement;
    }
    return ps;
  };
  var toHex = function (rgbVal) {
    return styles.toHex(Tools.trim(rgbVal));
  };
  var isEmpty = function (node, elements) {
    var i, attributes, type, whitespace, walker, name$$1, brCount = 0;
    node = node.firstChild;
    if (node) {
      walker = new TreeWalker(node, node.parentNode);
      elements = elements || (schema ? schema.getNonEmptyElements() : null);
      whitespace = schema ? schema.getWhiteSpaceElements() : {};
      do {
        type = node.nodeType;
        if (NodeType.isElement(node)) {
          var bogusVal = node.getAttribute(&#39;data-mce-bogus&#39;);
          if (bogusVal) {
            node = walker.next(bogusVal === &#39;all&#39;);
            continue;
          }
          name$$1 = node.nodeName.toLowerCase();
          if (elements &amp;&amp; elements[name$$1]) {
            if (name$$1 === &#39;br&#39;) {
              brCount++;
              node = walker.next();
              continue;
            }
            return false;
          }
          attributes = getAttribs(node);
          i = attributes.length;
          while (i--) {
            name$$1 = attributes[i].nodeName;
            if (name$$1 === &#39;name&#39; || name$$1 === &#39;data-mce-bookmark&#39;) {
              return false;
            }
          }
        }
        if (type === 8) {
          return false;
        }
        if (type === 3 &amp;&amp; !whiteSpaceRegExp$2.test(node.nodeValue)) {
          return false;
        }
        if (type === 3 &amp;&amp; node.parentNode &amp;&amp; whitespace[node.parentNode.nodeName] &amp;&amp; whiteSpaceRegExp$2.test(node.nodeValue)) {
          return false;
        }
        node = walker.next();
      } while (node);
    }
    return brCount &lt;= 1;
  };
  var createRng = function () {
    return doc.createRange();
  };
  var split = function (parentElm, splitElm, replacementElm) {
    var r = createRng(), bef, aft, pa;
    if (parentElm &amp;&amp; splitElm) {
      r.setStart(parentElm.parentNode, findNodeIndex(parentElm));
      r.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
      bef = r.extractContents();
      r = createRng();
      r.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
      r.setEnd(parentElm.parentNode, findNodeIndex(parentElm) + 1);
      aft = r.extractContents();
      pa = parentElm.parentNode;
      pa.insertBefore(TrimNode.trimNode(self$$1, bef), parentElm);
      if (replacementElm) {
        pa.insertBefore(replacementElm, parentElm);
      } else {
        pa.insertBefore(splitElm, parentElm);
      }
      pa.insertBefore(TrimNode.trimNode(self$$1, aft), parentElm);
      remove(parentElm);
      return replacementElm || splitElm;
    }
  };
  var bind = function (target, name$$1, func, scope) {
    if (Tools.isArray(target)) {
      var i = target.length;
      while (i--) {
        target[i] = bind(target[i], name$$1, func, scope);
      }
      return target;
    }
    if (settings.collect &amp;&amp; (target === doc || target === win)) {
      boundEvents.push([
        target,
        name$$1,
        func,
        scope
      ]);
    }
    return events.bind(target, name$$1, func, scope || self$$1);
  };
  var unbind = function (target, name$$1, func) {
    var i;
    if (Tools.isArray(target)) {
      i = target.length;
      while (i--) {
        target[i] = unbind(target[i], name$$1, func);
      }
      return target;
    }
    if (boundEvents &amp;&amp; (target === doc || target === win)) {
      i = boundEvents.length;
      while (i--) {
        var item = boundEvents[i];
        if (target === item[0] &amp;&amp; (!name$$1 || name$$1 === item[1]) &amp;&amp; (!func || func === item[2])) {
          events.unbind(item[0], item[1], item[2]);
        }
      }
    }
    return events.unbind(target, name$$1, func);
  };
  var fire = function (target, name$$1, evt) {
    return events.fire(target, name$$1, evt);
  };
  var getContentEditable = function (node) {
    if (node &amp;&amp; NodeType.isElement(node)) {
      var contentEditable = node.getAttribute(&#39;data-mce-contenteditable&#39;);
      if (contentEditable &amp;&amp; contentEditable !== &#39;inherit&#39;) {
        return contentEditable;
      }
      return node.contentEditable !== &#39;inherit&#39; ? node.contentEditable : null;
    } else {
      return null;
    }
  };
  var getContentEditableParent = function (node) {
    var root = getRoot();
    var state = null;
    for (; node &amp;&amp; node !== root; node = node.parentNode) {
      state = getContentEditable(node);
      if (state !== null) {
        break;
      }
    }
    return state;
  };
  var destroy = function () {
    if (boundEvents) {
      var i = boundEvents.length;
      while (i--) {
        var item = boundEvents[i];
        events.unbind(item[0], item[1], item[2]);
      }
    }
    if (Sizzle.setDocument) {
      Sizzle.setDocument();
    }
  };
  var isChildOf = function (node, parent$$1) {
    while (node) {
      if (parent$$1 === node) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  };
  var dumpRng = function (r) {
    return &#39;startContainer: &#39; + r.startContainer.nodeName + &#39;, startOffset: &#39; + r.startOffset + &#39;, endContainer: &#39; + r.endContainer.nodeName + &#39;, endOffset: &#39; + r.endOffset;
  };
  var self$$1 = {
    doc: doc,
    settings: settings,
    win: win,
    files: files,
    stdMode: stdMode,
    boxModel: boxModel,
    styleSheetLoader: styleSheetLoader,
    boundEvents: boundEvents,
    styles: styles,
    schema: schema,
    events: events,
    isBlock: isBlock,
    $: $,
    $$: $$,
    root: null,
    clone: clone,
    getRoot: getRoot,
    getViewPort: getViewPort,
    getRect: getRect,
    getSize: getSize,
    getParent: getParent,
    getParents: getParents,
    get: get,
    getNext: getNext,
    getPrev: getPrev,
    select: select,
    is: is,
    add: add,
    create: create,
    createHTML: createHTML,
    createFragment: createFragment,
    remove: remove,
    setStyle: setStyle,
    getStyle: getStyle,
    setStyles: setStyles,
    removeAllAttribs: removeAllAttribs,
    setAttrib: setAttrib,
    setAttribs: setAttribs,
    getAttrib: getAttrib,
    getPos: getPos,
    parseStyle: parseStyle,
    serializeStyle: serializeStyle,
    addStyle: addStyle,
    loadCSS: loadCSS,
    addClass: addClass,
    removeClass: removeClass,
    hasClass: hasClass,
    toggleClass: toggleClass,
    show: show,
    hide: hide,
    isHidden: isHidden,
    uniqueId: uniqueId,
    setHTML: setHTML,
    getOuterHTML: getOuterHTML,
    setOuterHTML: setOuterHTML,
    decode: decode,
    encode: encode,
    insertAfter: insertAfter,
    replace: replace,
    rename: rename,
    findCommonAncestor: findCommonAncestor,
    toHex: toHex,
    run: run,
    getAttribs: getAttribs,
    isEmpty: isEmpty,
    createRng: createRng,
    nodeIndex: findNodeIndex,
    split: split,
    bind: bind,
    unbind: unbind,
    fire: fire,
    getContentEditable: getContentEditable,
    getContentEditableParent: getContentEditableParent,
    destroy: destroy,
    isChildOf: isChildOf,
    dumpRng: dumpRng
  };
  attrHooks = setupAttrHooks(styles, settings, function () {
    return self$$1;
  });
  return self$$1;
}
(function (DOMUtils) {
  DOMUtils.DOM = DOMUtils(document);
  DOMUtils.nodeIndex = findNodeIndex;
}(DOMUtils || (DOMUtils = {})));
var DOMUtils$1 = DOMUtils;

var DOM = DOMUtils$1.DOM;
var each$6 = Tools.each, grep$2 = Tools.grep;
var isFunction$1 = function (f) {
  return typeof f === &#39;function&#39;;
};
var ScriptLoader = function () {
  var QUEUED = 0;
  var LOADING = 1;
  var LOADED = 2;
  var FAILED = 3;
  var states = {};
  var queue = [];
  var scriptLoadedCallbacks = {};
  var queueLoadedCallbacks = [];
  var loading = 0;
  var loadScript = function (url, success, failure) {
    var dom = DOM;
    var elm, id;
    var done = function () {
      dom.remove(id);
      if (elm) {
        elm.onreadystatechange = elm.onload = elm = null;
      }
      success();
    };
    var error = function () {
      if (isFunction$1(failure)) {
        failure();
      } else {
        if (typeof console !== &#39;undefined&#39; &amp;&amp; console.log) {
          console.log(&#39;Failed to load script: &#39; + url);
        }
      }
    };
    id = dom.uniqueId();
    elm = document.createElement(&#39;script&#39;);
    elm.id = id;
    elm.type = &#39;text/javascript&#39;;
    elm.src = Tools._addCacheSuffix(url);
    elm.onload = done;
    elm.onerror = error;
    (document.getElementsByTagName(&#39;head&#39;)[0] || document.body).appendChild(elm);
  };
  this.isDone = function (url) {
    return states[url] === LOADED;
  };
  this.markDone = function (url) {
    states[url] = LOADED;
  };
  this.add = this.load = function (url, success, scope, failure) {
    var state = states[url];
    if (state === undefined) {
      queue.push(url);
      states[url] = QUEUED;
    }
    if (success) {
      if (!scriptLoadedCallbacks[url]) {
        scriptLoadedCallbacks[url] = [];
      }
      scriptLoadedCallbacks[url].push({
        success: success,
        failure: failure,
        scope: scope || this
      });
    }
  };
  this.remove = function (url) {
    delete states[url];
    delete scriptLoadedCallbacks[url];
  };
  this.loadQueue = function (success, scope, failure) {
    this.loadScripts(queue, success, scope, failure);
  };
  this.loadScripts = function (scripts, success, scope, failure) {
    var loadScripts;
    var failures = [];
    var execCallbacks = function (name$$1, url) {
      each$6(scriptLoadedCallbacks[url], function (callback) {
        if (isFunction$1(callback[name$$1])) {
          callback[name$$1].call(callback.scope);
        }
      });
      scriptLoadedCallbacks[url] = undefined;
    };
    queueLoadedCallbacks.push({
      success: success,
      failure: failure,
      scope: scope || this
    });
    loadScripts = function () {
      var loadingScripts = grep$2(scripts);
      scripts.length = 0;
      each$6(loadingScripts, function (url) {
        if (states[url] === LOADED) {
          execCallbacks(&#39;success&#39;, url);
          return;
        }
        if (states[url] === FAILED) {
          execCallbacks(&#39;failure&#39;, url);
          return;
        }
        if (states[url] !== LOADING) {
          states[url] = LOADING;
          loading++;
          loadScript(url, function () {
            states[url] = LOADED;
            loading--;
            execCallbacks(&#39;success&#39;, url);
            loadScripts();
          }, function () {
            states[url] = FAILED;
            loading--;
            failures.push(url);
            execCallbacks(&#39;failure&#39;, url);
            loadScripts();
          });
        }
      });
      if (!loading) {
        var notifyCallbacks = queueLoadedCallbacks.slice(0);
        queueLoadedCallbacks.length = 0;
        each$6(notifyCallbacks, function (callback) {
          if (failures.length === 0) {
            if (isFunction$1(callback.success)) {
              callback.success.call(callback.scope);
            }
          } else {
            if (isFunction$1(callback.failure)) {
              callback.failure.call(callback.scope, failures);
            }
          }
        });
      }
    };
    loadScripts();
  };
};
ScriptLoader.ScriptLoader = new ScriptLoader();

var each$7 = Tools.each;
function AddOnManager() {
  var _this = this;
  var items = [];
  var urls = {};
  var lookup = {};
  var _listeners = [];
  var get = function (name) {
    if (lookup[name]) {
      return lookup[name].instance;
    }
    return undefined;
  };
  var dependencies = function (name) {
    var result;
    if (lookup[name]) {
      result = lookup[name].dependencies;
    }
    return result || [];
  };
  var requireLangPack = function (name, languages) {
    var language = AddOnManager.language;
    if (language &amp;&amp; AddOnManager.languageLoad !== false) {
      if (languages) {
        languages = &#39;,&#39; + languages + &#39;,&#39;;
        if (languages.indexOf(&#39;,&#39; + language.substr(0, 2) + &#39;,&#39;) !== -1) {
          language = language.substr(0, 2);
        } else if (languages.indexOf(&#39;,&#39; + language + &#39;,&#39;) === -1) {
          return;
        }
      }
      ScriptLoader.ScriptLoader.add(urls[name] + &#39;/langs/&#39; + language + &#39;.js&#39;);
    }
  };
  var add = function (id, addOn, dependencies) {
    items.push(addOn);
    lookup[id] = {
      instance: addOn,
      dependencies: dependencies
    };
    var result = partition(_listeners, function (listener) {
      return listener.name === id;
    });
    _listeners = result.fail;
    each$7(result.pass, function (listener) {
      listener.callback();
    });
    return addOn;
  };
  var remove = function (name) {
    delete urls[name];
    delete lookup[name];
  };
  var createUrl = function (baseUrl, dep) {
    if (typeof dep === &#39;object&#39;) {
      return dep;
    }
    return typeof baseUrl === &#39;string&#39; ? {
      prefix: &#39;&#39;,
      resource: dep,
      suffix: &#39;&#39;
    } : {
      prefix: baseUrl.prefix,
      resource: dep,
      suffix: baseUrl.suffix
    };
  };
  var addComponents = function (pluginName, scripts) {
    var pluginUrl = _this.urls[pluginName];
    each$7(scripts, function (script) {
      ScriptLoader.ScriptLoader.add(pluginUrl + &#39;/&#39; + script);
    });
  };
  var loadDependencies = function (name, addOnUrl, success, scope) {
    var deps = dependencies(name);
    each$7(deps, function (dep) {
      var newUrl = createUrl(addOnUrl, dep);
      load(newUrl.resource, newUrl, undefined, undefined);
    });
    if (success) {
      if (scope) {
        success.call(scope);
      } else {
        success.call(ScriptLoader);
      }
    }
  };
  var load = function (name, addOnUrl, success, scope, failure) {
    if (urls[name]) {
      return;
    }
    var urlString = typeof addOnUrl === &#39;string&#39; ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
    if (urlString.indexOf(&#39;/&#39;) !== 0 &amp;&amp; urlString.indexOf(&#39;://&#39;) === -1) {
      urlString = AddOnManager.baseURL + &#39;/&#39; + urlString;
    }
    urls[name] = urlString.substring(0, urlString.lastIndexOf(&#39;/&#39;));
    if (lookup[name]) {
      loadDependencies(name, addOnUrl, success, scope);
    } else {
      ScriptLoader.ScriptLoader.add(urlString, function () {
        return loadDependencies(name, addOnUrl, success, scope);
      }, scope, failure);
    }
  };
  var waitFor = function (name, callback) {
    if (lookup.hasOwnProperty(name)) {
      callback();
    } else {
      _listeners.push({
        name: name,
        callback: callback
      });
    }
  };
  return {
    items: items,
    urls: urls,
    lookup: lookup,
    _listeners: _listeners,
    get: get,
    dependencies: dependencies,
    requireLangPack: requireLangPack,
    add: add,
    remove: remove,
    createUrl: createUrl,
    addComponents: addComponents,
    load: load,
    waitFor: waitFor
  };
}
(function (AddOnManager) {
  AddOnManager.PluginManager = AddOnManager();
  AddOnManager.ThemeManager = AddOnManager();
}(AddOnManager || (AddOnManager = {})));

var before = function (marker, element) {
  var parent$$1 = parent(marker);
  parent$$1.each(function (v) {
    v.dom().insertBefore(element.dom(), marker.dom());
  });
};
var after = function (marker, element) {
  var sibling = nextSibling(marker);
  sibling.fold(function () {
    var parent$$1 = parent(marker);
    parent$$1.each(function (v) {
      append(v, element);
    });
  }, function (v) {
    before(v, element);
  });
};
var append = function (parent$$1, element) {
  parent$$1.dom().appendChild(element.dom());
};
var wrap$1 = function (element, wrapper) {
  before(element, wrapper);
  append(wrapper, element);
};

var before$1 = function (marker, elements) {
  each(elements, function (x) {
    before(marker, x);
  });
};
var append$1 = function (parent, elements) {
  each(elements, function (x) {
    append(parent, x);
  });
};

var empty = function (element) {
  element.dom().textContent = &#39;&#39;;
  each(children(element), function (rogue) {
    remove$2(rogue);
  });
};
var remove$2 = function (element) {
  var dom = element.dom();
  if (dom.parentNode !== null)
    dom.parentNode.removeChild(dom);
};
var unwrap = function (wrapper) {
  var children$$1 = children(wrapper);
  if (children$$1.length &gt; 0)
    before$1(wrapper, children$$1);
  remove$2(wrapper);
};

var first$1 = function (fn, rate) {
  var timer = null;
  var cancel = function () {
    if (timer !== null) {
      clearTimeout(timer);
      timer = null;
    }
  };
  var throttle = function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (timer === null) {
      timer = setTimeout(function () {
        fn.apply(null, args);
        timer = null;
      }, rate);
    }
  };
  return {
    cancel: cancel,
    throttle: throttle
  };
};
var last$3 = function (fn, rate) {
  var timer = null;
  var cancel = function () {
    if (timer !== null) {
      clearTimeout(timer);
      timer = null;
    }
  };
  var throttle = function () {
    var args = [];
    for (var _i = 0; _i &lt; arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (timer !== null)
      clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(null, args);
      timer = null;
    }, rate);
  };
  return {
    cancel: cancel,
    throttle: throttle
  };
};

var Cell = function (initial) {
  var value = initial;
  var get = function () {
    return value;
  };
  var set = function (v) {
    value = v;
  };
  var clone = function () {
    return Cell(get());
  };
  return {
    get: get,
    set: set,
    clone: clone
  };
};

var read = function (element, attr) {
  var value = get$1(element, attr);
  return value === undefined || value === &#39;&#39; ? [] : value.split(&#39; &#39;);
};
var add = function (element, attr, id) {
  var old = read(element, attr);
  var nu = old.concat([id]);
  set(element, attr, nu.join(&#39; &#39;));
  return true;
};
var remove$3 = function (element, attr, id) {
  var nu = filter(read(element, attr), function (v) {
    return v !== id;
  });
  if (nu.length &gt; 0)
    set(element, attr, nu.join(&#39; &#39;));
  else
    remove(element, attr);
  return false;
};

var supports = function (element) {
  return element.dom().classList !== undefined;
};
var get$3 = function (element) {
  return read(element, &#39;class&#39;);
};
var add$1 = function (element, clazz) {
  return add(element, &#39;class&#39;, clazz);
};
var remove$4 = function (element, clazz) {
  return remove$3(element, &#39;class&#39;, clazz);
};

var add$2 = function (element, clazz) {
  if (supports(element))
    element.dom().classList.add(clazz);
  else
    add$1(element, clazz);
};
var cleanClass = function (element) {
  var classList = supports(element) ? element.dom().classList : get$3(element);
  if (classList.length === 0) {
    remove(element, &#39;class&#39;);
  }
};
var remove$5 = function (element, clazz) {
  if (supports(element)) {
    var classList = element.dom().classList;
    classList.remove(clazz);
  } else
    remove$4(element, clazz);
  cleanClass(element);
};
var has$2 = function (element, clazz) {
  return supports(element) &amp;&amp; element.dom().classList.contains(clazz);
};

var descendants$1 = function (scope, selector) {
  return all(selector, scope);
};

function ClosestOrAncestor (is, ancestor, scope, a, isRoot) {
  return is(scope, a) ? Option.some(scope) : isFunction(isRoot) &amp;&amp; isRoot(scope) ? Option.none() : ancestor(scope, a, isRoot);
}

var ancestor = function (scope, predicate, isRoot) {
  var element = scope.dom();
  var stop = isFunction(isRoot) ? isRoot : constant(false);
  while (element.parentNode) {
    element = element.parentNode;
    var el = Element$$1.fromDom(element);
    if (predicate(el))
      return Option.some(el);
    else if (stop(el))
      break;
  }
  return Option.none();
};
var closest = function (scope, predicate, isRoot) {
  var is = function (scope) {
    return predicate(scope);
  };
  return ClosestOrAncestor(is, ancestor, scope, predicate, isRoot);
};

var ancestor$1 = function (scope, selector, isRoot) {
  return ancestor(scope, function (e) {
    return is$1(e, selector);
  }, isRoot);
};
var descendant$1 = function (scope, selector) {
  return one(selector, scope);
};
var closest$1 = function (scope, selector, isRoot) {
  return ClosestOrAncestor(is$1, ancestor$1, scope, selector, isRoot);
};

var annotation = constant(&#39;mce-annotation&#39;);
var dataAnnotation = constant(&#39;data-mce-annotation&#39;);
var dataAnnotationId = constant(&#39;data-mce-annotation-uid&#39;);

var identify = function (editor, annotationName) {
  var rng = editor.selection.getRng();
  var start = Element$$1.fromDom(rng.startContainer);
  var root = Element$$1.fromDom(editor.getBody());
  var selector = annotationName.fold(function () {
    return &#39;.&#39; + annotation();
  }, function (an) {
    return &#39;[&#39; + dataAnnotation() + &#39;=&quot;&#39; + an + &#39;&quot;]&#39;;
  });
  var newStart = child(start, rng.startOffset).getOr(start);
  var closest = closest$1(newStart, selector, function (n) {
    return eq(n, root);
  });
  var getAttr = function (c, property) {
    if (has$1(c, property)) {
      return Option.some(get$1(c, property));
    } else {
      return Option.none();
    }
  };
  return closest.bind(function (c) {
    return getAttr(c, &#39;&#39; + dataAnnotationId()).bind(function (uid) {
      return getAttr(c, &#39;&#39; + dataAnnotation()).map(function (name$$1) {
        var elements = findMarkers(editor, uid);
        return {
          uid: uid,
          name: name$$1,
          elements: elements
        };
      });
    });
  });
};
var isAnnotation = function (elem) {
  return isElement(elem) &amp;&amp; has$2(elem, annotation());
};
var findMarkers = function (editor, uid) {
  var body = Element$$1.fromDom(editor.getBody());
  return descendants$1(body, &#39;[&#39; + dataAnnotationId() + &#39;=&quot;&#39; + uid + &#39;&quot;]&#39;);
};
var findAll = function (editor, name$$1) {
  var body = Element$$1.fromDom(editor.getBody());
  var markers = descendants$1(body, &#39;[&#39; + dataAnnotation() + &#39;=&quot;&#39; + name$$1 + &#39;&quot;]&#39;);
  var directory = {};
  each(markers, function (m) {
    var uid = get$1(m, dataAnnotationId());
    var nodesAlready = directory.hasOwnProperty(uid) ? directory[uid] : [];
    directory[uid] = nodesAlready.concat([m]);
  });
  return directory;
};

var setup = function (editor, registry) {
  var changeCallbacks = Cell({});
  var initData = function () {
    return {
      listeners: [],
      previous: Cell(Option.none())
    };
  };
  var withCallbacks = function (name, f) {
    updateCallbacks(name, function (data) {
      f(data);
      return data;
    });
  };
  var updateCallbacks = function (name, f) {
    var callbackMap = changeCallbacks.get();
    var data = callbackMap.hasOwnProperty(name) ? callbackMap[name] : initData();
    var outputData = f(data);
    callbackMap[name] = outputData;
    changeCallbacks.set(callbackMap);
  };
  var fireCallbacks = function (name, uid, elements) {
    withCallbacks(name, function (data) {
      each(data.listeners, function (f) {
        return f(true, name, {
          uid: uid,
          nodes: map(elements, function (elem) {
            return elem.dom();
          })
        });
      });
    });
  };
  var fireNoAnnotation = function (name) {
    withCallbacks(name, function (data) {
      each(data.listeners, function (f) {
        return f(false, name);
      });
    });
  };
  var onNodeChange = last$3(function () {
    var callbackMap = changeCallbacks.get();
    var annotations = sort(keys(callbackMap));
    each(annotations, function (name) {
      updateCallbacks(name, function (data) {
        var prev = data.previous.get();
        identify(editor, Option.some(name)).fold(function () {
          if (prev.isSome()) {
            fireNoAnnotation(name);
            data.previous.set(Option.none());
          }
        }, function (_a) {
          var uid = _a.uid, name = _a.name, elements = _a.elements;
          if (!prev.is(uid)) {
            fireCallbacks(name, uid, elements);
            data.previous.set(Option.some(uid));
          }
        });
        return {
          previous: data.previous,
          listeners: data.listeners
        };
      });
    });
  }, 30);
  editor.on(&#39;remove&#39;, function () {
    onNodeChange.cancel();
  });
  editor.on(&#39;nodeChange&#39;, function () {
    onNodeChange.throttle();
  });
  var addListener = function (name, f) {
    updateCallbacks(name, function (data) {
      return {
        previous: data.previous,
        listeners: data.listeners.concat([f])
      };
    });
  };
  return { addListener: addListener };
};

var setup$1 = function (editor, registry) {
  var identifyParserNode = function (span) {
    var optAnnotation = Option.from(span.attributes.map[dataAnnotation()]);
    return optAnnotation.bind(registry.lookup);
  };
  editor.on(&#39;init&#39;, function () {
    editor.serializer.addNodeFilter(&#39;span&#39;, function (spans) {
      each(spans, function (span) {
        identifyParserNode(span).each(function (settings) {
          if (settings.persistent === false) {
            span.unwrap();
          }
        });
      });
    });
  });
};

var create$1 = function () {
  var annotations = {};
  var register = function (name, settings) {
    annotations[name] = {
      name: name,
      settings: settings
    };
  };
  var lookup = function (name) {
    return annotations.hasOwnProperty(name) ? Option.from(annotations[name]).map(function (a) {
      return a.settings;
    }) : Option.none();
  };
  return {
    register: register,
    lookup: lookup
  };
};

function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) &amp;&amp; e.indexOf(p) &lt; 0)
      t[p] = s[p];
  if (s != null &amp;&amp; typeof Object.getOwnPropertySymbols === &#39;function&#39;)
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i &lt; p.length; i++)
      if (e.indexOf(p[i]) &lt; 0)
        t[p[i]] = s[p[i]];
  return t;
}

var unique = 0;
var generate = function (prefix) {
  var date = new Date();
  var time = date.getTime();
  var random = Math.floor(Math.random() * 1000000000);
  unique++;
  return prefix + &#39;_&#39; + random + unique + String(time);
};

var add$3 = function (element, classes) {
  each(classes, function (x) {
    add$2(element, x);
  });
};

var clone$1 = function (original, deep) {
  return Element$$1.fromDom(original.dom().cloneNode(deep));
};
var shallow = function (original) {
  return clone$1(original, false);
};
var deep = function (original) {
  return clone$1(original, true);
};

var fromHtml$1 = function (html, scope) {
  var doc = scope || document;
  var div = doc.createElement(&#39;div&#39;);
  div.innerHTML = html;
  return children(Element$$1.fromDom(div));
};

var get$5 = function (element) {
  return element.dom().innerHTML;
};
var set$2 = function (element, content) {
  var owner$$1 = owner(element);
  var docDom = owner$$1.dom();
  var fragment = Element$$1.fromDom(docDom.createDocumentFragment());
  var contentElements = fromHtml$1(content, docDom);
  append$1(fragment, contentElements);
  empty(element);
  append(element, fragment);
};

var ZWSP = &#39;\uFEFF&#39;;
var isZwsp = function (chr) {
  return chr === ZWSP;
};
var trim$3 = function (text) {
  return text.replace(new RegExp(ZWSP, &#39;g&#39;), &#39;&#39;);
};
var Zwsp = {
  isZwsp: isZwsp,
  ZWSP: ZWSP,
  trim: trim$3
};

var isElement$2 = NodeType.isElement;
var isText$2 = NodeType.isText;
var isCaretContainerBlock = function (node) {
  if (isText$2(node)) {
    node = node.parentNode;
  }
  return isElement$2(node) &amp;&amp; node.hasAttribute(&#39;data-mce-caret&#39;);
};
var isCaretContainerInline = function (node) {
  return isText$2(node) &amp;&amp; Zwsp.isZwsp(node.data);
};
var isCaretContainer = function (node) {
  return isCaretContainerBlock(node) || isCaretContainerInline(node);
};
var hasContent = function (node) {
  return node.firstChild !== node.lastChild || !NodeType.isBr(node.firstChild);
};
var insertInline = function (node, before) {
  var doc, sibling, textNode, parentNode;
  doc = node.ownerDocument;
  textNode = doc.createTextNode(Zwsp.ZWSP);
  parentNode = node.parentNode;
  if (!before) {
    sibling = node.nextSibling;
    if (isText$2(sibling)) {
      if (isCaretContainer(sibling)) {
        return sibling;
      }
      if (startsWithCaretContainer(sibling)) {
        sibling.splitText(1);
        return sibling;
      }
    }
    if (node.nextSibling) {
      parentNode.insertBefore(textNode, node.nextSibling);
    } else {
      parentNode.appendChild(textNode);
    }
  } else {
    sibling = node.previousSibling;
    if (isText$2(sibling)) {
      if (isCaretContainer(sibling)) {
        return sibling;
      }
      if (endsWithCaretContainer(sibling)) {
        return sibling.splitText(sibling.data.length - 1);
      }
    }
    parentNode.insertBefore(textNode, node);
  }
  return textNode;
};
var isBeforeInline = function (pos) {
  var container = pos.container();
  return pos &amp;&amp; NodeType.isText(container) &amp;&amp; container.data.charAt(pos.offset()) === Zwsp.ZWSP;
};
var isAfterInline = function (pos) {
  var container = pos.container();
  return pos &amp;&amp; NodeType.isText(container) &amp;&amp; container.data.charAt(pos.offset() - 1) === Zwsp.ZWSP;
};
var createBogusBr = function () {
  var br = document.createElement(&#39;br&#39;);
  br.setAttribute(&#39;data-mce-bogus&#39;, &#39;1&#39;);
  return br;
};
var insertBlock = function (blockName, node, before) {
  var doc, blockNode, parentNode;
  doc = node.ownerDocument;
  blockNode = doc.createElement(blockName);
  blockNode.setAttribute(&#39;data-mce-caret&#39;, before ? &#39;before&#39; : &#39;after&#39;);
  blockNode.setAttribute(&#39;data-mce-bogus&#39;, &#39;all&#39;);
  blockNode.appendChild(createBogusBr());
  parentNode = node.parentNode;
  if (!before) {
    if (node.nextSibling) {
      parentNode.insertBefore(blockNode, node.nextSibling);
    } else {
      parentNode.appendChild(blockNode);
    }
  } else {
    parentNode.insertBefore(blockNode, node);
  }
  return blockNode;
};
var startsWithCaretContainer = function (node) {
  return isText$2(node) &amp;&amp; node.data[0] === Zwsp.ZWSP;
};
var endsWithCaretContainer = function (node) {
  return isText$2(node) &amp;&amp; node.data[node.data.length - 1] === Zwsp.ZWSP;
};
var trimBogusBr = function (elm) {
  var brs = elm.getElementsByTagName(&#39;br&#39;);
  var lastBr = brs[brs.length - 1];
  if (NodeType.isBogus(lastBr)) {
    lastBr.parentNode.removeChild(lastBr);
  }
};
var showCaretContainerBlock = function (caretContainer) {
  if (caretContainer &amp;&amp; caretContainer.hasAttribute(&#39;data-mce-caret&#39;)) {
    trimBogusBr(caretContainer);
    caretContainer.removeAttribute(&#39;data-mce-caret&#39;);
    caretContainer.removeAttribute(&#39;data-mce-bogus&#39;);
    caretContainer.removeAttribute(&#39;style&#39;);
    caretContainer.removeAttribute(&#39;_moz_abspos&#39;);
    return caretContainer;
  }
  return null;
};
var isRangeInCaretContainerBlock = function (range) {
  return isCaretContainerBlock(range.startContainer);
};

var isContentEditableTrue$1 = NodeType.isContentEditableTrue;
var isContentEditableFalse$1 = NodeType.isContentEditableFalse;
var isBr$2 = NodeType.isBr;
var isText$3 = NodeType.isText;
var isInvalidTextElement = NodeType.matchNodeNames(&#39;script style textarea&#39;);
var isAtomicInline = NodeType.matchNodeNames(&#39;img input textarea hr iframe video audio object&#39;);
var isTable$1 = NodeType.matchNodeNames(&#39;table&#39;);
var isCaretContainer$1 = isCaretContainer;
var isCaretCandidate = function (node) {
  if (isCaretContainer$1(node)) {
    return false;
  }
  if (isText$3(node)) {
    if (isInvalidTextElement(node.parentNode)) {
      return false;
    }
    return true;
  }
  return isAtomicInline(node) || isBr$2(node) || isTable$1(node) || isNonUiContentEditableFalse(node);
};
var isUnselectable = function (node) {
  return NodeType.isElement(node) &amp;&amp; node.getAttribute(&#39;unselectable&#39;) === &#39;true&#39;;
};
var isNonUiContentEditableFalse = function (node) {
  return isUnselectable(node) === false &amp;&amp; isContentEditableFalse$1(node);
};
var isInEditable = function (node, root) {
  for (node = node.parentNode; node &amp;&amp; node !== root; node = node.parentNode) {
    if (isNonUiContentEditableFalse(node)) {
      return false;
    }
    if (isContentEditableTrue$1(node)) {
      return true;
    }
  }
  return true;
};
var isAtomicContentEditableFalse = function (node) {
  if (!isNonUiContentEditableFalse(node)) {
    return false;
  }
  return foldl(from$1(node.getElementsByTagName(&#39;*&#39;)), function (result, elm) {
    return result || isContentEditableTrue$1(elm);
  }, false) !== true;
};
var isAtomic = function (node) {
  return isAtomicInline(node) || isAtomicContentEditableFalse(node);
};
var isEditableCaretCandidate = function (node, root) {
  return isCaretCandidate(node) &amp;&amp; isInEditable(node, root);
};

var round = Math.round;
var clone$2 = function (rect) {
  if (!rect) {
    return {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  return {
    left: round(rect.left),
    top: round(rect.top),
    bottom: round(rect.bottom),
    right: round(rect.right),
    width: round(rect.width),
    height: round(rect.height)
  };
};
var collapse = function (rect, toStart) {
  rect = clone$2(rect);
  if (toStart) {
    rect.right = rect.left;
  } else {
    rect.left = rect.left + rect.width;
    rect.right = rect.left;
  }
  rect.width = 0;
  return rect;
};
var isEqual = function (rect1, rect2) {
  return rect1.left === rect2.left &amp;&amp; rect1.top === rect2.top &amp;&amp; rect1.bottom === rect2.bottom &amp;&amp; rect1.right === rect2.right;
};
var isValidOverflow = function (overflowY, rect1, rect2) {
  return overflowY &gt;= 0 &amp;&amp; overflowY &lt;= Math.min(rect1.height, rect2.height) / 2;
};
var isAbove = function (rect1, rect2) {
  if (rect1.bottom - rect1.height / 2 &lt; rect2.top) {
    return true;
  }
  if (rect1.top &gt; rect2.bottom) {
    return false;
  }
  return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
};
var isBelow = function (rect1, rect2) {
  if (rect1.top &gt; rect2.bottom) {
    return true;
  }
  if (rect1.bottom &lt; rect2.top) {
    return false;
  }
  return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
};
var containsXY = function (rect, clientX, clientY) {
  return clientX &gt;= rect.left &amp;&amp; clientX &lt;= rect.right &amp;&amp; clientY &gt;= rect.top &amp;&amp; clientY &lt;= rect.bottom;
};
var overflowX = function (outer, inner) {
  if (inner.left &gt; outer.left &amp;&amp; inner.right &lt; outer.right) {
    return 0;
  } else {
    return inner.left &lt; outer.left ? inner.left - outer.left : inner.right - outer.right;
  }
};
var overflowY = function (outer, inner) {
  if (inner.top &gt; outer.top &amp;&amp; inner.bottom &lt; outer.bottom) {
    return 0;
  } else {
    return inner.top &lt; outer.top ? inner.top - outer.top : inner.bottom - outer.bottom;
  }
};
var getOverflow = function (outer, inner) {
  return {
    x: overflowX(outer, inner),
    y: overflowY(outer, inner)
  };
};

var getSelectedNode = function (range) {
  var startContainer = range.startContainer, startOffset = range.startOffset;
  if (startContainer.hasChildNodes() &amp;&amp; range.endOffset === startOffset + 1) {
    return startContainer.childNodes[startOffset];
  }
  return null;
};
var getNode = function (container, offset) {
  if (container.nodeType === 1 &amp;&amp; container.hasChildNodes()) {
    if (offset &gt;= container.childNodes.length) {
      offset = container.childNodes.length - 1;
    }
    container = container.childNodes[offset];
  }
  return container;
};

var extendingChars = new RegExp(&#39;[\u0300-\u036f\u0483-\u0487\u0488-\u0489\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u0610-\u061a&#39; + &#39;\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7-\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0&#39; + &#39;\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08E3-\u0902\u093a\u093c&#39; + &#39;\u0941-\u0948\u094d\u0951-\u0957\u0962-\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2-\u09e3&#39; + &#39;\u0a01-\u0a02\u0a3c\u0a41-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a70-\u0a71\u0a75\u0a81-\u0a82\u0abc&#39; + &#39;\u0ac1-\u0ac5\u0ac7-\u0ac8\u0acd\u0ae2-\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57&#39; + &#39;\u0b62-\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c00\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56&#39; + &#39;\u0c62-\u0c63\u0c81\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc-\u0ccd\u0cd5-\u0cd6\u0ce2-\u0ce3\u0d01\u0d3e\u0d41-\u0d44&#39; + &#39;\u0d4d\u0d57\u0d62-\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9&#39; + &#39;\u0ebb-\u0ebc\u0ec8-\u0ecd\u0f18-\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86-\u0f87\u0f8d-\u0f97&#39; + &#39;\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039-\u103a\u103d-\u103e\u1058-\u1059\u105e-\u1060\u1071-\u1074&#39; + &#39;\u1082\u1085-\u1086\u108d\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17b4-\u17b5&#39; + &#39;\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193b\u1a17-\u1a18&#39; + &#39;\u1a1b\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1ab0-\u1abd\u1ABE\u1b00-\u1b03\u1b34&#39; + &#39;\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80-\u1b81\u1ba2-\u1ba5\u1ba8-\u1ba9\u1bab-\u1bad\u1be6\u1be8-\u1be9&#39; + &#39;\u1bed\u1bef-\u1bf1\u1c2c-\u1c33\u1c36-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1cf4\u1cf8-\u1cf9&#39; + &#39;\u1dc0-\u1df5\u1dfc-\u1dff\u200c-\u200d\u20d0-\u20dc\u20DD-\u20E0\u20e1\u20E2-\u20E4\u20e5-\u20f0\u2cef-\u2cf1&#39; + &#39;\u2d7f\u2de0-\u2dff\u302a-\u302d\u302e-\u302f\u3099-\u309a\ua66f\uA670-\uA672\ua674-\ua67d\uA69E-\ua69f\ua6f0-\ua6f1&#39; + &#39;\ua802\ua806\ua80b\ua825-\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc&#39; + &#39;\ua9e5\uaa29-\uaa2e\uaa31-\uaa32\uaa35-\uaa36\uaa43\uaa4c\uaa7c\uaab0\uaab2-\uaab4\uaab7-\uaab8\uaabe-\uaabf\uaac1&#39; + &#39;\uaaec-\uaaed\uaaf6\uabe5\uabe8\uabed\ufb1e\ufe00-\ufe0f\ufe20-\uFE2F\uff9e-\uff9f]&#39;);
var isExtendingChar = function (ch) {
  return typeof ch === &#39;string&#39; &amp;&amp; ch.charCodeAt(0) &gt;= 768 &amp;&amp; extendingChars.test(ch);
};

var liftN = function (arr, f) {
  var r = [];
  for (var i = 0; i &lt; arr.length; i++) {
    var x = arr[i];
    if (x.isSome()) {
      r.push(x.getOrDie());
    } else {
      return Option.none();
    }
  }
  return Option.some(f.apply(null, r));
};

var slice$3 = [].slice;
var or = function () {
  var x = [];
  for (var _i = 0; _i &lt; arguments.length; _i++) {
    x[_i] = arguments[_i];
  }
  var args = slice$3.call(arguments);
  return function (x) {
    for (var i = 0; i &lt; args.length; i++) {
      if (args[i](x)) {
        return true;
      }
    }
    return false;
  };
};
var and = function () {
  var x = [];
  for (var _i = 0; _i &lt; arguments.length; _i++) {
    x[_i] = arguments[_i];
  }
  var args = slice$3.call(arguments);
  return function (x) {
    for (var i = 0; i &lt; args.length; i++) {
      if (!args[i](x)) {
        return false;
      }
    }
    return true;
  };
};
var Predicate = {
  and: and,
  or: or
};

var isElement$3 = NodeType.isElement;
var isCaretCandidate$1 = isCaretCandidate;
var isBlock$1 = NodeType.matchStyleValues(&#39;display&#39;, &#39;block table&#39;);
var isFloated = NodeType.matchStyleValues(&#39;float&#39;, &#39;left right&#39;);
var isValidElementCaretCandidate = Predicate.and(isElement$3, isCaretCandidate$1, not(isFloated));
var isNotPre = not(NodeType.matchStyleValues(&#39;white-space&#39;, &#39;pre pre-line pre-wrap&#39;));
var isText$4 = NodeType.isText;
var isBr$3 = NodeType.isBr;
var nodeIndex = DOMUtils$1.nodeIndex;
var resolveIndex = getNode;
var createRange = function (doc) {
  return &#39;createRange&#39; in doc ? doc.createRange() : DOMUtils$1.DOM.createRng();
};
var isWhiteSpace = function (chr) {
  return chr &amp;&amp; /[\r\n\t ]/.test(chr);
};
var isRange = function (rng) {
  return !!rng.setStart &amp;&amp; !!rng.setEnd;
};
var isHiddenWhiteSpaceRange = function (range$$1) {
  var container = range$$1.startContainer;
  var offset = range$$1.startOffset;
  var text;
  if (isWhiteSpace(range$$1.toString()) &amp;&amp; isNotPre(container.parentNode) &amp;&amp; NodeType.isText(container)) {
    text = container.data;
    if (isWhiteSpace(text[offset - 1]) || isWhiteSpace(text[offset + 1])) {
      return true;
    }
  }
  return false;
};
var getBrClientRect = function (brNode) {
  var doc = brNode.ownerDocument;
  var rng = createRange(doc);
  var nbsp = doc.createTextNode(&#39;\xA0&#39;);
  var parentNode = brNode.parentNode;
  var clientRect;
  parentNode.insertBefore(nbsp, brNode);
  rng.setStart(nbsp, 0);
  rng.setEnd(nbsp, 1);
  clientRect = clone$2(rng.getBoundingClientRect());
  parentNode.removeChild(nbsp);
  return clientRect;
};
var getBoundingClientRectWebKitText = function (rng) {
  var sc = rng.startContainer;
  var ec = rng.endContainer;
  var so = rng.startOffset;
  var eo = rng.endOffset;
  if (sc === ec &amp;&amp; NodeType.isText(ec) &amp;&amp; so === 0 &amp;&amp; eo === 1) {
    var newRng = rng.cloneRange();
    newRng.setEndAfter(ec);
    return getBoundingClientRect(newRng);
  } else {
    return null;
  }
};
var isZeroRect = function (r) {
  return r.left === 0 &amp;&amp; r.right === 0 &amp;&amp; r.top === 0 &amp;&amp; r.bottom === 0;
};
var getBoundingClientRect = function (item) {
  var clientRect, clientRects;
  clientRects = item.getClientRects();
  if (clientRects.length &gt; 0) {
    clientRect = clone$2(clientRects[0]);
  } else {
    clientRect = clone$2(item.getBoundingClientRect());
  }
  if (!isRange(item) &amp;&amp; isBr$3(item) &amp;&amp; isZeroRect(clientRect)) {
    return getBrClientRect(item);
  }
  if (isZeroRect(clientRect) &amp;&amp; isRange(item)) {
    return getBoundingClientRectWebKitText(item);
  }
  return clientRect;
};
var collapseAndInflateWidth = function (clientRect, toStart) {
  var newClientRect = collapse(clientRect, toStart);
  newClientRect.width = 1;
  newClientRect.right = newClientRect.left + 1;
  return newClientRect;
};
var getCaretPositionClientRects = function (caretPosition) {
  var clientRects = [];
  var beforeNode, node;
  var addUniqueAndValidRect = function (clientRect) {
    if (clientRect.height === 0) {
      return;
    }
    if (clientRects.length &gt; 0) {
      if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
        return;
      }
    }
    clientRects.push(clientRect);
  };
  var addCharacterOffset = function (container, offset) {
    var range$$1 = createRange(container.ownerDocument);
    if (offset &lt; container.data.length) {
      if (isExtendingChar(container.data[offset])) {
        return clientRects;
      }
      if (isExtendingChar(container.data[offset - 1])) {
        range$$1.setStart(container, offset);
        range$$1.setEnd(container, offset + 1);
        if (!isHiddenWhiteSpaceRange(range$$1)) {
          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range$$1), false));
          return clientRects;
        }
      }
    }
    if (offset &gt; 0) {
      range$$1.setStart(container, offset - 1);
      range$$1.setEnd(container, offset);
      if (!isHiddenWhiteSpaceRange(range$$1)) {
        addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range$$1), false));
      }
    }
    if (offset &lt; container.data.length) {
      range$$1.setStart(container, offset);
      range$$1.setEnd(container, offset + 1);
      if (!isHiddenWhiteSpaceRange(range$$1)) {
        addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(range$$1), true));
      }
    }
  };
  if (isText$4(caretPosition.container())) {
    addCharacterOffset(caretPosition.container(), caretPosition.offset());
    return clientRects;
  }
  if (isElement$3(caretPosition.container())) {
    if (caretPosition.isAtEnd()) {
      node = resolveIndex(caretPosition.container(), caretPosition.offset());
      if (isText$4(node)) {
        addCharacterOffset(node, node.data.length);
      }
      if (isValidElementCaretCandidate(node) &amp;&amp; !isBr$3(node)) {
        addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
      }
    } else {
      node = resolveIndex(caretPosition.container(), caretPosition.offset());
      if (isText$4(node)) {
        addCharacterOffset(node, 0);
      }
      if (isValidElementCaretCandidate(node) &amp;&amp; caretPosition.isAtEnd()) {
        addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), false));
        return clientRects;
      }
      beforeNode = resolveIndex(caretPosition.container(), caretPosition.offset() - 1);
      if (isValidElementCaretCandidate(beforeNode) &amp;&amp; !isBr$3(beforeNode)) {
        if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {
          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(beforeNode), false));
        }
      }
      if (isValidElementCaretCandidate(node)) {
        addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect(node), true));
      }
    }
  }
  return clientRects;
};
function CaretPosition(container, offset, clientRects) {
  var isAtStart = function () {
    if (isText$4(container)) {
      return offset === 0;
    }
    return offset === 0;
  };
  var isAtEnd = function () {
    if (isText$4(container)) {
      return offset &gt;= container.data.length;
    }
    return offset &gt;= container.childNodes.length;
  };
  var toRange = function () {
    var range$$1;
    range$$1 = createRange(container.ownerDocument);
    range$$1.setStart(container, offset);
    range$$1.setEnd(container, offset);
    return range$$1;
  };
  var getClientRects = function () {
    if (!clientRects) {
      clientRects = getCaretPositionClientRects(CaretPosition(container, offset));
    }
    return clientRects;
  };
  var isVisible = function () {
    return getClientRects().length &gt; 0;
  };
  var isEqual$$1 = function (caretPosition) {
    return caretPosition &amp;&amp; container === caretPosition.container() &amp;&amp; offset === caretPosition.offset();
  };
  var getNode$$1 = function (before) {
    return resolveIndex(container, before ? offset - 1 : offset);
  };
  return {
    container: constant(container),
    offset: constant(offset),
    toRange: toRange,
    getClientRects: getClientRects,
    isVisible: isVisible,
    isAtStart: isAtStart,
    isAtEnd: isAtEnd,
    isEqual: isEqual$$1,
    getNode: getNode$$1
  };
}
(function (CaretPosition) {
  CaretPosition.fromRangeStart = function (range$$1) {
    return CaretPosition(range$$1.startContainer, range$$1.startOffset);
  };
  CaretPosition.fromRangeEnd = function (range$$1) {
    return CaretPosition(range$$1.endContainer, range$$1.endOffset);
  };
  CaretPosition.after = function (node) {
    return CaretPosition(node.parentNode, nodeIndex(node) + 1);
  };
  CaretPosition.before = function (node) {
    return CaretPosition(node.parentNode, nodeIndex(node));
  };
  CaretPosition.isAbove = function (pos1, pos2) {
    return liftN([
      head(pos2.getClientRects()),
      last(pos1.getClientRects())
    ], isAbove).getOr(false);
  };
  CaretPosition.isBelow = function (pos1, pos2) {
    return liftN([
      last(pos2.getClientRects()),
      head(pos1.getClientRects())
    ], isBelow).getOr(false);
  };
  CaretPosition.isAtStart = function (pos) {
    return pos ? pos.isAtStart() : false;
  };
  CaretPosition.isAtEnd = function (pos) {
    return pos ? pos.isAtEnd() : false;
  };
  CaretPosition.isTextPosition = function (pos) {
    return pos ? NodeType.isText(pos.container()) : false;
  };
  CaretPosition.isElementPosition = function (pos) {
    return CaretPosition.isTextPosition(pos) === false;
  };
}(CaretPosition || (CaretPosition = {})));
var CaretPosition$1 = CaretPosition;

var isText$5 = NodeType.isText;
var isBogus$1 = NodeType.isBogus;
var nodeIndex$1 = DOMUtils$1.nodeIndex;
var normalizedParent = function (node) {
  var parentNode = node.parentNode;
  if (isBogus$1(parentNode)) {
    return normalizedParent(parentNode);
  }
  return parentNode;
};
var getChildNodes = function (node) {
  if (!node) {
    return [];
  }
  return ArrUtils.reduce(node.childNodes, function (result, node) {
    if (isBogus$1(node) &amp;&amp; node.nodeName !== &#39;BR&#39;) {
      result = result.concat(getChildNodes(node));
    } else {
      result.push(node);
    }
    return result;
  }, []);
};
var normalizedTextOffset = function (node, offset) {
  while (node = node.previousSibling) {
    if (!isText$5(node)) {
      break;
    }
    offset += node.data.length;
  }
  return offset;
};
var equal$1 = function (a) {
  return function (b) {
    return a === b;
  };
};
var normalizedNodeIndex = function (node) {
  var nodes, index, numTextFragments;
  nodes = getChildNodes(normalizedParent(node));
  index = ArrUtils.findIndex(nodes, equal$1(node), node);
  nodes = nodes.slice(0, index + 1);
  numTextFragments = ArrUtils.reduce(nodes, function (result, node, i) {
    if (isText$5(node) &amp;&amp; isText$5(nodes[i - 1])) {
      result++;
    }
    return result;
  }, 0);
  nodes = ArrUtils.filter(nodes, NodeType.matchNodeNames(node.nodeName));
  index = ArrUtils.findIndex(nodes, equal$1(node), node);
  return index - numTextFragments;
};
var createPathItem = function (node) {
  var name;
  if (isText$5(node)) {
    name = &#39;text()&#39;;
  } else {
    name = node.nodeName.toLowerCase();
  }
  return name + &#39;[&#39; + normalizedNodeIndex(node) + &#39;]&#39;;
};
var parentsUntil = function (root, node, predicate) {
  var parents = [];
  for (node = node.parentNode; node !== root; node = node.parentNode) {
    if (predicate &amp;&amp; predicate(node)) {
      break;
    }
    parents.push(node);
  }
  return parents;
};
var create$2 = function (root, caretPosition) {
  var container, offset, path = [], outputOffset, childNodes, parents;
  container = caretPosition.container();
  offset = caretPosition.offset();
  if (isText$5(container)) {
    outputOffset = normalizedTextOffset(container, offset);
  } else {
    childNodes = container.childNodes;
    if (offset &gt;= childNodes.length) {
      outputOffset = &#39;after&#39;;
      offset = childNodes.length - 1;
    } else {
      outputOffset = &#39;before&#39;;
    }
    container = childNodes[offset];
  }
  path.push(createPathItem(container));
  parents = parentsUntil(root, container);
  parents = ArrUtils.filter(parents, not(NodeType.isBogus));
  path = path.concat(ArrUtils.map(parents, function (node) {
    return createPathItem(node);
  }));
  return path.reverse().join(&#39;/&#39;) + &#39;,&#39; + outputOffset;
};
var resolvePathItem = function (node, name, index) {
  var nodes = getChildNodes(node);
  nodes = ArrUtils.filter(nodes, function (node, index) {
    return !isText$5(node) || !isText$5(nodes[index - 1]);
  });
  nodes = ArrUtils.filter(nodes, NodeType.matchNodeNames(name));
  return nodes[index];
};
var findTextPosition = function (container, offset) {
  var node = container, targetOffset = 0, dataLen;
  while (isText$5(node)) {
    dataLen = node.data.length;
    if (offset &gt;= targetOffset &amp;&amp; offset &lt;= targetOffset + dataLen) {
      container = node;
      offset = offset - targetOffset;
      break;
    }
    if (!isText$5(node.nextSibling)) {
      container = node;
      offset = dataLen;
      break;
    }
    targetOffset += dataLen;
    node = node.nextSibling;
  }
  if (isText$5(container) &amp;&amp; offset &gt; container.data.length) {
    offset = container.data.length;
  }
  return CaretPosition$1(container, offset);
};
var resolve$2 = function (root, path) {
  var parts, container, offset;
  if (!path) {
    return null;
  }
  parts = path.split(&#39;,&#39;);
  path = parts[0].split(&#39;/&#39;);
  offset = parts.length &gt; 1 ? parts[1] : &#39;before&#39;;
  container = ArrUtils.reduce(path, function (result, value) {
    value = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value);
    if (!value) {
      return null;
    }
    if (value[1] === &#39;text()&#39;) {
      value[1] = &#39;#text&#39;;
    }
    return resolvePathItem(result, value[1], parseInt(value[2], 10));
  }, root);
  if (!container) {
    return null;
  }
  if (!isText$5(container)) {
    if (offset === &#39;after&#39;) {
      offset = nodeIndex$1(container) + 1;
    } else {
      offset = nodeIndex$1(container);
    }
    return CaretPosition$1(container.parentNode, offset);
  }
  return findTextPosition(container, parseInt(offset, 10));
};

var isContentEditableFalse$2 = NodeType.isContentEditableFalse;
var getNormalizedTextOffset = function (trim, container, offset) {
  var node, trimmedOffset;
  trimmedOffset = trim(container.data.slice(0, offset)).length;
  for (node = container.previousSibling; node &amp;&amp; NodeType.isText(node); node = node.previousSibling) {
    trimmedOffset += trim(node.data).length;
  }
  return trimmedOffset;
};
var getPoint = function (dom, trim, normalized, rng, start) {
  var container = rng[start ? &#39;startContainer&#39; : &#39;endContainer&#39;];
  var offset = rng[start ? &#39;startOffset&#39; : &#39;endOffset&#39;];
  var point = [];
  var childNodes, after = 0;
  var root = dom.getRoot();
  if (NodeType.isText(container)) {
    point.push(normalized ? getNormalizedTextOffset(trim, container, offset) : offset);
  } else {
    childNodes = container.childNodes;
    if (offset &gt;= childNodes.length &amp;&amp; childNodes.length) {
      after = 1;
      offset = Math.max(0, childNodes.length - 1);
    }
    point.push(dom.nodeIndex(childNodes[offset], normalized) + after);
  }
  for (; container &amp;&amp; container !== root; container = container.parentNode) {
    point.push(dom.nodeIndex(container, normalized));
  }
  return point;
};
var getLocation = function (trim, selection, normalized, rng) {
  var dom = selection.dom, bookmark = {};
  bookmark.start = getPoint(dom, trim, normalized, rng, true);
  if (!selection.isCollapsed()) {
    bookmark.end = getPoint(dom, trim, normalized, rng, false);
  }
  return bookmark;
};
var trimEmptyTextNode = function (node) {
  if (NodeType.isText(node) &amp;&amp; node.data.length === 0) {
    node.parentNode.removeChild(node);
  }
};
var findIndex$3 = function (dom, name, element) {
  var count = 0;
  Tools.each(dom.select(name), function (node) {
    if (node.getAttribute(&#39;data-mce-bogus&#39;) === &#39;all&#39;) {
      return;
    }
    if (node === element) {
      return false;
    }
    count++;
  });
  return count;
};
var moveEndPoint = function (rng, start) {
  var container, offset, childNodes;
  var prefix = start ? &#39;start&#39; : &#39;end&#39;;
  container = rng[prefix + &#39;Container&#39;];
  offset = rng[prefix + &#39;Offset&#39;];
  if (NodeType.isElement(container) &amp;&amp; container.nodeName === &#39;TR&#39;) {
    childNodes = container.childNodes;
    container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];
    if (container) {
      offset = start ? 0 : container.childNodes.length;
      rng[&#39;set&#39; + (start ? &#39;Start&#39; : &#39;End&#39;)](container, offset);
    }
  }
};
var normalizeTableCellSelection = function (rng) {
  moveEndPoint(rng, true);
  moveEndPoint(rng, false);
  return rng;
};
var findSibling = function (node, offset) {
  var sibling;
  if (NodeType.isElement(node)) {
    node = getNode(node, offset);
    if (isContentEditableFalse$2(node)) {
      return node;
    }
  }
  if (isCaretContainer(node)) {
    if (NodeType.isText(node) &amp;&amp; isCaretContainerBlock(node)) {
      node = node.parentNode;
    }
    sibling = node.previousSibling;
    if (isContentEditableFalse$2(sibling)) {
      return sibling;
    }
    sibling = node.nextSibling;
    if (isContentEditableFalse$2(sibling)) {
      return sibling;
    }
  }
};
var findAdjacentContentEditableFalseElm = function (rng) {
  return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
};
var getOffsetBookmark = function (trim, normalized, selection) {
  var element = selection.getNode();
  var name = element ? element.nodeName : null;
  var rng = selection.getRng();
  if (isContentEditableFalse$2(element) || name === &#39;IMG&#39;) {
    return {
      name: name,
      index: findIndex$3(selection.dom, name, element)
    };
  }
  var sibling = findAdjacentContentEditableFalseElm(rng);
  if (sibling) {
    name = sibling.tagName;
    return {
      name: name,
      index: findIndex$3(selection.dom, name, sibling)
    };
  }
  return getLocation(trim, selection, normalized, rng);
};
var getCaretBookmark = function (selection) {
  var rng = selection.getRng();
  return {
    start: create$2(selection.dom.getRoot(), CaretPosition$1.fromRangeStart(rng)),
    end: create$2(selection.dom.getRoot(), CaretPosition$1.fromRangeEnd(rng))
  };
};
var getRangeBookmark = function (selection) {
  return { rng: selection.getRng() };
};
var createBookmarkSpan = function (dom, id, filled) {
  var args = {
    &#39;data-mce-type&#39;: &#39;bookmark&#39;,
    &#39;id&#39;: id,
    &#39;style&#39;: &#39;overflow:hidden;line-height:0px&#39;
  };
  return filled ? dom.create(&#39;span&#39;, args, &#39;&amp;#xFEFF;&#39;) : dom.create(&#39;span&#39;, args);
};
var getPersistentBookmark = function (selection, filled) {
  var dom = selection.dom;
  var rng = selection.getRng();
  var id = dom.uniqueId();
  var collapsed = selection.isCollapsed();
  var element = selection.getNode();
  var name = element.nodeName;
  if (name === &#39;IMG&#39;) {
    return {
      name: name,
      index: findIndex$3(dom, name, element)
    };
  }
  var rng2 = normalizeTableCellSelection(rng.cloneRange());
  if (!collapsed) {
    rng2.collapse(false);
    var endBookmarkNode = createBookmarkSpan(dom, id + &#39;_end&#39;, filled);
    rng2.insertNode(endBookmarkNode);
    trimEmptyTextNode(endBookmarkNode.nextSibling);
  }
  rng = normalizeTableCellSelection(rng);
  rng.collapse(true);
  var startBookmarkNode = createBookmarkSpan(dom, id + &#39;_start&#39;, filled);
  rng.insertNode(startBookmarkNode);
  trimEmptyTextNode(startBookmarkNode.previousSibling);
  trimEmptyTextNode(startBookmarkNode.nextSibling);
  selection.moveToBookmark({
    id: id,
    keep: 1
  });
  return { id: id };
};
var getBookmark = function (selection, type, normalized) {
  if (type === 2) {
    return getOffsetBookmark(Zwsp.trim, normalized, selection);
  } else if (type === 3) {
    return getCaretBookmark(selection);
  } else if (type) {
    return getRangeBookmark(selection);
  } else {
    return getPersistentBookmark(selection, false);
  }
};
var GetBookmark = {
  getBookmark: getBookmark,
  getUndoBookmark: curry(getOffsetBookmark, identity, true),
  getPersistentBookmark: getPersistentBookmark
};

var CARET_ID = &#39;_mce_caret&#39;;
var isCaretNode = function (node) {
  return NodeType.isElement(node) &amp;&amp; node.id === CARET_ID;
};
var getParentCaretContainer = function (body, node) {
  while (node &amp;&amp; node !== body) {
    if (node.id === CARET_ID) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
};

var isElement$4 = NodeType.isElement;
var isText$6 = NodeType.isText;
var removeNode = function (node) {
  var parentNode = node.parentNode;
  if (parentNode) {
    parentNode.removeChild(node);
  }
};
var getNodeValue = function (node) {
  try {
    return node.nodeValue;
  } catch (ex) {
    return &#39;&#39;;
  }
};
var setNodeValue = function (node, text) {
  if (text.length === 0) {
    removeNode(node);
  } else {
    node.nodeValue = text;
  }
};
var trimCount = function (text) {
  var trimmedText = Zwsp.trim(text);
  return {
    count: text.length - trimmedText.length,
    text: trimmedText
  };
};
var removeUnchanged = function (caretContainer, pos) {
  remove$7(caretContainer);
  return pos;
};
var removeTextAndReposition = function (caretContainer, pos) {
  var before = trimCount(caretContainer.data.substr(0, pos.offset()));
  var after = trimCount(caretContainer.data.substr(pos.offset()));
  var text = before.text + after.text;
  if (text.length &gt; 0) {
    setNodeValue(caretContainer, text);
    return CaretPosition$1(caretContainer, pos.offset() - before.count);
  } else {
    return pos;
  }
};
var removeElementAndReposition = function (caretContainer, pos) {
  var parentNode = pos.container();
  var newPosition = indexOf(from$1(parentNode.childNodes), caretContainer).map(function (index) {
    return index &lt; pos.offset() ? CaretPosition$1(parentNode, pos.offset() - 1) : pos;
  }).getOr(pos);
  remove$7(caretContainer);
  return newPosition;
};
var removeTextCaretContainer = function (caretContainer, pos) {
  return isText$6(caretContainer) &amp;&amp; pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
};
var removeElementCaretContainer = function (caretContainer, pos) {
  return pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
};
var removeAndReposition = function (container, pos) {
  return CaretPosition$1.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
};
var remove$7 = function (caretContainerNode) {
  if (isElement$4(caretContainerNode) &amp;&amp; isCaretContainer(caretContainerNode)) {
    if (hasContent(caretContainerNode)) {
      caretContainerNode.removeAttribute(&#39;data-mce-caret&#39;);
    } else {
      removeNode(caretContainerNode);
    }
  }
  if (isText$6(caretContainerNode)) {
    var text = Zwsp.trim(getNodeValue(caretContainerNode));
    setNodeValue(caretContainerNode, text);
  }
};
var CaretContainerRemove = {
  removeAndReposition: removeAndReposition,
  remove: remove$7
};

var browser$2 = PlatformDetection$1.detect().browser;
var isContentEditableFalse$3 = NodeType.isContentEditableFalse;
var isTableCell$1 = function (node) {
  return NodeType.isElement(node) &amp;&amp; /^(TD|TH)$/i.test(node.tagName);
};
var getAbsoluteClientRect = function (root, element, before) {
  var clientRect = collapse(element.getBoundingClientRect(), before);
  var docElm, scrollX, scrollY, margin, rootRect;
  if (root.tagName === &#39;BODY&#39;) {
    docElm = root.ownerDocument.documentElement;
    scrollX = root.scrollLeft || docElm.scrollLeft;
    scrollY = root.scrollTop || docElm.scrollTop;
  } else {
    rootRect = root.getBoundingClientRect();
    scrollX = root.scrollLeft - rootRect.left;
    scrollY = root.scrollTop - rootRect.top;
  }
  clientRect.left += scrollX;
  clientRect.right += scrollX;
  clientRect.top += scrollY;
  clientRect.bottom += scrollY;
  clientRect.width = 1;
  margin = element.offsetWidth - element.clientWidth;
  if (margin &gt; 0) {
    if (before) {
      margin *= -1;
    }
    clientRect.left += margin;
    clientRect.right += margin;
  }
  return clientRect;
};
var trimInlineCaretContainers = function (root) {
  var contentEditableFalseNodes, node, sibling, i, data;
  contentEditableFalseNodes = DomQuery(&#39;*[contentEditable=false]&#39;, root);
  for (i = 0; i &lt; contentEditableFalseNodes.length; i++) {
    node = contentEditableFalseNodes[i];
    sibling = node.previousSibling;
    if (endsWithCaretContainer(sibling)) {
      data = sibling.data;
      if (data.length === 1) {
        sibling.parentNode.removeChild(sibling);
      } else {
        sibling.deleteData(data.length - 1, 1);
      }
    }
    sibling = node.nextSibling;
    if (startsWithCaretContainer(sibling)) {
      data = sibling.data;
      if (data.length === 1) {
        sibling.parentNode.removeChild(sibling);
      } else {
        sibling.deleteData(0, 1);
      }
    }
  }
};
var FakeCaret = function (root, isBlock, hasFocus) {
  var lastVisualCaret = Cell(Option.none());
  var cursorInterval, caretContainerNode;
  var show = function (before, element) {
    var clientRect, rng;
    hide();
    if (isTableCell$1(element)) {
      return null;
    }
    if (isBlock(element)) {
      caretContainerNode = insertBlock(&#39;p&#39;, element, before);
      clientRect = getAbsoluteClientRect(root, element, before);
      DomQuery(caretContainerNode).css(&#39;top&#39;, clientRect.top);
      var caret = DomQuery(&#39;&lt;div class=&quot;mce-visual-caret&quot; data-mce-bogus=&quot;all&quot;&gt;&lt;/div&gt;&#39;).css(clientRect).appendTo(root)[0];
      lastVisualCaret.set(Option.some({
        caret: caret,
        element: element,
        before: before
      }));
      lastVisualCaret.get().each(function (caretState) {
        if (before) {
          DomQuery(caretState.caret).addClass(&#39;mce-visual-caret-before&#39;);
        }
      });
      startBlink();
      rng = element.ownerDocument.createRange();
      rng.setStart(caretContainerNode, 0);
      rng.setEnd(caretContainerNode, 0);
    } else {
      caretContainerNode = insertInline(element, before);
      rng = element.ownerDocument.createRange();
      if (isContentEditableFalse$3(caretContainerNode.nextSibling)) {
        rng.setStart(caretContainerNode, 0);
        rng.setEnd(caretContainerNode, 0);
      } else {
        rng.setStart(caretContainerNode, 1);
        rng.setEnd(caretContainerNode, 1);
      }
      return rng;
    }
    return rng;
  };
  var hide = function () {
    trimInlineCaretContainers(root);
    if (caretContainerNode) {
      CaretContainerRemove.remove(caretContainerNode);
      caretContainerNode = null;
    }
    lastVisualCaret.get().each(function (caretState) {
      DomQuery(caretState.caret).remove();
      lastVisualCaret.set(Option.none());
    });
    clearInterval(cursorInterval);
  };
  var startBlink = function () {
    cursorInterval = Delay.setInterval(function () {
      if (hasFocus()) {
        DomQuery(&#39;div.mce-visual-caret&#39;, root).toggleClass(&#39;mce-visual-caret-hidden&#39;);
      } else {
        DomQuery(&#39;div.mce-visual-caret&#39;, root).addClass(&#39;mce-visual-caret-hidden&#39;);
      }
    }, 500);
  };
  var reposition = function () {
    lastVisualCaret.get().each(function (caretState) {
      var clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
      DomQuery(caretState.caret).css(clientRect);
    });
  };
  var destroy = function () {
    return Delay.clearInterval(cursorInterval);
  };
  var getCss = function () {
    return &#39;.mce-visual-caret {&#39; + &#39;position: absolute;&#39; + &#39;background-color: black;&#39; + &#39;background-color: currentcolor;&#39; + &#39;}&#39; + &#39;.mce-visual-caret-hidden {&#39; + &#39;display: none;&#39; + &#39;}&#39; + &#39;*[data-mce-caret] {&#39; + &#39;position: absolute;&#39; + &#39;left: -1000px;&#39; + &#39;right: auto;&#39; + &#39;top: 0;&#39; + &#39;margin: 0;&#39; + &#39;padding: 0;&#39; + &#39;}&#39;;
  };
  return {
    show: show,
    hide: hide,
    getCss: getCss,
    reposition: reposition,
    destroy: destroy
  };
};
var isFakeCaretTableBrowser = function () {
  return browser$2.isIE() || browser$2.isEdge() || browser$2.isFirefox();
};
var isFakeCaretTarget = function (node) {
  return isContentEditableFalse$3(node) || NodeType.isTable(node) &amp;&amp; isFakeCaretTableBrowser();
};

var is$3 = function (expected) {
  return function (actual) {
    return expected === actual;
  };
};
var isNbsp = is$3(&#39;\xA0&#39;);
var isWhiteSpace$1 = function (chr) {
  return /^[\r\n\t ]$/.test(chr);
};
var isContent = function (chr) {
  return !isWhiteSpace$1(chr) &amp;&amp; !isNbsp(chr);
};

var isContentEditableFalse$4 = NodeType.isContentEditableFalse;
var isBlockLike = NodeType.matchStyleValues(&#39;display&#39;, &#39;block table table-cell table-caption list-item&#39;);
var isCaretContainer$2 = isCaretContainer;
var isCaretContainerBlock$1 = isCaretContainerBlock;
var isElement$5 = NodeType.isElement;
var isCaretCandidate$2 = isCaretCandidate;
var isForwards = function (direction) {
  return direction &gt; 0;
};
var isBackwards = function (direction) {
  return direction &lt; 0;
};
var skipCaretContainers = function (walk, shallow) {
  var node;
  while (node = walk(shallow)) {
    if (!isCaretContainerBlock$1(node)) {
      return node;
    }
  }
  return null;
};
var findNode = function (node, direction, predicateFn, rootNode, shallow) {
  var walker = new TreeWalker(node, rootNode);
  if (isBackwards(direction)) {
    if (isContentEditableFalse$4(node) || isCaretContainerBlock$1(node)) {
      node = skipCaretContainers(walker.prev, true);
      if (predicateFn(node)) {
        return node;
      }
    }
    while (node = skipCaretContainers(walker.prev, shallow)) {
      if (predicateFn(node)) {
        return node;
      }
    }
  }
  if (isForwards(direction)) {
    if (isContentEditableFalse$4(node) || isCaretContainerBlock$1(node)) {
      node = skipCaretContainers(walker.next, true);
      if (predicateFn(node)) {
        return node;
      }
    }
    while (node = skipCaretContainers(walker.next, shallow)) {
      if (predicateFn(node)) {
        return node;
      }
    }
  }
  return null;
};
var getParentBlock = function (node, rootNode) {
  while (node &amp;&amp; node !== rootNode) {
    if (isBlockLike(node)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
};
var isInSameBlock = function (caretPosition1, caretPosition2, rootNode) {
  return getParentBlock(caretPosition1.container(), rootNode) === getParentBlock(caretPosition2.container(), rootNode);
};
var getChildNodeAtRelativeOffset = function (relativeOffset, caretPosition) {
  var container, offset;
  if (!caretPosition) {
    return null;
  }
  container = caretPosition.container();
  offset = caretPosition.offset();
  if (!isElement$5(container)) {
    return null;
  }
  return container.childNodes[offset + relativeOffset];
};
var beforeAfter = function (before, node) {
  var range = node.ownerDocument.createRange();
  if (before) {
    range.setStartBefore(node);
    range.setEndBefore(node);
  } else {
    range.setStartAfter(node);
    range.setEndAfter(node);
  }
  return range;
};
var isNodesInSameBlock = function (root, node1, node2) {
  return getParentBlock(node1, root) === getParentBlock(node2, root);
};
var lean = function (left, root, node) {
  var sibling, siblingName;
  if (left) {
    siblingName = &#39;previousSibling&#39;;
  } else {
    siblingName = &#39;nextSibling&#39;;
  }
  while (node &amp;&amp; node !== root) {
    sibling = node[siblingName];
    if (isCaretContainer$2(sibling)) {
      sibling = sibling[siblingName];
    }
    if (isContentEditableFalse$4(sibling)) {
      if (isNodesInSameBlock(root, sibling, node)) {
        return sibling;
      }
      break;
    }
    if (isCaretCandidate$2(sibling)) {
      break;
    }
    node = node.parentNode;
  }
  return null;
};
var before$2 = curry(beforeAfter, true);
var after$2 = curry(beforeAfter, false);
var normalizeRange = function (direction, root, range) {
  var node, container, offset, location;
  var leanLeft = curry(lean, true, root);
  var leanRight = curry(lean, false, root);
  container = range.startContainer;
  offset = range.startOffset;
  if (isCaretContainerBlock(container)) {
    if (!isElement$5(container)) {
      container = container.parentNode;
    }
    location = container.getAttribute(&#39;data-mce-caret&#39;);
    if (location === &#39;before&#39;) {
      node = container.nextSibling;
      if (isFakeCaretTarget(node)) {
        return before$2(node);
      }
    }
    if (location === &#39;after&#39;) {
      node = container.previousSibling;
      if (isFakeCaretTarget(node)) {
        return after$2(node);
      }
    }
  }
  if (!range.collapsed) {
    return range;
  }
  if (NodeType.isText(container)) {
    if (isCaretContainer$2(container)) {
      if (direction === 1) {
        node = leanRight(container);
        if (node) {
          return before$2(node);
        }
        node = leanLeft(container);
        if (node) {
          return after$2(node);
        }
      }
      if (direction === -1) {
        node = leanLeft(container);
        if (node) {
          return after$2(node);
        }
        node = leanRight(container);
        if (node) {
          return before$2(node);
        }
      }
      return range;
    }
    if (endsWithCaretContainer(container) &amp;&amp; offset &gt;= container.data.length - 1) {
      if (direction === 1) {
        node = leanRight(container);
        if (node) {
          return before$2(node);
        }
      }
      return range;
    }
    if (startsWithCaretContainer(container) &amp;&amp; offset &lt;= 1) {
      if (direction === -1) {
        node = leanLeft(container);
        if (node) {
          return after$2(node);
        }
      }
      return range;
    }
    if (offset === container.data.length) {
      node = leanRight(container);
      if (node) {
        return before$2(node);
      }
      return range;
    }
    if (offset === 0) {
      node = leanLeft(container);
      if (node) {
        return after$2(node);
      }
      return range;
    }
  }
  return range;
};
var isNextToContentEditableFalse = function (relativeOffset, caretPosition) {
  var node = getChildNodeAtRelativeOffset(relativeOffset, caretPosition);
  return isContentEditableFalse$4(node) &amp;&amp; !NodeType.isBogusAll(node);
};
var isNextToTable = function (relativeOffset, caretPosition) {
  return NodeType.isTable(getChildNodeAtRelativeOffset(relativeOffset, caretPosition));
};
var getRelativeCefElm = function (forward, caretPosition) {
  return Option.from(getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition)).filter(isContentEditableFalse$4);
};
var getNormalizedRangeEndPoint = function (direction, root, range) {
  var normalizedRange = normalizeRange(direction, root, range);
  if (direction === -1) {
    return CaretPosition.fromRangeStart(normalizedRange);
  }
  return CaretPosition.fromRangeEnd(normalizedRange);
};
var isBeforeContentEditableFalse = curry(isNextToContentEditableFalse, 0);
var isAfterContentEditableFalse = curry(isNextToContentEditableFalse, -1);
var isBeforeTable = curry(isNextToTable, 0);
var isAfterTable = curry(isNextToTable, -1);
var isChar = function (forward, predicate, pos) {
  return Option.from(pos.container()).filter(NodeType.isText).exists(function (text) {
    var delta = forward ? 0 : -1;
    return predicate(text.data.charAt(pos.offset() + delta));
  });
};
var isBeforeSpace = curry(isChar, true, isWhiteSpace$1);
var isAfterSpace = curry(isChar, false, isWhiteSpace$1);
var getElementFromPosition = function (pos) {
  return Option.from(pos.getNode()).map(Element$$1.fromDom);
};
var getElementFromPrevPosition = function (pos) {
  return Option.from(pos.getNode(true)).map(Element$$1.fromDom);
};

var HDirection;
(function (HDirection) {
  HDirection[HDirection[&#39;Backwards&#39;] = -1] = &#39;Backwards&#39;;
  HDirection[HDirection[&#39;Forwards&#39;] = 1] = &#39;Forwards&#39;;
}(HDirection || (HDirection = {})));
var isContentEditableFalse$5 = NodeType.isContentEditableFalse;
var isText$7 = NodeType.isText;
var isElement$6 = NodeType.isElement;
var isBr$4 = NodeType.isBr;
var isCaretCandidate$3 = isCaretCandidate;
var isAtomic$1 = isAtomic;
var isEditableCaretCandidate$1 = isEditableCaretCandidate;
var getParents = function (node, root) {
  var parents = [];
  while (node &amp;&amp; node !== root) {
    parents.push(node);
    node = node.parentNode;
  }
  return parents;
};
var nodeAtIndex = function (container, offset) {
  if (container.hasChildNodes() &amp;&amp; offset &lt; container.childNodes.length) {
    return container.childNodes[offset];
  }
  return null;
};
var getCaretCandidatePosition = function (direction, node) {
  if (isForwards(direction)) {
    if (isCaretCandidate$3(node.previousSibling) &amp;&amp; !isText$7(node.previousSibling)) {
      return CaretPosition$1.before(node);
    }
    if (isText$7(node)) {
      return CaretPosition$1(node, 0);
    }
  }
  if (isBackwards(direction)) {
    if (isCaretCandidate$3(node.nextSibling) &amp;&amp; !isText$7(node.nextSibling)) {
      return CaretPosition$1.after(node);
    }
    if (isText$7(node)) {
      return CaretPosition$1(node, node.data.length);
    }
  }
  if (isBackwards(direction)) {
    if (isBr$4(node)) {
      return CaretPosition$1.before(node);
    }
    return CaretPosition$1.after(node);
  }
  return CaretPosition$1.before(node);
};
var isBrBeforeBlock = function (node, root) {
  var next;
  if (!NodeType.isBr(node)) {
    return false;
  }
  if (isAtomic(node.nextSibling)) {
    return false;
  }
  next = findCaretPosition(HDirection.Forwards, CaretPosition$1.after(node), root);
  if (!next) {
    return false;
  }
  return !isInSameBlock(CaretPosition$1.before(node), CaretPosition$1.before(next), root);
};
var findCaretPosition = function (direction, startPos, root) {
  var node, nextNode, innerNode;
  var rootContentEditableFalseElm, caretPosition;
  if (!isElement$6(root) || !startPos) {
    return null;
  }
  if (startPos.isEqual(CaretPosition$1.after(root)) &amp;&amp; root.lastChild) {
    caretPosition = CaretPosition$1.after(root.lastChild);
    if (isBackwards(direction) &amp;&amp; isCaretCandidate$3(root.lastChild) &amp;&amp; isElement$6(root.lastChild)) {
      return isBr$4(root.lastChild) ? CaretPosition$1.before(root.lastChild) : caretPosition;
    }
  } else {
    caretPosition = startPos;
  }
  var container = caretPosition.container();
  var offset = caretPosition.offset();
  if (isText$7(container)) {
    if (isBackwards(direction) &amp;&amp; offset &gt; 0) {
      return CaretPosition$1(container, --offset);
    }
    if (isForwards(direction) &amp;&amp; offset &lt; container.length) {
      return CaretPosition$1(container, ++offset);
    }
    node = container;
  } else {
    if (isBackwards(direction) &amp;&amp; offset &gt; 0) {
      nextNode = nodeAtIndex(container, offset - 1);
      if (isCaretCandidate$3(nextNode)) {
        if (!isAtomic$1(nextNode)) {
          innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
          if (innerNode) {
            if (isText$7(innerNode)) {
              return CaretPosition$1(innerNode, innerNode.data.length);
            }
            return CaretPosition$1.after(innerNode);
          }
        }
        if (isText$7(nextNode)) {
          return CaretPosition$1(nextNode, nextNode.data.length);
        }
        return CaretPosition$1.before(nextNode);
      }
    }
    if (isForwards(direction) &amp;&amp; offset &lt; container.childNodes.length) {
      nextNode = nodeAtIndex(container, offset);
      if (isCaretCandidate$3(nextNode)) {
        if (isBr$4(nextNode) &amp;&amp; root.lastChild === nextNode) {
          return null;
        }
        if (isBrBeforeBlock(nextNode, root)) {
          return findCaretPosition(direction, CaretPosition$1.after(nextNode), root);
        }
        if (!isAtomic$1(nextNode)) {
          innerNode = findNode(nextNode, direction, isEditableCaretCandidate$1, nextNode);
          if (innerNode) {
            if (isText$7(innerNode)) {
              return CaretPosition$1(innerNode, 0);
            }
            return CaretPosition$1.before(innerNode);
          }
        }
        if (isText$7(nextNode)) {
          return CaretPosition$1(nextNode, 0);
        }
        return CaretPosition$1.after(nextNode);
      }
    }
    node = nextNode ? nextNode : caretPosition.getNode();
  }
  if (isForwards(direction) &amp;&amp; caretPosition.isAtEnd() || isBackwards(direction) &amp;&amp; caretPosition.isAtStart()) {
    node = findNode(node, direction, constant(true), root, true);
    if (isEditableCaretCandidate$1(node, root)) {
      return getCaretCandidatePosition(direction, node);
    }
  }
  nextNode = findNode(node, direction, isEditableCaretCandidate$1, root);
  rootContentEditableFalseElm = ArrUtils.last(filter(getParents(container, root), isContentEditableFalse$5));
  if (rootContentEditableFalseElm &amp;&amp; (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
    if (isForwards(direction)) {
      caretPosition = CaretPosition$1.after(rootContentEditableFalseElm);
    } else {
      caretPosition = CaretPosition$1.before(rootContentEditableFalseElm);
    }
    return caretPosition;
  }
  if (nextNode) {
    return getCaretCandidatePosition(direction, nextNode);
  }
  return null;
};
var CaretWalker = function (root) {
  return {
    next: function (caretPosition) {
      return findCaretPosition(HDirection.Forwards, caretPosition, root);
    },
    prev: function (caretPosition) {
      return findCaretPosition(HDirection.Backwards, caretPosition, root);
    }
  };
};

var walkToPositionIn = function (forward, root, start) {
  var position = forward ? CaretPosition$1.before(start) : CaretPosition$1.after(start);
  return fromPosition(forward, root, position);
};
var afterElement = function (node) {
  return NodeType.isBr(node) ? CaretPosition$1.before(node) : CaretPosition$1.after(node);
};
var isBeforeOrStart = function (position) {
  if (CaretPosition$1.isTextPosition(position)) {
    return position.offset() === 0;
  } else {
    return isCaretCandidate(position.getNode());
  }
};
var isAfterOrEnd = function (position) {
  if (CaretPosition$1.isTextPosition(position)) {
    var container = position.container();
    return position.offset() === container.data.length;
  } else {
    return isCaretCandidate(position.getNode(true));
  }
};
var isBeforeAfterSameElement = function (from, to) {
  return !CaretPosition$1.isTextPosition(from) &amp;&amp; !CaretPosition$1.isTextPosition(to) &amp;&amp; from.getNode() === to.getNode(true);
};
var isAtBr = function (position) {
  return !CaretPosition$1.isTextPosition(position) &amp;&amp; NodeType.isBr(position.getNode());
};
var shouldSkipPosition = function (forward, from, to) {
  if (forward) {
    return !isBeforeAfterSameElement(from, to) &amp;&amp; !isAtBr(from) &amp;&amp; isAfterOrEnd(from) &amp;&amp; isBeforeOrStart(to);
  } else {
    return !isBeforeAfterSameElement(to, from) &amp;&amp; isBeforeOrStart(from) &amp;&amp; isAfterOrEnd(to);
  }
};
var fromPosition = function (forward, root, pos) {
  var walker = CaretWalker(root);
  return Option.from(forward ? walker.next(pos) : walker.prev(pos));
};
var navigate = function (forward, root, from) {
  return fromPosition(forward, root, from).bind(function (to) {
    if (isInSameBlock(from, to, root) &amp;&amp; shouldSkipPosition(forward, from, to)) {
      return fromPosition(forward, root, to);
    } else {
      return Option.some(to);
    }
  });
};
var positionIn = function (forward, element) {
  var startNode = forward ? element.firstChild : element.lastChild;
  if (NodeType.isText(startNode)) {
    return Option.some(CaretPosition$1(startNode, forward ? 0 : startNode.data.length));
  } else if (startNode) {
    if (isCaretCandidate(startNode)) {
      return Option.some(forward ? CaretPosition$1.before(startNode) : afterElement(startNode));
    } else {
      return walkToPositionIn(forward, element, startNode);
    }
  } else {
    return Option.none();
  }
};
var nextPosition = curry(fromPosition, true);
var prevPosition = curry(fromPosition, false);
var CaretFinder = {
  fromPosition: fromPosition,
  nextPosition: nextPosition,
  prevPosition: prevPosition,
  navigate: navigate,
  positionIn: positionIn,
  firstPositionIn: curry(positionIn, true),
  lastPositionIn: curry(positionIn, false)
};

var isStringPathBookmark = function (bookmark) {
  return typeof bookmark.start === &#39;string&#39;;
};
var isRangeBookmark = function (bookmark) {
  return bookmark.hasOwnProperty(&#39;rng&#39;);
};
var isIdBookmark = function (bookmark) {
  return bookmark.hasOwnProperty(&#39;id&#39;);
};
var isIndexBookmark = function (bookmark) {
  return bookmark.hasOwnProperty(&#39;name&#39;);
};
var isPathBookmark = function (bookmark) {
  return Tools.isArray(bookmark.start);
};

var addBogus = function (dom, node) {
  if (dom.isBlock(node) &amp;&amp; !node.innerHTML &amp;&amp; !Env.ie) {
    node.innerHTML = &#39;&lt;br data-mce-bogus=&quot;1&quot; /&gt;&#39;;
  }
  return node;
};
var resolveCaretPositionBookmark = function (dom, bookmark) {
  var rng, pos;
  rng = dom.createRng();
  pos = resolve$2(dom.getRoot(), bookmark.start);
  rng.setStart(pos.container(), pos.offset());
  pos = resolve$2(dom.getRoot(), bookmark.end);
  rng.setEnd(pos.container(), pos.offset());
  return rng;
};
var insertZwsp = function (node, rng) {
  var textNode = node.ownerDocument.createTextNode(Zwsp.ZWSP);
  node.appendChild(textNode);
  rng.setStart(textNode, 0);
  rng.setEnd(textNode, 0);
};
var isEmpty = function (node) {
  return node.hasChildNodes() === false;
};
var tryFindRangePosition = function (node, rng) {
  return CaretFinder.lastPositionIn(node).fold(function () {
    return false;
  }, function (pos) {
    rng.setStart(pos.container(), pos.offset());
    rng.setEnd(pos.container(), pos.offset());
    return true;
  });
};
var padEmptyCaretContainer = function (root, node, rng) {
  if (isEmpty(node) &amp;&amp; getParentCaretContainer(root, node)) {
    insertZwsp(node, rng);
    return true;
  } else {
    return false;
  }
};
var setEndPoint = function (dom, start, bookmark, rng) {
  var point = bookmark[start ? &#39;start&#39; : &#39;end&#39;];
  var i, node, offset, children;
  var root = dom.getRoot();
  if (point) {
    offset = point[0];
    for (node = root, i = point.length - 1; i &gt;= 1; i--) {
      children = node.childNodes;
      if (padEmptyCaretContainer(root, node, rng)) {
        return true;
      }
      if (point[i] &gt; children.length - 1) {
        if (padEmptyCaretContainer(root, node, rng)) {
          return true;
        }
        return tryFindRangePosition(node, rng);
      }
      node = children[point[i]];
    }
    if (node.nodeType === 3) {
      offset = Math.min(point[0], node.nodeValue.length);
    }
    if (node.nodeType === 1) {
      offset = Math.min(point[0], node.childNodes.length);
    }
    if (start) {
      rng.setStart(node, offset);
    } else {
      rng.setEnd(node, offset);
    }
  }
  return true;
};
var isValidTextNode = function (node) {
  return NodeType.isText(node) &amp;&amp; node.data.length &gt; 0;
};
var restoreEndPoint = function (dom, suffix, bookmark) {
  var marker = dom.get(bookmark.id + &#39;_&#39; + suffix), node, idx, next, prev;
  var keep = bookmark.keep;
  var container, offset;
  if (marker) {
    node = marker.parentNode;
    if (suffix === &#39;start&#39;) {
      if (!keep) {
        idx = dom.nodeIndex(marker);
      } else {
        if (marker.hasChildNodes()) {
          node = marker.firstChild;
          idx = 1;
        } else if (isValidTextNode(marker.nextSibling)) {
          node = marker.nextSibling;
          idx = 0;
        } else if (isValidTextNode(marker.previousSibling)) {
          node = marker.previousSibling;
          idx = marker.previousSibling.data.length;
        } else {
          node = marker.parentNode;
          idx = dom.nodeIndex(marker) + 1;
        }
      }
      container = node;
      offset = idx;
    } else {
      if (!keep) {
        idx = dom.nodeIndex(marker);
      } else {
        if (marker.hasChildNodes()) {
          node = marker.firstChild;
          idx = 1;
        } else if (isValidTextNode(marker.previousSibling)) {
          node = marker.previousSibling;
          idx = marker.previousSibling.data.length;
        } else {
          node = marker.parentNode;
          idx = dom.nodeIndex(marker);
        }
      }
      container = node;
      offset = idx;
    }
    if (!keep) {
      prev = marker.previousSibling;
      next = marker.nextSibling;
      Tools.each(Tools.grep(marker.childNodes), function (node) {
        if (NodeType.isText(node)) {
          node.nodeValue = node.nodeValue.replace(/\uFEFF/g, &#39;&#39;);
        }
      });
      while (marker = dom.get(bookmark.id + &#39;_&#39; + suffix)) {
        dom.remove(marker, true);
      }
      if (prev &amp;&amp; next &amp;&amp; prev.nodeType === next.nodeType &amp;&amp; NodeType.isText(prev) &amp;&amp; !Env.opera) {
        idx = prev.nodeValue.length;
        prev.appendData(next.nodeValue);
        dom.remove(next);
        if (suffix === &#39;start&#39;) {
          container = prev;
          offset = idx;
        } else {
          container = prev;
          offset = idx;
        }
      }
    }
    return Option.some(CaretPosition$1(container, offset));
  } else {
    return Option.none();
  }
};
var alt = function (o1, o2) {
  return o1.isSome() ? o1 : o2;
};
var resolvePaths = function (dom, bookmark) {
  var rng = dom.createRng();
  if (setEndPoint(dom, true, bookmark, rng) &amp;&amp; setEndPoint(dom, false, bookmark, rng)) {
    return Option.some(rng);
  } else {
    return Option.none();
  }
};
var resolveId = function (dom, bookmark) {
  var startPos = restoreEndPoint(dom, &#39;start&#39;, bookmark);
  var endPos = restoreEndPoint(dom, &#39;end&#39;, bookmark);
  return liftN([
    startPos,
    alt(endPos, startPos)
  ], function (spos, epos) {
    var rng = dom.createRng();
    rng.setStart(addBogus(dom, spos.container()), spos.offset());
    rng.setEnd(addBogus(dom, epos.container()), epos.offset());
    return rng;
  });
};
var resolveIndex$1 = function (dom, bookmark) {
  return Option.from(dom.select(bookmark.name)[bookmark.index]).map(function (elm) {
    var rng = dom.createRng();
    rng.selectNode(elm);
    return rng;
  });
};
var resolve$3 = function (selection, bookmark) {
  var dom = selection.dom;
  if (bookmark) {
    if (isPathBookmark(bookmark)) {
      return resolvePaths(dom, bookmark);
    } else if (isStringPathBookmark(bookmark)) {
      return Option.some(resolveCaretPositionBookmark(dom, bookmark));
    } else if (isIdBookmark(bookmark)) {
      return resolveId(dom, bookmark);
    } else if (isIndexBookmark(bookmark)) {
      return resolveIndex$1(dom, bookmark);
    } else if (isRangeBookmark(bookmark)) {
      return Option.some(bookmark.rng);
    }
  }
  return Option.none();
};
var ResolveBookmark = { resolve: resolve$3 };

var getBookmark$1 = function (selection, type, normalized) {
  return GetBookmark.getBookmark(selection, type, normalized);
};
var moveToBookmark = function (selection, bookmark) {
  ResolveBookmark.resolve(selection, bookmark).each(function (rng) {
    selection.setRng(rng);
  });
};
var isBookmarkNode$1 = function (node) {
  return NodeType.isElement(node) &amp;&amp; node.tagName === &#39;SPAN&#39; &amp;&amp; node.getAttribute(&#39;data-mce-type&#39;) === &#39;bookmark&#39;;
};
var Bookmarks = {
  getBookmark: getBookmark$1,
  moveToBookmark: moveToBookmark,
  isBookmarkNode: isBookmarkNode$1
};

var isInlineBlock = function (node) {
  return node &amp;&amp; /^(IMG)$/.test(node.nodeName);
};
var moveStart = function (dom, selection, rng) {
  var offset = rng.startOffset;
  var container = rng.startContainer, walker, node, nodes;
  if (rng.startContainer === rng.endContainer) {
    if (isInlineBlock(rng.startContainer.childNodes[rng.startOffset])) {
      return;
    }
  }
  if (container.nodeType === 1) {
    nodes = container.childNodes;
    if (offset &lt; nodes.length) {
      container = nodes[offset];
      walker = new TreeWalker(container, dom.getParent(container, dom.isBlock));
    } else {
      container = nodes[nodes.length - 1];
      walker = new TreeWalker(container, dom.getParent(container, dom.isBlock));
      walker.next(true);
    }
    for (node = walker.current(); node; node = walker.next()) {
      if (node.nodeType === 3 &amp;&amp; !isWhiteSpaceNode(node)) {
        rng.setStart(node, 0);
        selection.setRng(rng);
        return;
      }
    }
  }
};
var getNonWhiteSpaceSibling = function (node, next, inc) {
  if (node) {
    next = next ? &#39;nextSibling&#39; : &#39;previousSibling&#39;;
    for (node = inc ? node : node[next]; node; node = node[next]) {
      if (node.nodeType === 1 || !isWhiteSpaceNode(node)) {
        return node;
      }
    }
  }
};
var isTextBlock$1 = function (editor, name) {
  if (name.nodeType) {
    name = name.nodeName;
  }
  return !!editor.schema.getTextBlockElements()[name.toLowerCase()];
};
var isValid = function (ed, parent, child) {
  return ed.schema.isValidChild(parent, child);
};
var isWhiteSpaceNode = function (node) {
  return node &amp;&amp; node.nodeType === 3 &amp;&amp; /^([\t \r\n]+|)$/.test(node.nodeValue);
};
var replaceVars = function (value, vars) {
  if (typeof value !== &#39;string&#39;) {
    value = value(vars);
  } else if (vars) {
    value = value.replace(/%(\w+)/g, function (str, name) {
      return vars[name] || str;
    });
  }
  return value;
};
var isEq = function (str1, str2) {
  str1 = str1 || &#39;&#39;;
  str2 = str2 || &#39;&#39;;
  str1 = &#39;&#39; + (str1.nodeName || str1);
  str2 = &#39;&#39; + (str2.nodeName || str2);
  return str1.toLowerCase() === str2.toLowerCase();
};
var normalizeStyleValue = function (dom, value, name) {
  if (name === &#39;color&#39; || name === &#39;backgroundColor&#39;) {
    value = dom.toHex(value);
  }
  if (name === &#39;fontWeight&#39; &amp;&amp; value === 700) {
    value = &#39;bold&#39;;
  }
  if (name === &#39;fontFamily&#39;) {
    value = value.replace(/[\&#39;\&quot;]/g, &#39;&#39;).replace(/,\s+/g, &#39;,&#39;);
  }
  return &#39;&#39; + value;
};
var getStyle = function (dom, node, name) {
  return normalizeStyleValue(dom, dom.getStyle(node, name), name);
};
var getTextDecoration = function (dom, node) {
  var decoration;
  dom.getParent(node, function (n) {
    decoration = dom.getStyle(n, &#39;text-decoration&#39;);
    return decoration &amp;&amp; decoration !== &#39;none&#39;;
  });
  return decoration;
};
var getParents$1 = function (dom, node, selector) {
  return dom.getParents(node, selector, dom.getRoot());
};
var FormatUtils = {
  isInlineBlock: isInlineBlock,
  moveStart: moveStart,
  getNonWhiteSpaceSibling: getNonWhiteSpaceSibling,
  isTextBlock: isTextBlock$1,
  isValid: isValid,
  isWhiteSpaceNode: isWhiteSpaceNode,
  replaceVars: replaceVars,
  isEq: isEq,
  normalizeStyleValue: normalizeStyleValue,
  getStyle: getStyle,
  getTextDecoration: getTextDecoration,
  getParents: getParents$1
};

var isBookmarkNode$2 = Bookmarks.isBookmarkNode;
var getParents$2 = FormatUtils.getParents, isWhiteSpaceNode$1 = FormatUtils.isWhiteSpaceNode, isTextBlock$2 = FormatUtils.isTextBlock;
var findLeaf = function (node, offset) {
  if (typeof offset === &#39;undefined&#39;) {
    offset = node.nodeType === 3 ? node.length : node.childNodes.length;
  }
  while (node &amp;&amp; node.hasChildNodes()) {
    node = node.childNodes[offset];
    if (node) {
      offset = node.nodeType === 3 ? node.length : node.childNodes.length;
    }
  }
  return {
    node: node,
    offset: offset
  };
};
var excludeTrailingWhitespace = function (endContainer, endOffset) {
  var leaf = findLeaf(endContainer, endOffset);
  if (leaf.node) {
    while (leaf.node &amp;&amp; leaf.offset === 0 &amp;&amp; leaf.node.previousSibling) {
      leaf = findLeaf(leaf.node.previousSibling);
    }
    if (leaf.node &amp;&amp; leaf.offset &gt; 0 &amp;&amp; leaf.node.nodeType === 3 &amp;&amp; leaf.node.nodeValue.charAt(leaf.offset - 1) === &#39; &#39;) {
      if (leaf.offset &gt; 1) {
        endContainer = leaf.node;
        endContainer.splitText(leaf.offset - 1);
      }
    }
  }
  return endContainer;
};
var isBogusBr = function (node) {
  return node.nodeName === &#39;BR&#39; &amp;&amp; node.getAttribute(&#39;data-mce-bogus&#39;) &amp;&amp; !node.nextSibling;
};
var findParentContentEditable = function (dom, node) {
  var parent = node;
  while (parent) {
    if (parent.nodeType === 1 &amp;&amp; dom.getContentEditable(parent)) {
      return dom.getContentEditable(parent) === &#39;false&#39; ? parent : node;
    }
    parent = parent.parentNode;
  }
  return node;
};
var findSpace = function (start, remove, node, offset) {
  var pos, pos2;
  var str = node.nodeValue;
  if (typeof offset === &#39;undefined&#39;) {
    offset = start ? str.length : 0;
  }
  if (start) {
    pos = str.lastIndexOf(&#39; &#39;, offset);
    pos2 = str.lastIndexOf(&#39;\xA0&#39;, offset);
    pos = pos &gt; pos2 ? pos : pos2;
    if (pos !== -1 &amp;&amp; !remove &amp;&amp; (pos &lt; offset || !start) &amp;&amp; pos &lt;= str.length) {
      pos++;
    }
  } else {
    pos = str.indexOf(&#39; &#39;, offset);
    pos2 = str.indexOf(&#39;\xA0&#39;, offset);
    pos = pos !== -1 &amp;&amp; (pos2 === -1 || pos &lt; pos2) ? pos : pos2;
  }
  return pos;
};
var findWordEndPoint = function (dom, body, container, offset, start, remove) {
  var walker, node, pos, lastTextNode;
  if (container.nodeType === 3) {
    pos = findSpace(start, remove, container, offset);
    if (pos !== -1) {
      return {
        container: container,
        offset: pos
      };
    }
    lastTextNode = container;
  }
  walker = new TreeWalker(container, dom.getParent(container, dom.isBlock) || body);
  while (node = walker[start ? &#39;prev&#39; : &#39;next&#39;]()) {
    if (node.nodeType === 3 &amp;&amp; !isBookmarkNode$2(node.parentNode)) {
      lastTextNode = node;
      pos = findSpace(start, remove, node);
      if (pos !== -1) {
        return {
          container: node,
          offset: pos
        };
      }
    } else if (dom.isBlock(node) || FormatUtils.isEq(node, &#39;BR&#39;)) {
      break;
    }
  }
  if (lastTextNode) {
    if (start) {
      offset = 0;
    } else {
      offset = lastTextNode.length;
    }
    return {
      container: lastTextNode,
      offset: offset
    };
  }
};
var findSelectorEndPoint = function (dom, format, rng, container, siblingName) {
  var parents, i, y, curFormat;
  if (container.nodeType === 3 &amp;&amp; container.nodeValue.length === 0 &amp;&amp; container[siblingName]) {
    container = container[siblingName];
  }
  parents = getParents$2(dom, container);
  for (i = 0; i &lt; parents.length; i++) {
    for (y = 0; y &lt; format.length; y++) {
      curFormat = format[y];
      if (&#39;collapsed&#39; in curFormat &amp;&amp; curFormat.collapsed !== rng.collapsed) {
        continue;
      }
      if (dom.is(parents[i], curFormat.selector)) {
        return parents[i];
      }
    }
  }
  return container;
};
var findBlockEndPoint = function (editor, format, container, siblingName) {
  var node;
  var dom = editor.dom;
  var root = dom.getRoot();
  if (!format[0].wrapper) {
    node = dom.getParent(container, format[0].block, root);
  }
  if (!node) {
    var scopeRoot = dom.getParent(container, &#39;LI,TD,TH&#39;);
    node = dom.getParent(container.nodeType === 3 ? container.parentNode : container, function (node) {
      return node !== root &amp;&amp; isTextBlock$2(editor, node);
    }, scopeRoot);
  }
  if (node &amp;&amp; format[0].wrapper) {
    node = getParents$2(dom, node, &#39;ul,ol&#39;).reverse()[0] || node;
  }
  if (!node) {
    node = container;
    while (node[siblingName] &amp;&amp; !dom.isBlock(node[siblingName])) {
      node = node[siblingName];
      if (FormatUtils.isEq(node, &#39;br&#39;)) {
        break;
      }
    }
  }
  return node || container;
};
var findParentContainer = function (dom, format, startContainer, startOffset, endContainer, endOffset, start) {
  var container, parent, sibling, siblingName, root;
  container = parent = start ? startContainer : endContainer;
  siblingName = start ? &#39;previousSibling&#39; : &#39;nextSibling&#39;;
  root = dom.getRoot();
  if (container.nodeType === 3 &amp;&amp; !isWhiteSpaceNode$1(container)) {
    if (start ? startOffset &gt; 0 : endOffset &lt; container.nodeValue.length) {
      return container;
    }
  }
  while (true) {
    if (!format[0].block_expand &amp;&amp; dom.isBlock(parent)) {
      return parent;
    }
    for (sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {
      if (!isBookmarkNode$2(sibling) &amp;&amp; !isWhiteSpaceNode$1(sibling) &amp;&amp; !isBogusBr(sibling)) {
        return parent;
      }
    }
    if (parent === root || parent.parentNode === root) {
      container = parent;
      break;
    }
    parent = parent.parentNode;
  }
  return container;
};
var expandRng = function (editor, rng, format, remove) {
  var endPoint, startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
  var dom = editor.dom;
  if (startContainer.nodeType === 1 &amp;&amp; startContainer.hasChildNodes()) {
    startContainer = getNode(startContainer, startOffset);
    if (startContainer.nodeType === 3) {
      startOffset = 0;
    }
  }
  if (endContainer.nodeType === 1 &amp;&amp; endContainer.hasChildNodes()) {
    endContainer = getNode(endContainer, rng.collapsed ? endOffset : endOffset - 1);
    if (endContainer.nodeType === 3) {
      endOffset = endContainer.nodeValue.length;
    }
  }
  startContainer = findParentContentEditable(dom, startContainer);
  endContainer = findParentContentEditable(dom, endContainer);
  if (isBookmarkNode$2(startContainer.parentNode) || isBookmarkNode$2(startContainer)) {
    startContainer = isBookmarkNode$2(startContainer) ? startContainer : startContainer.parentNode;
    if (rng.collapsed) {
      startContainer = startContainer.previousSibling || startContainer;
    } else {
      startContainer = startContainer.nextSibling || startContainer;
    }
    if (startContainer.nodeType === 3) {
      startOffset = rng.collapsed ? startContainer.length : 0;
    }
  }
  if (isBookmarkNode$2(endContainer.parentNode) || isBookmarkNode$2(endContainer)) {
    endContainer = isBookmarkNode$2(endContainer) ? endContainer : endContainer.parentNode;
    if (rng.collapsed) {
      endContainer = endContainer.nextSibling || endContainer;
    } else {
      endContainer = endContainer.previousSibling || endContainer;
    }
    if (endContainer.nodeType === 3) {
      endOffset = rng.collapsed ? 0 : endContainer.length;
    }
  }
  if (rng.collapsed) {
    endPoint = findWordEndPoint(dom, editor.getBody(), startContainer, startOffset, true, remove);
    if (endPoint) {
      startContainer = endPoint.container;
      startOffset = endPoint.offset;
    }
    endPoint = findWordEndPoint(dom, editor.getBody(), endContainer, endOffset, false, remove);
    if (endPoint) {
      endContainer = endPoint.container;
      endOffset = endPoint.offset;
    }
  }
  if (format[0].inline) {
    endContainer = remove ? endContainer : excludeTrailingWhitespace(endContainer, endOffset);
  }
  if (format[0].inline || format[0].block_expand) {
    if (!format[0].inline || (startContainer.nodeType !== 3 || startOffset === 0)) {
      startContainer = findParentContainer(dom, format, startContainer, startOffset, endContainer, endOffset, true);
    }
    if (!format[0].inline || (endContainer.nodeType !== 3 || endOffset === endContainer.nodeValue.length)) {
      endContainer = findParentContainer(dom, format, startContainer, startOffset, endContainer, endOffset, false);
    }
  }
  if (format[0].selector &amp;&amp; format[0].expand !== false &amp;&amp; !format[0].inline) {
    startContainer = findSelectorEndPoint(dom, format, rng, startContainer, &#39;previousSibling&#39;);
    endContainer = findSelectorEndPoint(dom, format, rng, endContainer, &#39;nextSibling&#39;);
  }
  if (format[0].block || format[0].selector) {
    startContainer = findBlockEndPoint(editor, format, startContainer, &#39;previousSibling&#39;);
    endContainer = findBlockEndPoint(editor, format, endContainer, &#39;nextSibling&#39;);
    if (format[0].block) {
      if (!dom.isBlock(startContainer)) {
        startContainer = findParentContainer(dom, format, startContainer, startOffset, endContainer, endOffset, true);
      }
      if (!dom.isBlock(endContainer)) {
        endContainer = findParentContainer(dom, format, startContainer, startOffset, endContainer, endOffset, false);
      }
    }
  }
  if (startContainer.nodeType === 1) {
    startOffset = dom.nodeIndex(startContainer);
    startContainer = startContainer.parentNode;
  }
  if (endContainer.nodeType === 1) {
    endOffset = dom.nodeIndex(endContainer) + 1;
    endContainer = endContainer.parentNode;
  }
  return {
    startContainer: startContainer,
    startOffset: startOffset,
    endContainer: endContainer,
    endOffset: endOffset
  };
};
var ExpandRange = { expandRng: expandRng };

var each$8 = Tools.each;
var getEndChild = function (container, index) {
  var childNodes = container.childNodes;
  index--;
  if (index &gt; childNodes.length - 1) {
    index = childNodes.length - 1;
  } else if (index &lt; 0) {
    index = 0;
  }
  return childNodes[index] || container;
};
var walk$1 = function (dom, rng, callback) {
  var startContainer = rng.startContainer;
  var startOffset = rng.startOffset;
  var endContainer = rng.endContainer;
  var endOffset = rng.endOffset;
  var ancestor;
  var startPoint;
  var endPoint;
  var node;
  var parent;
  var siblings;
  var nodes;
  nodes = dom.select(&#39;td[data-mce-selected],th[data-mce-selected]&#39;);
  if (nodes.length &gt; 0) {
    each$8(nodes, function (node) {
      callback([node]);
    });
    return;
  }
  var exclude = function (nodes) {
    var node;
    node = nodes[0];
    if (node.nodeType === 3 &amp;&amp; node === startContainer &amp;&amp; startOffset &gt;= node.nodeValue.length) {
      nodes.splice(0, 1);
    }
    node = nodes[nodes.length - 1];
    if (endOffset === 0 &amp;&amp; nodes.length &gt; 0 &amp;&amp; node === endContainer &amp;&amp; node.nodeType === 3) {
      nodes.splice(nodes.length - 1, 1);
    }
    return nodes;
  };
  var collectSiblings = function (node, name, endNode) {
    var siblings = [];
    for (; node &amp;&amp; node !== endNode; node = node[name]) {
      siblings.push(node);
    }
    return siblings;
  };
  var findEndPoint = function (node, root) {
    do {
      if (node.parentNode === root) {
        return node;
      }
      node = node.parentNode;
    } while (node);
  };
  var walkBoundary = function (startNode, endNode, next) {
    var siblingName = next ? &#39;nextSibling&#39; : &#39;previousSibling&#39;;
    for (node = startNode, parent = node.parentNode; node &amp;&amp; node !== endNode; node = parent) {
      parent = node.parentNode;
      siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
      if (siblings.length) {
        if (!next) {
          siblings.reverse();
        }
        callback(exclude(siblings));
      }
    }
  };
  if (startContainer.nodeType === 1 &amp;&amp; startContainer.hasChildNodes()) {
    startContainer = startContainer.childNodes[startOffset];
  }
  if (endContainer.nodeType === 1 &amp;&amp; endContainer.hasChildNodes()) {
    endContainer = getEndChild(endContainer, endOffset);
  }
  if (startContainer === endContainer) {
    return callback(exclude([startContainer]));
  }
  ancestor = dom.findCommonAncestor(startContainer, endContainer);
  for (node = startContainer; node; node = node.parentNode) {
    if (node === endContainer) {
      return walkBoundary(startContainer, ancestor, true);
    }
    if (node === ancestor) {
      break;
    }
  }
  for (node = endContainer; node; node = node.parentNode) {
    if (node === startContainer) {
      return walkBoundary(endContainer, ancestor);
    }
    if (node === ancestor) {
      break;
    }
  }
  startPoint = findEndPoint(startContainer, ancestor) || startContainer;
  endPoint = findEndPoint(endContainer, ancestor) || endContainer;
  walkBoundary(startContainer, startPoint, true);
  siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, &#39;nextSibling&#39;, endPoint === endContainer ? endPoint.nextSibling : endPoint);
  if (siblings.length) {
    callback(exclude(siblings));
  }
  walkBoundary(endContainer, endPoint);
};
var RangeWalk = { walk: walk$1 };

var zeroWidth = function () {
  return &#39;\uFEFF&#39;;
};

function NodeValue (is, name) {
  var get = function (element) {
    if (!is(element))
      throw new Error(&#39;Can only get &#39; + name + &#39; value of a &#39; + name + &#39; node&#39;);
    return getOption(element).getOr(&#39;&#39;);
  };
  var getOptionIE10 = function (element) {
    try {
      return getOptionSafe(element);
    } catch (e) {
      return Option.none();
    }
  };
  var getOptionSafe = function (element) {
    return is(element) ? Option.from(element.dom().nodeValue) : Option.none();
  };
  var browser = PlatformDetection$1.detect().browser;
  var getOption = browser.isIE() &amp;&amp; browser.version.major === 10 ? getOptionIE10 : getOptionSafe;
  var set = function (element, value) {
    if (!is(element))
      throw new Error(&#39;Can only set raw &#39; + name + &#39; value of a &#39; + name + &#39; node&#39;);
    element.dom().nodeValue = value;
  };
  return {
    get: get,
    getOption: getOption,
    set: set
  };
}

var api = NodeValue(isText, &#39;text&#39;);
var get$6 = function (element) {
  return api.get(element);
};

var isZeroWidth = function (elem) {
  return isText(elem) &amp;&amp; get$6(elem) === zeroWidth();
};
var context = function (editor, elem, wrapName, nodeName) {
  return parent(elem).fold(function () {
    return &#39;skipping&#39;;
  }, function (parent$$1) {
    if (nodeName === &#39;br&#39; || isZeroWidth(elem)) {
      return &#39;valid&#39;;
    } else if (isAnnotation(elem)) {
      return &#39;existing&#39;;
    } else if (isCaretNode(elem)) {
      return &#39;caret&#39;;
    } else if (!FormatUtils.isValid(editor, wrapName, nodeName) || !FormatUtils.isValid(editor, name(parent$$1), wrapName)) {
      return &#39;invalid-child&#39;;
    } else {
      return &#39;valid&#39;;
    }
  });
};

var shouldApplyToTrailingSpaces = function (rng) {
  return rng.startContainer.nodeType === 3 &amp;&amp; rng.startContainer.nodeValue.length &gt;= rng.startOffset &amp;&amp; rng.startContainer.nodeValue[rng.startOffset] === &#39;\xA0&#39;;
};
var applyWordGrab = function (editor, rng) {
  var r = ExpandRange.expandRng(editor, rng, [{ inline: true }], shouldApplyToTrailingSpaces(rng));
  rng.setStart(r.startContainer, r.startOffset);
  rng.setEnd(r.endContainer, r.endOffset);
  editor.selection.setRng(rng);
};
var makeAnnotation = function (eDoc, _a, annotationName, decorate) {
  var _b = _a.uid, uid = _b === void 0 ? generate(&#39;mce-annotation&#39;) : _b, data = __rest(_a, [&#39;uid&#39;]);
  var master = Element$$1.fromTag(&#39;span&#39;, eDoc);
  add$2(master, annotation());
  set(master, &#39;&#39; + dataAnnotationId(), uid);
  set(master, &#39;&#39; + dataAnnotation(), annotationName);
  var _c = decorate(uid, data), _d = _c.attributes, attributes = _d === void 0 ? {} : _d, _e = _c.classes, classes = _e === void 0 ? [] : _e;
  setAll(master, attributes);
  add$3(master, classes);
  return master;
};
var annotate = function (editor, rng, annotationName, decorate, data) {
  var newWrappers = [];
  var master = makeAnnotation(editor.getDoc(), data, annotationName, decorate);
  var wrapper = Cell(Option.none());
  var finishWrapper = function () {
    wrapper.set(Option.none());
  };
  var getOrOpenWrapper = function () {
    return wrapper.get().getOrThunk(function () {
      var nu = shallow(master);
      newWrappers.push(nu);
      wrapper.set(Option.some(nu));
      return nu;
    });
  };
  var processElements = function (elems) {
    each(elems, processElement);
  };
  var processElement = function (elem) {
    var ctx = context(editor, elem, &#39;span&#39;, name(elem));
    switch (ctx) {
    case &#39;invalid-child&#39;: {
        finishWrapper();
        var children$$1 = children(elem);
        processElements(children$$1);
        finishWrapper();
        break;
      }
    case &#39;valid&#39;: {
        var w = getOrOpenWrapper();
        wrap$1(elem, w);
        break;
      }
    case &#39;skipping&#39;:
    case &#39;existing&#39;:
    case &#39;caret&#39;:
    }
  };
  var processNodes = function (nodes) {
    var elems = map(nodes, Element$$1.fromDom);
    processElements(elems);
  };
  RangeWalk.walk(editor.dom, rng, function (nodes) {
    finishWrapper();
    processNodes(nodes);
  });
  return newWrappers;
};
var annotateWithBookmark = function (editor, name$$1, settings, data) {
  editor.undoManager.transact(function () {
    var initialRng = editor.selection.getRng();
    if (initialRng.collapsed) {
      applyWordGrab(editor, initialRng);
    }
    if (editor.selection.getRng().collapsed) {
      var wrapper = makeAnnotation(editor.getDoc(), data, name$$1, settings.decorate);
      set$2(wrapper, &#39;\xA0&#39;);
      editor.selection.getRng().insertNode(wrapper.dom());
      editor.selection.select(wrapper.dom());
    } else {
      var bookmark = GetBookmark.getPersistentBookmark(editor.selection, false);
      var rng = editor.selection.getRng();
      annotate(editor, rng, name$$1, settings.decorate, data);
      editor.selection.moveToBookmark(bookmark);
    }
  });
};

function Annotator (editor) {
  var registry = create$1();
  setup$1(editor, registry);
  var changes = setup(editor, registry);
  return {
    register: function (name, settings) {
      registry.register(name, settings);
    },
    annotate: function (name, data) {
      registry.lookup(name).each(function (settings) {
        annotateWithBookmark(editor, name, settings, data);
      });
    },
    annotationChanged: function (name, callback) {
      changes.addListener(name, callback);
    },
    remove: function (name) {
      identify(editor, Option.some(name)).each(function (_a) {
        var elements = _a.elements;
        each(elements, unwrap);
      });
    },
    getAll: function (name) {
      var directory = findAll(editor, name);
      return map$2(directory, function (elems) {
        return map(elems, function (elem) {
          return elem.dom();
        });
      });
    }
  };
}

var hasOnlyOneChild = function (node) {
  return node.firstChild &amp;&amp; node.firstChild === node.lastChild;
};
var isPaddingNode = function (node) {
  return node.name === &#39;br&#39; || node.value === &#39;\xA0&#39;;
};
var isPaddedEmptyBlock = function (schema, node) {
  var blockElements = schema.getBlockElements();
  return blockElements[node.name] &amp;&amp; hasOnlyOneChild(node) &amp;&amp; isPaddingNode(node.firstChild);
};
var isEmptyFragmentElement = function (schema, node) {
  var nonEmptyElements = schema.getNonEmptyElements();
  return node &amp;&amp; (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
};
var isListFragment = function (schema, fragment) {
  var firstChild = fragment.firstChild;
  var lastChild = fragment.lastChild;
  if (firstChild &amp;&amp; firstChild.name === &#39;meta&#39;) {
    firstChild = firstChild.next;
  }
  if (lastChild &amp;&amp; lastChild.attr(&#39;id&#39;) === &#39;mce_marker&#39;) {
    lastChild = lastChild.prev;
  }
  if (isEmptyFragmentElement(schema, lastChild)) {
    lastChild = lastChild.prev;
  }
  if (!firstChild || firstChild !== lastChild) {
    return false;
  }
  return firstChild.name === &#39;ul&#39; || firstChild.name === &#39;ol&#39;;
};
var cleanupDomFragment = function (domFragment) {
  var firstChild = domFragment.firstChild;
  var lastChild = domFragment.lastChild;
  if (firstChild &amp;&amp; firstChild.nodeName === &#39;META&#39;) {
    firstChild.parentNode.removeChild(firstChild);
  }
  if (lastChild &amp;&amp; lastChild.id === &#39;mce_marker&#39;) {
    lastChild.parentNode.removeChild(lastChild);
  }
  return domFragment;
};
var toDomFragment = function (dom, serializer, fragment) {
  var html = serializer.serialize(fragment);
  var domFragment = dom.createFragment(html);
  return cleanupDomFragment(domFragment);
};
var listItems$1 = function (elm) {
  return Tools.grep(elm.childNodes, function (child) {
    return child.nodeName === &#39;LI&#39;;
  });
};
var isPadding = function (node) {
  return node.data === &#39;\xA0&#39; || NodeType.isBr(node);
};
var isListItemPadded = function (node) {
  return node &amp;&amp; node.firstChild &amp;&amp; node.firstChild === node.lastChild &amp;&amp; isPadding(node.firstChild);
};
var isEmptyOrPadded = function (elm) {
  return !elm.firstChild || isListItemPadded(elm);
};
var trimListItems = function (elms) {
  return elms.length &gt; 0 &amp;&amp; isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
};
var getParentLi = function (dom, node) {
  var parentBlock = dom.getParent(node, dom.isBlock);
  return parentBlock &amp;&amp; parentBlock.nodeName === &#39;LI&#39; ? parentBlock : null;
};
var isParentBlockLi = function (dom, node) {
  return !!getParentLi(dom, node);
};
var getSplit = function (parentNode, rng) {
  var beforeRng = rng.cloneRange();
  var afterRng = rng.cloneRange();
  beforeRng.setStartBefore(parentNode);
  afterRng.setEndAfter(parentNode);
  return [
    beforeRng.cloneContents(),
    afterRng.cloneContents()
  ];
};
var findFirstIn = function (node, rootNode) {
  var caretPos = CaretPosition$1.before(node);
  var caretWalker = CaretWalker(rootNode);
  var newCaretPos = caretWalker.next(caretPos);
  return newCaretPos ? newCaretPos.toRange() : null;
};
var findLastOf = function (node, rootNode) {
  var caretPos = CaretPosition$1.after(node);
  var caretWalker = CaretWalker(rootNode);
  var newCaretPos = caretWalker.prev(caretPos);
  return newCaretPos ? newCaretPos.toRange() : null;
};
var insertMiddle = function (target, elms, rootNode, rng) {
  var parts = getSplit(target, rng);
  var parentElm = target.parentNode;
  parentElm.insertBefore(parts[0], target);
  Tools.each(elms, function (li) {
    parentElm.insertBefore(li, target);
  });
  parentElm.insertBefore(parts[1], target);
  parentElm.removeChild(target);
  return findLastOf(elms[elms.length - 1], rootNode);
};
var insertBefore = function (target, elms, rootNode) {
  var parentElm = target.parentNode;
  Tools.each(elms, function (elm) {
    parentElm.insertBefore(elm, target);
  });
  return findFirstIn(target, rootNode);
};
var insertAfter = function (target, elms, rootNode, dom) {
  dom.insertAfter(elms.reverse(), target);
  return findLastOf(elms[0], rootNode);
};
var insertAtCaret = function (serializer, dom, rng, fragment) {
  var domFragment = toDomFragment(dom, serializer, fragment);
  var liTarget = getParentLi(dom, rng.startContainer);
  var liElms = trimListItems(listItems$1(domFragment.firstChild));
  var BEGINNING = 1, END = 2;
  var rootNode = dom.getRoot();
  var isAt = function (location) {
    var caretPos = CaretPosition$1.fromRangeStart(rng);
    var caretWalker = CaretWalker(dom.getRoot());
    var newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
    return newPos ? getParentLi(dom, newPos.getNode()) !== liTarget : true;
  };
  if (isAt(BEGINNING)) {
    return insertBefore(liTarget, liElms, rootNode);
  } else if (isAt(END)) {
    return insertAfter(liTarget, liElms, rootNode, dom);
  }
  return insertMiddle(liTarget, liElms, rootNode, rng);
};
var InsertList = {
  isListFragment: isListFragment,
  insertAtCaret: insertAtCaret,
  isParentBlockLi: isParentBlockLi,
  trimListItems: trimListItems,
  listItems: listItems$1
};

var each$9 = Tools.each;
var ElementUtils = function (dom) {
  this.compare = function (node1, node2) {
    if (node1.nodeName !== node2.nodeName) {
      return false;
    }
    var getAttribs = function (node) {
      var attribs = {};
      each$9(dom.getAttribs(node), function (attr) {
        var name = attr.nodeName.toLowerCase();
        if (name.indexOf(&#39;_&#39;) !== 0 &amp;&amp; name !== &#39;style&#39; &amp;&amp; name.indexOf(&#39;data-&#39;) !== 0) {
          attribs[name] = dom.getAttrib(node, name);
        }
      });
      return attribs;
    };
    var compareObjects = function (obj1, obj2) {
      var value, name;
      for (name in obj1) {
        if (obj1.hasOwnProperty(name)) {
          value = obj2[name];
          if (typeof value === &#39;undefined&#39;) {
            return false;
          }
          if (obj1[name] !== value) {
            return false;
          }
          delete obj2[name];
        }
      }
      for (name in obj2) {
        if (obj2.hasOwnProperty(name)) {
          return false;
        }
      }
      return true;
    };
    if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
      return false;
    }
    if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, &#39;style&#39;)), dom.parseStyle(dom.getAttrib(node2, &#39;style&#39;)))) {
      return false;
    }
    return !Bookmarks.isBookmarkNode(node1) &amp;&amp; !Bookmarks.isBookmarkNode(node2);
  };
};

var getLastChildren = function (elm) {
  var children$$1 = [];
  var rawNode = elm.dom();
  while (rawNode) {
    children$$1.push(Element$$1.fromDom(rawNode));
    rawNode = rawNode.lastChild;
  }
  return children$$1;
};
var removeTrailingBr = function (elm) {
  var allBrs = descendants$1(elm, &#39;br&#39;);
  var brs = filter(getLastChildren(elm).slice(-1), isBr);
  if (allBrs.length === brs.length) {
    each(brs, remove$2);
  }
};
var fillWithPaddingBr = function (elm) {
  empty(elm);
  append(elm, Element$$1.fromHtml(&#39;&lt;br data-mce-bogus=&quot;1&quot;&gt;&#39;));
};
var isPaddingContents = function (elm) {
  return isText(elm) ? get$6(elm) === &#39;\xA0&#39; : isBr(elm);
};
var isPaddedElement = function (elm) {
  return filter(children(elm), isPaddingContents).length === 1;
};
var trimBlockTrailingBr = function (elm) {
  lastChild(elm).each(function (lastChild$$1) {
    prevSibling(lastChild$$1).each(function (lastChildPrevSibling) {
      if (isBlock(elm) &amp;&amp; isBr(lastChild$$1) &amp;&amp; isBlock(lastChildPrevSibling)) {
        remove$2(lastChild$$1);
      }
    });
  });
};
var PaddingBr = {
  removeTrailingBr: removeTrailingBr,
  fillWithPaddingBr: fillWithPaddingBr,
  isPaddedElement: isPaddedElement,
  trimBlockTrailingBr: trimBlockTrailingBr
};

var makeMap$3 = Tools.makeMap;
function Writer (settings) {
  var html = [];
  var indent, indentBefore, indentAfter, encode, htmlOutput;
  settings = settings || {};
  indent = settings.indent;
  indentBefore = makeMap$3(settings.indent_before || &#39;&#39;);
  indentAfter = makeMap$3(settings.indent_after || &#39;&#39;);
  encode = Entities.getEncodeFunc(settings.entity_encoding || &#39;raw&#39;, settings.entities);
  htmlOutput = settings.element_format === &#39;html&#39;;
  return {
    start: function (name, attrs, empty) {
      var i, l, attr, value;
      if (indent &amp;&amp; indentBefore[name] &amp;&amp; html.length &gt; 0) {
        value = html[html.length - 1];
        if (value.length &gt; 0 &amp;&amp; value !== &#39;\n&#39;) {
          html.push(&#39;\n&#39;);
        }
      }
      html.push(&#39;&lt;&#39;, name);
      if (attrs) {
        for (i = 0, l = attrs.length; i &lt; l; i++) {
          attr = attrs[i];
          html.push(&#39; &#39;, attr.name, &#39;=&quot;&#39;, encode(attr.value, true), &#39;&quot;&#39;);
        }
      }
      if (!empty || htmlOutput) {
        html[html.length] = &#39;&gt;&#39;;
      } else {
        html[html.length] = &#39; /&gt;&#39;;
      }
      if (empty &amp;&amp; indent &amp;&amp; indentAfter[name] &amp;&amp; html.length &gt; 0) {
        value = html[html.length - 1];
        if (value.length &gt; 0 &amp;&amp; value !== &#39;\n&#39;) {
          html.push(&#39;\n&#39;);
        }
      }
    },
    end: function (name) {
      var value;
      html.push(&#39;&lt;/&#39;, name, &#39;&gt;&#39;);
      if (indent &amp;&amp; indentAfter[name] &amp;&amp; html.length &gt; 0) {
        value = html[html.length - 1];
        if (value.length &gt; 0 &amp;&amp; value !== &#39;\n&#39;) {
          html.push(&#39;\n&#39;);
        }
      }
    },
    text: function (text, raw) {
      if (text.length &gt; 0) {
        html[html.length] = raw ? text : encode(text);
      }
    },
    cdata: function (text) {
      html.push(&#39;&lt;![CDATA[&#39;, text, &#39;]]&gt;&#39;);
    },
    comment: function (text) {
      html.push(&#39;&lt;!--&#39;, text, &#39;--&gt;&#39;);
    },
    pi: function (name, text) {
      if (text) {
        html.push(&#39;&lt;?&#39;, name, &#39; &#39;, encode(text), &#39;?&gt;&#39;);
      } else {
        html.push(&#39;&lt;?&#39;, name, &#39;?&gt;&#39;);
      }
      if (indent) {
        html.push(&#39;\n&#39;);
      }
    },
    doctype: function (text) {
      html.push(&#39;&lt;!DOCTYPE&#39;, text, &#39;&gt;&#39;, indent ? &#39;\n&#39; : &#39;&#39;);
    },
    reset: function () {
      html.length = 0;
    },
    getContent: function () {
      return html.join(&#39;&#39;).replace(/\n$/, &#39;&#39;);
    }
  };
}

function Serializer (settings, schema) {
  if (schema === void 0) {
    schema = Schema();
  }
  var writer = Writer(settings);
  settings = settings || {};
  settings.validate = &#39;validate&#39; in settings ? settings.validate : true;
  var serialize = function (node) {
    var handlers, validate;
    validate = settings.validate;
    handlers = {
      3: function (node) {
        writer.text(node.value, node.raw);
      },
      8: function (node) {
        writer.comment(node.value);
      },
      7: function (node) {
        writer.pi(node.name, node.value);
      },
      10: function (node) {
        writer.doctype(node.value);
      },
      4: function (node) {
        writer.cdata(node.value);
      },
      11: function (node) {
        if (node = node.firstChild) {
          do {
            walk(node);
          } while (node = node.next);
        }
      }
    };
    writer.reset();
    var walk = function (node) {
      var handler = handlers[node.type];
      var name, isEmpty, attrs, attrName, attrValue, sortedAttrs, i, l, elementRule;
      if (!handler) {
        name = node.name;
        isEmpty = node.shortEnded;
        attrs = node.attributes;
        if (validate &amp;&amp; attrs &amp;&amp; attrs.length &gt; 1) {
          sortedAttrs = [];
          sortedAttrs.map = {};
          elementRule = schema.getElementRule(node.name);
          if (elementRule) {
            for (i = 0, l = elementRule.attributesOrder.length; i &lt; l; i++) {
              attrName = elementRule.attributesOrder[i];
              if (attrName in attrs.map) {
                attrValue = attrs.map[attrName];
                sortedAttrs.map[attrName] = attrValue;
                sortedAttrs.push({
                  name: attrName,
                  value: attrValue
                });
              }
            }
            for (i = 0, l = attrs.length; i &lt; l; i++) {
              attrName = attrs[i].name;
              if (!(attrName in sortedAttrs.map)) {
                attrValue = attrs.map[attrName];
                sortedAttrs.map[attrName] = attrValue;
                sortedAttrs.push({
                  name: attrName,
                  value: attrValue
                });
              }
            }
            attrs = sortedAttrs;
          }
        }
        writer.start(node.name, attrs, isEmpty);
        if (!isEmpty) {
          if (node = node.firstChild) {
            do {
              walk(node);
            } while (node = node.next);
          }
          writer.end(name);
        }
      } else {
        handler(node);
      }
    };
    if (node.type === 1 &amp;&amp; !settings.inner) {
      walk(node);
    } else {
      handlers[11](node);
    }
    return writer.getContent();
  };
  return { serialize: serialize };
}

var createRange$1 = function (sc, so, ec, eo) {
  var rng = document.createRange();
  rng.setStart(sc, so);
  rng.setEnd(ec, eo);
  return rng;
};
var normalizeBlockSelectionRange = function (rng) {
  var startPos = CaretPosition$1.fromRangeStart(rng);
  var endPos = CaretPosition$1.fromRangeEnd(rng);
  var rootNode = rng.commonAncestorContainer;
  return CaretFinder.fromPosition(false, rootNode, endPos).map(function (newEndPos) {
    if (!isInSameBlock(startPos, endPos, rootNode) &amp;&amp; isInSameBlock(startPos, newEndPos, rootNode)) {
      return createRange$1(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
    } else {
      return rng;
    }
  }).getOr(rng);
};
var normalize = function (rng) {
  return rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
};
var RangeNormalizer = { normalize: normalize };

var isAfterNbsp = function (container, offset) {
  return NodeType.isText(container) &amp;&amp; container.nodeValue[offset - 1] === &#39;\xA0&#39;;
};
var trimOrPadLeftRight = function (rng, html) {
  var container, offset;
  container = rng.startContainer;
  offset = rng.startOffset;
  var hasSiblingText = function (siblingName) {
    return container[siblingName] &amp;&amp; container[siblingName].nodeType === 3;
  };
  if (container.nodeType === 3) {
    if (offset &gt; 0) {
      html = html.replace(/^&amp;nbsp;/, &#39; &#39;);
    } else if (!hasSiblingText(&#39;previousSibling&#39;)) {
      html = html.replace(/^ /, &#39;&amp;nbsp;&#39;);
    }
    if (offset &lt; container.length) {
      html = html.replace(/&amp;nbsp;(&lt;br&gt;|)$/, &#39; &#39;);
    } else if (!hasSiblingText(&#39;nextSibling&#39;)) {
      html = html.replace(/(&amp;nbsp;| )(&lt;br&gt;|)$/, &#39;&amp;nbsp;&#39;);
    }
  }
  return html;
};
var trimNbspAfterDeleteAndPadValue = function (rng, value) {
  var container, offset;
  container = rng.startContainer;
  offset = rng.startOffset;
  if (container.nodeType === 3 &amp;&amp; rng.collapsed) {
    if (container.data[offset] === &#39;\xA0&#39;) {
      container.deleteData(offset, 1);
      if (!/[\u00a0| ]$/.test(value)) {
        value += &#39; &#39;;
      }
    } else if (container.data[offset - 1] === &#39;\xA0&#39;) {
      container.deleteData(offset - 1, 1);
      if (!/[\u00a0| ]$/.test(value)) {
        value = &#39; &#39; + value;
      }
    }
  }
  return value;
};

var isTableCell$2 = NodeType.matchNodeNames(&#39;td th&#39;);
var selectionSetContent = function (editor, content) {
  var rng = editor.selection.getRng();
  var container = rng.startContainer;
  var offset = rng.startOffset;
  if (rng.collapsed &amp;&amp; isAfterNbsp(container, offset) &amp;&amp; NodeType.isText(container)) {
    container.insertData(offset - 1, &#39; &#39;);
    container.deleteData(offset, 1);
    rng.setStart(container, offset);
    rng.setEnd(container, offset);
    editor.selection.setRng(rng);
  }
  editor.selection.setContent(content);
};
var validInsertion = function (editor, value, parentNode) {
  if (parentNode.getAttribute(&#39;data-mce-bogus&#39;) === &#39;all&#39;) {
    parentNode.parentNode.insertBefore(editor.dom.createFragment(value), parentNode);
  } else {
    var node = parentNode.firstChild;
    var node2 = parentNode.lastChild;
    if (!node || node === node2 &amp;&amp; node.nodeName === &#39;BR&#39;) {
      editor.dom.setHTML(parentNode, value);
    } else {
      selectionSetContent(editor, value);
    }
  }
};
var trimBrsFromTableCell = function (dom, elm) {
  Option.from(dom.getParent(elm, &#39;td,th&#39;)).map(Element$$1.fromDom).each(PaddingBr.trimBlockTrailingBr);
};
var reduceInlineTextElements = function (editor, merge) {
  var textInlineElements = editor.schema.getTextInlineElements();
  var dom = editor.dom;
  if (merge) {
    var root_1 = editor.getBody(), elementUtils_1 = new ElementUtils(dom);
    Tools.each(dom.select(&#39;*[data-mce-fragment]&#39;), function (node) {
      for (var testNode = node.parentNode; testNode &amp;&amp; testNode !== root_1; testNode = testNode.parentNode) {
        if (textInlineElements[node.nodeName.toLowerCase()] &amp;&amp; elementUtils_1.compare(testNode, node)) {
          dom.remove(node, true);
        }
      }
    });
  }
};
var markFragmentElements = function (fragment) {
  var node = fragment;
  while (node = node.walk()) {
    if (node.type === 1) {
      node.attr(&#39;data-mce-fragment&#39;, &#39;1&#39;);
    }
  }
};
var umarkFragmentElements = function (elm) {
  Tools.each(elm.getElementsByTagName(&#39;*&#39;), function (elm) {
    elm.removeAttribute(&#39;data-mce-fragment&#39;);
  });
};
var isPartOfFragment = function (node) {
  return !!node.getAttribute(&#39;data-mce-fragment&#39;);
};
var canHaveChildren = function (editor, node) {
  return node &amp;&amp; !editor.schema.getShortEndedElements()[node.nodeName];
};
var moveSelectionToMarker = function (editor, marker) {
  var parentEditableFalseElm, parentBlock, nextRng;
  var dom = editor.dom, selection = editor.selection;
  var node, node2;
  var getContentEditableFalseParent = function (node) {
    var root = editor.getBody();
    for (; node &amp;&amp; node !== root; node = node.parentNode) {
      if (editor.dom.getContentEditable(node) === &#39;false&#39;) {
        return node;
      }
    }
    return null;
  };
  if (!marker) {
    return;
  }
  editor.selection.scrollIntoView(marker);
  parentEditableFalseElm = getContentEditableFalseParent(marker);
  if (parentEditableFalseElm) {
    dom.remove(marker);
    selection.select(parentEditableFalseElm);
    return;
  }
  var rng = dom.createRng();
  node = marker.previousSibling;
  if (node &amp;&amp; node.nodeType === 3) {
    rng.setStart(node, node.nodeValue.length);
    if (!Env.ie) {
      node2 = marker.nextSibling;
      if (node2 &amp;&amp; node2.nodeType === 3) {
        node.appendData(node2.data);
        node2.parentNode.removeChild(node2);
      }
    }
  } else {
    rng.setStartBefore(marker);
    rng.setEndBefore(marker);
  }
  var findNextCaretRng = function (rng) {
    var caretPos = CaretPosition$1.fromRangeStart(rng);
    var caretWalker = CaretWalker(editor.getBody());
    caretPos = caretWalker.next(caretPos);
    if (caretPos) {
      return caretPos.toRange();
    }
  };
  parentBlock = dom.getParent(marker, dom.isBlock);
  dom.remove(marker);
  if (parentBlock &amp;&amp; dom.isEmpty(parentBlock)) {
    editor.$(parentBlock).empty();
    rng.setStart(parentBlock, 0);
    rng.setEnd(parentBlock, 0);
    if (!isTableCell$2(parentBlock) &amp;&amp; !isPartOfFragment(parentBlock) &amp;&amp; (nextRng = findNextCaretRng(rng))) {
      rng = nextRng;
      dom.remove(parentBlock);
    } else {
      dom.add(parentBlock, dom.create(&#39;br&#39;, { &#39;data-mce-bogus&#39;: &#39;1&#39; }));
    }
  }
  selection.setRng(rng);
};
var insertHtmlAtCaret = function (editor, value, details) {
  var parser, serializer, parentNode, rootNode, fragment, args;
  var marker, rng, node, bookmarkHtml, merge;
  var selection = editor.selection, dom = editor.dom;
  if (/^ | $/.test(value)) {
    value = trimOrPadLeftRight(selection.getRng(), value);
  }
  parser = editor.parser;
  merge = details.merge;
  serializer = Serializer({ validate: editor.settings.validate }, editor.schema);
  bookmarkHtml = &#39;&lt;span id=&quot;mce_marker&quot; data-mce-type=&quot;bookmark&quot;&gt;&amp;#xFEFF;&amp;#x200B;&lt;/span&gt;&#39;;
  args = {
    content: value,
    format: &#39;html&#39;,
    selection: true,
    paste: details.paste
  };
  args = editor.fire(&#39;BeforeSetContent&#39;, args);
  if (args.isDefaultPrevented()) {
    editor.fire(&#39;SetContent&#39;, {
      content: args.content,
      format: &#39;html&#39;,
      selection: true,
      paste: details.paste
    });
    return;
  }
  value = args.content;
  if (value.indexOf(&#39;{$caret}&#39;) === -1) {
    value += &#39;{$caret}&#39;;
  }
  value = value.replace(/\{\$caret\}/, bookmarkHtml);
  rng = selection.getRng();
  var caretElement = rng.startContainer || (rng.parentElement ? rng.parentElement() : null);
  var body = editor.getBody();
  if (caretElement === body &amp;&amp; selection.isCollapsed()) {
    if (dom.isBlock(body.firstChild) &amp;&amp; canHaveChildren(editor, body.firstChild) &amp;&amp; dom.isEmpty(body.firstChild)) {
      rng = dom.createRng();
      rng.setStart(body.firstChild, 0);
      rng.setEnd(body.firstChild, 0);
      selection.setRng(rng);
    }
  }
  if (!selection.isCollapsed()) {
    editor.selection.setRng(RangeNormalizer.normalize(editor.selection.getRng()));
    editor.getDoc().execCommand(&#39;Delete&#39;, false, null);
    value = trimNbspAfterDeleteAndPadValue(editor.selection.getRng(), value);
  }
  parentNode = selection.getNode();
  var parserArgs = {
    context: parentNode.nodeName.toLowerCase(),
    data: details.data,
    insert: true
  };
  fragment = parser.parse(value, parserArgs);
  if (details.paste === true &amp;&amp; InsertList.isListFragment(editor.schema, fragment) &amp;&amp; InsertList.isParentBlockLi(dom, parentNode)) {
    rng = InsertList.insertAtCaret(serializer, dom, editor.selection.getRng(), fragment);
    editor.selection.setRng(rng);
    editor.fire(&#39;SetContent&#39;, args);
    return;
  }
  markFragmentElements(fragment);
  node = fragment.lastChild;
  if (node.attr(&#39;id&#39;) === &#39;mce_marker&#39;) {
    marker = node;
    for (node = node.prev; node; node = node.walk(true)) {
      if (node.type === 3 || !dom.isBlock(node.name)) {
        if (editor.schema.isValidChild(node.parent.name, &#39;span&#39;)) {
          node.parent.insert(marker, node, node.name === &#39;br&#39;);
        }
        break;
      }
    }
  }
  editor._selectionOverrides.showBlockCaretContainer(parentNode);
  if (!parserArgs.invalid) {
    value = serializer.serialize(fragment);
    validInsertion(editor, value, parentNode);
  } else {
    selectionSetContent(editor, bookmarkHtml);
    parentNode = selection.getNode();
    rootNode = editor.getBody();
    if (parentNode.nodeType === 9) {
      parentNode = node = rootNode;
    } else {
      node = parentNode;
    }
    while (node !== rootNode) {
      parentNode = node;
      node = node.parentNode;
    }
    value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);
    value = serializer.serialize(parser.parse(value.replace(/&lt;span (id=&quot;mce_marker&quot;|id=mce_marker).+?&lt;\/span&gt;/i, function () {
      return serializer.serialize(fragment);
    })));
    if (parentNode === rootNode) {
      dom.setHTML(rootNode, value);
    } else {
      dom.setOuterHTML(parentNode, value);
    }
  }
  reduceInlineTextElements(editor, merge);
  moveSelectionToMarker(editor, dom.get(&#39;mce_marker&#39;));
  umarkFragmentElements(editor.getBody());
  trimBrsFromTableCell(editor.dom, editor.selection.getStart());
  editor.fire(&#39;SetContent&#39;, args);
  editor.addVisual();
};
var processValue = function (value) {
  var details;
  if (typeof value !== &#39;string&#39;) {
    details = Tools.extend({
      paste: value.paste,
      data: { paste: value.paste }
    }, value);
    return {
      content: value.content,
      details: details
    };
  }
  return {
    content: value,
    details: {}
  };
};
var insertAtCaret$1 = function (editor, value) {
  var result = processValue(value);
  insertHtmlAtCaret(editor, result.content, result.details);
};
var InsertContent = { insertAtCaret: insertAtCaret$1 };

var sectionResult = Immutable(&#39;sections&#39;, &#39;settings&#39;);
var detection = PlatformDetection$1.detect();
var isTouch = detection.deviceType.isTouch();
var mobilePlugins = [
  &#39;lists&#39;,
  &#39;autolink&#39;,
  &#39;autosave&#39;
];
var defaultMobileSettings = { theme: &#39;mobile&#39; };
var normalizePlugins = function (plugins) {
  var pluginNames = isArray(plugins) ? plugins.join(&#39; &#39;) : plugins;
  var trimmedPlugins = map(isString(pluginNames) ? pluginNames.split(&#39; &#39;) : [], trim$2);
  return filter(trimmedPlugins, function (item) {
    return item.length &gt; 0;
  });
};
var filterMobilePlugins = function (plugins) {
  return filter(plugins, curry(contains, mobilePlugins));
};
var extractSections = function (keys$$1, settings) {
  var result = bifilter(settings, function (value, key) {
    return contains(keys$$1, key);
  });
  return sectionResult(result.t, result.f);
};
var getSection = function (sectionResult, name, defaults) {
  var sections = sectionResult.sections();
  var sectionSettings = sections.hasOwnProperty(name) ? sections[name] : {};
  return Tools.extend({}, defaults, sectionSettings);
};
var hasSection = function (sectionResult, name) {
  return sectionResult.sections().hasOwnProperty(name);
};
var getDefaultSettings = function (id, documentBaseUrl, editor) {
  return {
    id: id,
    theme: &#39;modern&#39;,
    delta_width: 0,
    delta_height: 0,
    popup_css: &#39;&#39;,
    plugins: &#39;&#39;,
    document_base_url: documentBaseUrl,
    add_form_submit_trigger: true,
    submit_patch: true,
    add_unload_trigger: true,
    convert_urls: true,
    relative_urls: true,
    remove_script_host: true,
    object_resizing: true,
    doctype: &#39;&lt;!DOCTYPE html&gt;&#39;,
    visual: true,
    font_size_style_values: &#39;xx-small,x-small,small,medium,large,x-large,xx-large&#39;,
    font_size_legacy_values: &#39;xx-small,small,medium,large,x-large,xx-large,300%&#39;,
    forced_root_block: &#39;p&#39;,
    hidden_input: true,
    render_ui: true,
    indentation: &#39;40px&#39;,
    inline_styles: true,
    convert_fonts_to_spans: true,
    indent: &#39;simple&#39;,
    indent_before: &#39;p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,&#39; + &#39;tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist&#39;,
    indent_after: &#39;p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,&#39; + &#39;tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist&#39;,
    entity_encoding: &#39;named&#39;,
    url_converter: editor.convertURL,
    url_converter_scope: editor,
    ie7_compat: true
  };
};
var getExternalPlugins = function (overrideSettings, settings) {
  var userDefinedExternalPlugins = settings.external_plugins ? settings.external_plugins : {};
  if (overrideSettings &amp;&amp; overrideSettings.external_plugins) {
    return Tools.extend({}, overrideSettings.external_plugins, userDefinedExternalPlugins);
  } else {
    return userDefinedExternalPlugins;
  }
};
var combinePlugins = function (forcedPlugins, plugins) {
  return [].concat(normalizePlugins(forcedPlugins)).concat(normalizePlugins(plugins));
};
var processPlugins = function (isTouchDevice, sectionResult, defaultOverrideSettings, settings) {
  var forcedPlugins = normalizePlugins(defaultOverrideSettings.forced_plugins);
  var plugins = normalizePlugins(settings.plugins);
  var platformPlugins = isTouchDevice &amp;&amp; hasSection(sectionResult, &#39;mobile&#39;) ? filterMobilePlugins(plugins) : plugins;
  var combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
  return Tools.extend(settings, { plugins: combinedPlugins.join(&#39; &#39;) });
};
var isOnMobile = function (isTouchDevice, sectionResult) {
  var isInline = sectionResult.settings().inline;
  return isTouchDevice &amp;&amp; hasSection(sectionResult, &#39;mobile&#39;) &amp;&amp; !isInline;
};
var combineSettings = function (isTouchDevice, defaultSettings, defaultOverrideSettings, settings) {
  var sectionResult = extractSections([&#39;mobile&#39;], settings);
  var extendedSettings = Tools.extend(defaultSettings, defaultOverrideSettings, sectionResult.settings(), isOnMobile(isTouchDevice, sectionResult) ? getSection(sectionResult, &#39;mobile&#39;, defaultMobileSettings) : {}, {
    validate: true,
    content_editable: sectionResult.settings().inline,
    external_plugins: getExternalPlugins(defaultOverrideSettings, sectionResult.settings())
  });
  return processPlugins(isTouchDevice, sectionResult, defaultOverrideSettings, extendedSettings);
};
var getEditorSettings = function (editor, id, documentBaseUrl, defaultOverrideSettings, settings) {
  var defaultSettings = getDefaultSettings(id, documentBaseUrl, editor);
  return combineSettings(isTouch, defaultSettings, defaultOverrideSettings, settings);
};
var getFiltered = function (predicate, editor, name) {
  return Option.from(editor.settings[name]).filter(predicate);
};
var getString = curry(getFiltered, isString);
var getParamObject = function (value) {
  var output = {};
  if (typeof value === &#39;string&#39;) {
    each(value.indexOf(&#39;=&#39;) &gt; 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(&#39;,&#39;), function (val) {
      var arr = val.split(&#39;=&#39;);
      if (arr.length &gt; 1) {
        output[Tools.trim(arr[0])] = Tools.trim(arr[1]);
      } else {
        output[Tools.trim(arr[0])] = Tools.trim(arr);
      }
    });
  } else {
    output = value;
  }
  return output;
};
var isArrayOf = function (p) {
  return function (a) {
    return isArray(a) &amp;&amp; forall(a, p);
  };
};
var getParam = function (editor, name, defaultVal, type) {
  var value = name in editor.settings ? editor.settings[name] : defaultVal;
  if (type === &#39;hash&#39;) {
    return getParamObject(value);
  } else if (type === &#39;string&#39;) {
    return getFiltered(isString, editor, name).getOr(defaultVal);
  } else if (type === &#39;number&#39;) {
    return getFiltered(isNumber, editor, name).getOr(defaultVal);
  } else if (type === &#39;boolean&#39;) {
    return getFiltered(isBoolean, editor, name).getOr(defaultVal);
  } else if (type === &#39;object&#39;) {
    return getFiltered(isObject, editor, name).getOr(defaultVal);
  } else if (type === &#39;array&#39;) {
    return getFiltered(isArray, editor, name).getOr(defaultVal);
  } else if (type === &#39;string[]&#39;) {
    return getFiltered(isArrayOf(isString), editor, name).getOr(defaultVal);
  } else if (type === &#39;function&#39;) {
    return getFiltered(isFunction, editor, name).getOr(defaultVal);
  } else {
    return value;
  }
};

var strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
var hasStrongRtl = function (text) {
  return strongRtl.test(text);
};

var isInlineTarget = function (editor, elm) {
  var selector = getString(editor, &#39;inline_boundaries_selector&#39;).getOr(&#39;a[href],code&#39;);
  return is$1(Element$$1.fromDom(elm), selector);
};
var isRtl = function (element) {
  return DOMUtils$1.DOM.getStyle(element, &#39;direction&#39;, true) === &#39;rtl&#39; || hasStrongRtl(element.textContent);
};
var findInlineParents = function (isInlineTarget, rootNode, pos) {
  return filter(DOMUtils$1.DOM.getParents(pos.container(), &#39;*&#39;, rootNode), isInlineTarget);
};
var findRootInline = function (isInlineTarget, rootNode, pos) {
  var parents = findInlineParents(isInlineTarget, rootNode, pos);
  return Option.from(parents[parents.length - 1]);
};
var hasSameParentBlock = function (rootNode, node1, node2) {
  var block1 = getParentBlock(node1, rootNode);
  var block2 = getParentBlock(node2, rootNode);
  return block1 &amp;&amp; block1 === block2;
};
var isAtZwsp = function (pos) {
  return isBeforeInline(pos) || isAfterInline(pos);
};
var normalizePosition = function (forward, pos) {
  var container = pos.container(), offset = pos.offset();
  if (forward) {
    if (isCaretContainerInline(container)) {
      if (NodeType.isText(container.nextSibling)) {
        return CaretPosition$1(container.nextSibling, 0);
      } else {
        return CaretPosition$1.after(container);
      }
    } else {
      return isBeforeInline(pos) ? CaretPosition$1(container, offset + 1) : pos;
    }
  } else {
    if (isCaretContainerInline(container)) {
      if (NodeType.isText(container.previousSibling)) {
        return CaretPosition$1(container.previousSibling, container.previousSibling.data.length);
      } else {
        return CaretPosition$1.before(container);
      }
    } else {
      return isAfterInline(pos) ? CaretPosition$1(container, offset - 1) : pos;
    }
  }
};
var normalizeForwards = curry(normalizePosition, true);
var normalizeBackwards = curry(normalizePosition, false);
var InlineUtils = {
  isInlineTarget: isInlineTarget,
  findRootInline: findRootInline,
  isRtl: isRtl,
  isAtZwsp: isAtZwsp,
  normalizePosition: normalizePosition,
  normalizeForwards: normalizeForwards,
  normalizeBackwards: normalizeBackwards,
  hasSameParentBlock: hasSameParentBlock
};

var isBeforeRoot = function (rootNode) {
  return function (elm) {
    return eq(rootNode, Element$$1.fromDom(elm.dom().parentNode));
  };
};
var getParentBlock$1 = function (rootNode, elm) {
  return contains$3(rootNode, elm) ? closest(elm, function (element) {
    return isTextBlock(element) || isListItem(element);
  }, isBeforeRoot(rootNode)) : Option.none();
};
var placeCaretInEmptyBody = function (editor) {
  var body = editor.getBody();
  var node = body.firstChild &amp;&amp; editor.dom.isBlock(body.firstChild) ? body.firstChild : body;
  editor.selection.setCursorLocation(node, 0);
};
var paddEmptyBody = function (editor) {
  if (editor.dom.isEmpty(editor.getBody())) {
    editor.setContent(&#39;&#39;);
    placeCaretInEmptyBody(editor);
  }
};
var willDeleteLastPositionInElement = function (forward, fromPos, elm) {
  return liftN([
    CaretFinder.firstPositionIn(elm),
    CaretFinder.lastPositionIn(elm)
  ], function (firstPos, lastPos) {
    var normalizedFirstPos = InlineUtils.normalizePosition(true, firstPos);
    var normalizedLastPos = InlineUtils.normalizePosition(false, lastPos);
    var normalizedFromPos = InlineUtils.normalizePosition(false, fromPos);
    if (forward) {
      return CaretFinder.nextPosition(elm, normalizedFromPos).map(function (nextPos) {
        return nextPos.isEqual(normalizedLastPos) &amp;&amp; fromPos.isEqual(normalizedFirstPos);
      }).getOr(false);
    } else {
      return CaretFinder.prevPosition(elm, normalizedFromPos).map(function (prevPos) {
        return prevPos.isEqual(normalizedFirstPos) &amp;&amp; fromPos.isEqual(normalizedLastPos);
      }).getOr(false);
    }
  }).getOr(true);
};
var DeleteUtils = {
  getParentBlock: getParentBlock$1,
  paddEmptyBody: paddEmptyBody,
  willDeleteLastPositionInElement: willDeleteLastPositionInElement
};

var ancestor$2 = function (scope, selector, isRoot) {
  return ancestor$1(scope, selector, isRoot).isSome();
};

var hasWhitespacePreserveParent = function (rootNode, node) {
  var rootElement = Element$$1.fromDom(rootNode);
  var startNode = Element$$1.fromDom(node);
  return ancestor$2(startNode, &#39;pre,code&#39;, curry(eq, rootElement));
};
var isWhitespace = function (rootNode, node) {
  return NodeType.isText(node) &amp;&amp; /^[ \t\r\n]*$/.test(node.data) &amp;&amp; hasWhitespacePreserveParent(rootNode, node) === false;
};
var isNamedAnchor = function (node) {
  return NodeType.isElement(node) &amp;&amp; node.nodeName === &#39;A&#39; &amp;&amp; node.hasAttribute(&#39;name&#39;);
};
var isContent$1 = function (rootNode, node) {
  return isCaretCandidate(node) &amp;&amp; isWhitespace(rootNode, node) === false || isNamedAnchor(node) || isBookmark(node);
};
var isBookmark = NodeType.hasAttribute(&#39;data-mce-bookmark&#39;);
var isBogus$2 = NodeType.hasAttribute(&#39;data-mce-bogus&#39;);
var isBogusAll$1 = NodeType.hasAttributeValue(&#39;data-mce-bogus&#39;, &#39;all&#39;);
var isEmptyNode = function (targetNode) {
  var walker, node, brCount = 0;
  if (isContent$1(targetNode, targetNode)) {
    return false;
  } else {
    node = targetNode.firstChild;
    if (!node) {
      return true;
    }
    walker = new TreeWalker(node, targetNode);
    do {
      if (isBogusAll$1(node)) {
        node = walker.next(true);
        continue;
      }
      if (isBogus$2(node)) {
        node = walker.next();
        continue;
      }
      if (NodeType.isBr(node)) {
        brCount++;
        node = walker.next();
        continue;
      }
      if (isContent$1(targetNode, node)) {
        return false;
      }
      node = walker.next();
    } while (node);
    return brCount &lt;= 1;
  }
};
var isEmpty$1 = function (elm) {
  return isEmptyNode(elm.dom());
};
var Empty = { isEmpty: isEmpty$1 };

var BlockPosition = Immutable(&#39;block&#39;, &#39;position&#39;);
var BlockBoundary = Immutable(&#39;from&#39;, &#39;to&#39;);
var getBlockPosition = function (rootNode, pos) {
  var rootElm = Element$$1.fromDom(rootNode);
  var containerElm = Element$$1.fromDom(pos.container());
  return DeleteUtils.getParentBlock(rootElm, containerElm).map(function (block) {
    return BlockPosition(block, pos);
  });
};
var isDifferentBlocks = function (blockBoundary) {
  return eq(blockBoundary.from().block(), blockBoundary.to().block()) === false;
};
var hasSameParent = function (blockBoundary) {
  return parent(blockBoundary.from().block()).bind(function (parent1) {
    return parent(blockBoundary.to().block()).filter(function (parent2) {
      return eq(parent1, parent2);
    });
  }).isSome();
};
var isEditable = function (blockBoundary) {
  return NodeType.isContentEditableFalse(blockBoundary.from().block()) === false &amp;&amp; NodeType.isContentEditableFalse(blockBoundary.to().block()) === false;
};
var skipLastBr = function (rootNode, forward, blockPosition) {
  if (NodeType.isBr(blockPosition.position().getNode()) &amp;&amp; Empty.isEmpty(blockPosition.block()) === false) {
    return CaretFinder.positionIn(false, blockPosition.block().dom()).bind(function (lastPositionInBlock) {
      if (lastPositionInBlock.isEqual(blockPosition.position())) {
        return CaretFinder.fromPosition(forward, rootNode, lastPositionInBlock).bind(function (to) {
          return getBlockPosition(rootNode, to);
        });
      } else {
        return Option.some(blockPosition);
      }
    }).getOr(blockPosition);
  } else {
    return blockPosition;
  }
};
var readFromRange = function (rootNode, forward, rng) {
  var fromBlockPos = getBlockPosition(rootNode, CaretPosition$1.fromRangeStart(rng));
  var toBlockPos = fromBlockPos.bind(function (blockPos) {
    return CaretFinder.fromPosition(forward, rootNode, blockPos.position()).bind(function (to) {
      return getBlockPosition(rootNode, to).map(function (blockPos) {
        return skipLastBr(rootNode, forward, blockPos);
      });
    });
  });
  return liftN([
    fromBlockPos,
    toBlockPos
  ], BlockBoundary).filter(function (blockBoundary) {
    return isDifferentBlocks(blockBoundary) &amp;&amp; hasSameParent(blockBoundary) &amp;&amp; isEditable(blockBoundary);
  });
};
var read$1 = function (rootNode, forward, rng) {
  return rng.collapsed ? readFromRange(rootNode, forward, rng) : Option.none();
};
var BlockMergeBoundary = { read: read$1 };

var dropLast = function (xs) {
  return xs.slice(0, -1);
};
var parentsUntil$1 = function (start, root, predicate) {
  if (contains$3(root, start)) {
    return dropLast(parents(start, function (elm) {
      return predicate(elm) || eq(elm, root);
    }));
  } else {
    return [];
  }
};
var parents$1 = function (start, root) {
  return parentsUntil$1(start, root, constant(false));
};
var parentsAndSelf = function (start, root) {
  return [start].concat(parents$1(start, root));
};
var Parents = {
  parentsUntil: parentsUntil$1,
  parents: parents$1,
  parentsAndSelf: parentsAndSelf
};

var getChildrenUntilBlockBoundary = function (block) {
  var children$$1 = children(block);
  return findIndex(children$$1, isBlock).fold(function () {
    return children$$1;
  }, function (index) {
    return children$$1.slice(0, index);
  });
};
var extractChildren = function (block) {
  var children$$1 = getChildrenUntilBlockBoundary(block);
  each(children$$1, remove$2);
  return children$$1;
};
var removeEmptyRoot = function (rootNode, block) {
  var parents$$1 = Parents.parentsAndSelf(block, rootNode);
  return find(parents$$1.reverse(), Empty.isEmpty).each(remove$2);
};
var isEmptyBefore = function (el) {
  return filter(prevSiblings(el), function (el) {
    return !Empty.isEmpty(el);
  }).length === 0;
};
var nestedBlockMerge = function (rootNode, fromBlock, toBlock, insertionPoint) {
  if (Empty.isEmpty(toBlock)) {
    PaddingBr.fillWithPaddingBr(toBlock);
    return CaretFinder.firstPositionIn(toBlock.dom());
  }
  if (isEmptyBefore(insertionPoint) &amp;&amp; Empty.isEmpty(fromBlock)) {
    before(insertionPoint, Element$$1.fromTag(&#39;br&#39;));
  }
  var position = CaretFinder.prevPosition(toBlock.dom(), CaretPosition$1.before(insertionPoint.dom()));
  each(extractChildren(fromBlock), function (child$$1) {
    before(insertionPoint, child$$1);
  });
  removeEmptyRoot(rootNode, fromBlock);
  return position;
};
var sidelongBlockMerge = function (rootNode, fromBlock, toBlock) {
  if (Empty.isEmpty(toBlock)) {
    remove$2(toBlock);
    if (Empty.isEmpty(fromBlock)) {
      PaddingBr.fillWithPaddingBr(fromBlock);
    }
    return CaretFinder.firstPositionIn(fromBlock.dom());
  }
  var position = CaretFinder.lastPositionIn(toBlock.dom());
  each(extractChildren(fromBlock), function (child$$1) {
    append(toBlock, child$$1);
  });
  removeEmptyRoot(rootNode, fromBlock);
  return position;
};
var findInsertionPoint = function (toBlock, block) {
  var parentsAndSelf = Parents.parentsAndSelf(block, toBlock);
  return Option.from(parentsAndSelf[parentsAndSelf.length - 1]);
};
var getInsertionPoint = function (fromBlock, toBlock) {
  return contains$3(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Option.none();
};
var trimBr = function (first, block) {
  CaretFinder.positionIn(first, block.dom()).map(function (position) {
    return position.getNode();
  }).map(Element$$1.fromDom).filter(isBr).each(remove$2);
};
var mergeBlockInto = function (rootNode, fromBlock, toBlock) {
  trimBr(true, fromBlock);
  trimBr(false, toBlock);
  return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
};
var mergeBlocks = function (rootNode, forward, block1, block2) {
  return forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
};
var MergeBlocks = { mergeBlocks: mergeBlocks };

var backspaceDelete = function (editor, forward) {
  var position;
  var rootNode = Element$$1.fromDom(editor.getBody());
  position = BlockMergeBoundary.read(rootNode.dom(), forward, editor.selection.getRng()).bind(function (blockBoundary) {
    return MergeBlocks.mergeBlocks(rootNode, forward, blockBoundary.from().block(), blockBoundary.to().block());
  });
  position.each(function (pos) {
    editor.selection.setRng(pos.toRange());
  });
  return position.isSome();
};
var BlockBoundaryDelete = { backspaceDelete: backspaceDelete };

var deleteRangeMergeBlocks = function (rootNode, selection) {
  var rng = selection.getRng();
  return liftN([
    DeleteUtils.getParentBlock(rootNode, Element$$1.fromDom(rng.startContainer)),
    DeleteUtils.getParentBlock(rootNode, Element$$1.fromDom(rng.endContainer))
  ], function (block1, block2) {
    if (eq(block1, block2) === false) {
      rng.deleteContents();
      MergeBlocks.mergeBlocks(rootNode, true, block1, block2).each(function (pos) {
        selection.setRng(pos.toRange());
      });
      return true;
    } else {
      return false;
    }
  }).getOr(false);
};
var isRawNodeInTable = function (root, rawNode) {
  var node = Element$$1.fromDom(rawNode);
  var isRoot = curry(eq, root);
  return ancestor(node, isTableCell, isRoot).isSome();
};
var isSelectionInTable = function (root, rng) {
  return isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
};
var isEverythingSelected = function (root, rng) {
  var noPrevious = CaretFinder.prevPosition(root.dom(), CaretPosition$1.fromRangeStart(rng)).isNone();
  var noNext = CaretFinder.nextPosition(root.dom(), CaretPosition$1.fromRangeEnd(rng)).isNone();
  return !isSelectionInTable(root, rng) &amp;&amp; noPrevious &amp;&amp; noNext;
};
var emptyEditor = function (editor) {
  editor.setContent(&#39;&#39;);
  editor.selection.setCursorLocation();
  return true;
};
var deleteRange = function (editor) {
  var rootNode = Element$$1.fromDom(editor.getBody());
  var rng = editor.selection.getRng();
  return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
};
var backspaceDelete$1 = function (editor, forward) {
  return editor.selection.isCollapsed() ? false : deleteRange(editor);
};
var BlockRangeDelete = { backspaceDelete: backspaceDelete$1 };

var generate$1 = function (cases) {
  if (!isArray(cases)) {
    throw new Error(&#39;cases must be an array&#39;);
  }
  if (cases.length === 0) {
    throw new Error(&#39;there must be at least one case&#39;);
  }
  var constructors = [];
  var adt = {};
  each(cases, function (acase, count) {
    var keys$$1 = keys(acase);
    if (keys$$1.length !== 1) {
      throw new Error(&#39;one and only one name per case&#39;);
    }
    var key = keys$$1[0];
    var value = acase[key];
    if (adt[key] !== undefined) {
      throw new Error(&#39;duplicate key detected:&#39; + key);
    } else if (key === &#39;cata&#39;) {
      throw new Error(&#39;cannot have a case named cata (sorry)&#39;);
    } else if (!isArray(value)) {
      throw new Error(&#39;case arguments must be an array&#39;);
    }
    constructors.push(key);
    adt[key] = function () {
      var argLength = arguments.length;
      if (argLength !== value.length) {
        throw new Error(&#39;Wrong number of arguments to case &#39; + key + &#39;. Expected &#39; + value.length + &#39; (&#39; + value + &#39;), got &#39; + argLength);
      }
      var args = new Array(argLength);
      for (var i = 0; i &lt; args.length; i++)
        args[i] = arguments[i];
      var match = function (branches) {
        var branchKeys = keys(branches);
        if (constructors.length !== branchKeys.length) {
          throw new Error(&#39;Wrong number of arguments to match. Expected: &#39; + constructors.join(&#39;,&#39;) + &#39;\nActual: &#39; + branchKeys.join(&#39;,&#39;));
        }
        var allReqd = forall(constructors, function (reqKey) {
          return contains(branchKeys, reqKey);
        });
        if (!allReqd)
          throw new Error(&#39;Not all branches were specified when using match. Specified: &#39; + branchKeys.join(&#39;, &#39;) + &#39;\nRequired: &#39; + constructors.join(&#39;, &#39;));
        return branches[key].apply(null, args);
      };
      return {
        fold: function () {
          if (arguments.length !== cases.length) {
            throw new Error(&#39;Wrong number of arguments to fold. Expected &#39; + cases.length + &#39;, got &#39; + arguments.length);
          }
          var target = arguments[count];
          return target.apply(null, args);
        },
        match: match,
        log: function (label) {
          console.log(label, {
            constructors: constructors,
            constructor: key,
            params: args
          });
        }
      };
    };
  });
  return adt;
};
var Adt = { generate: generate$1 };

var isBr$5 = function (pos) {
  return getElementFromPosition(pos).exists(isBr);
};
var findBr = function (forward, root, pos) {
  var parentBlocks = filter(Parents.parentsAndSelf(Element$$1.fromDom(pos.container()), root), isBlock);
  var scope = head(parentBlocks).getOr(root);
  return CaretFinder.fromPosition(forward, scope.dom(), pos).filter(isBr$5);
};
var isBeforeBr = function (root, pos) {
  return getElementFromPosition(pos).exists(isBr) || findBr(true, root, pos).isSome();
};
var isAfterBr = function (root, pos) {
  return getElementFromPrevPosition(pos).exists(isBr) || findBr(false, root, pos).isSome();
};
var findPreviousBr = curry(findBr, false);
var findNextBr = curry(findBr, true);

var isCompoundElement = function (node) {
  return isTableCell(Element$$1.fromDom(node)) || isListItem(Element$$1.fromDom(node));
};
var DeleteAction = Adt.generate([
  { remove: [&#39;element&#39;] },
  { moveToElement: [&#39;element&#39;] },
  { moveToPosition: [&#39;position&#39;] }
]);
var isAtContentEditableBlockCaret = function (forward, from) {
  var elm = from.getNode(forward === false);
  var caretLocation = forward ? &#39;after&#39; : &#39;before&#39;;
  return NodeType.isElement(elm) &amp;&amp; elm.getAttribute(&#39;data-mce-caret&#39;) === caretLocation;
};
var isDeleteFromCefDifferentBlocks = function (root, forward, from, to) {
  var inSameBlock = function (elm) {
    return isInline(Element$$1.fromDom(elm)) &amp;&amp; !isInSameBlock(from, to, root);
  };
  return getRelativeCefElm(!forward, from).fold(function () {
    return getRelativeCefElm(forward, to).fold(constant(false), inSameBlock);
  }, inSameBlock);
};
var deleteEmptyBlockOrMoveToCef = function (root, forward, from, to) {
  var toCefElm = to.getNode(forward === false);
  return DeleteUtils.getParentBlock(Element$$1.fromDom(root), Element$$1.fromDom(from.getNode())).map(function (blockElm) {
    return Empty.isEmpty(blockElm) ? DeleteAction.remove(blockElm.dom()) : DeleteAction.moveToElement(toCefElm);
  }).orThunk(function () {
    return Option.some(DeleteAction.moveToElement(toCefElm));
  });
};
var findCefPosition = function (root, forward, from) {
  return CaretFinder.fromPosition(forward, root, from).bind(function (to) {
    if (isCompoundElement(to.getNode())) {
      return Option.none();
    } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to)) {
      return Option.none();
    } else if (forward &amp;&amp; NodeType.isContentEditableFalse(to.getNode())) {
      return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
    } else if (forward === false &amp;&amp; NodeType.isContentEditableFalse(to.getNode(true))) {
      return deleteEmptyBlockOrMoveToCef(root, forward, from, to);
    } else if (forward &amp;&amp; isAfterContentEditableFalse(from)) {
      return Option.some(DeleteAction.moveToPosition(to));
    } else if (forward === false &amp;&amp; isBeforeContentEditableFalse(from)) {
      return Option.some(DeleteAction.moveToPosition(to));
    } else {
      return Option.none();
    }
  });
};
var getContentEditableBlockAction = function (forward, elm) {
  if (forward &amp;&amp; NodeType.isContentEditableFalse(elm.nextSibling)) {
    return Option.some(DeleteAction.moveToElement(elm.nextSibling));
  } else if (forward === false &amp;&amp; NodeType.isContentEditableFalse(elm.previousSibling)) {
    return Option.some(DeleteAction.moveToElement(elm.previousSibling));
  } else {
    return Option.none();
  }
};
var skipMoveToActionFromInlineCefToContent = function (root, from, deleteAction) {
  return deleteAction.fold(function (elm) {
    return Option.some(DeleteAction.remove(elm));
  }, function (elm) {
    return Option.some(DeleteAction.moveToElement(elm));
  }, function (to) {
    if (isInSameBlock(from, to, root)) {
      return Option.none();
    } else {
      return Option.some(DeleteAction.moveToPosition(to));
    }
  });
};
var getContentEditableAction = function (root, forward, from) {
  if (isAtContentEditableBlockCaret(forward, from)) {
    return getContentEditableBlockAction(forward, from.getNode(forward === false)).fold(function () {
      return findCefPosition(root, forward, from);
    }, Option.some);
  } else {
    return findCefPosition(root, forward, from).bind(function (deleteAction) {
      return skipMoveToActionFromInlineCefToContent(root, from, deleteAction);
    });
  }
};
var read$2 = function (root, forward, rng) {
  var normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
  var from = CaretPosition$1.fromRangeStart(normalizedRange);
  var rootElement = Element$$1.fromDom(root);
  if (forward === false &amp;&amp; isAfterContentEditableFalse(from)) {
    return Option.some(DeleteAction.remove(from.getNode(true)));
  } else if (forward &amp;&amp; isBeforeContentEditableFalse(from)) {
    return Option.some(DeleteAction.remove(from.getNode()));
  } else if (forward === false &amp;&amp; isBeforeContentEditableFalse(from) &amp;&amp; isAfterBr(rootElement, from)) {
    return findPreviousBr(rootElement, from).map(function (br) {
      return DeleteAction.remove(br.getNode());
    });
  } else if (forward &amp;&amp; isAfterContentEditableFalse(from) &amp;&amp; isBeforeBr(rootElement, from)) {
    return findNextBr(rootElement, from).map(function (br) {
      return DeleteAction.remove(br.getNode());
    });
  } else {
    return getContentEditableAction(root, forward, from);
  }
};

var isCollapsibleWhitespace = function (c) {
  return &#39; \f\n\r\t\x0B&#39;.indexOf(c) !== -1;
};
var normalizeContent = function (content, isStartOfContent, isEndOfContent) {
  var result = foldl(content.split(&#39;&#39;), function (acc, c) {
    if (isCollapsibleWhitespace(c) || c === &#39;\xA0&#39;) {
      if (acc.previousCharIsSpace || acc.str === &#39;&#39; &amp;&amp; isStartOfContent || acc.str.length === content.length - 1 &amp;&amp; isEndOfContent) {
        return {
          previousCharIsSpace: false,
          str: acc.str + &#39;\xA0&#39;
        };
      } else {
        return {
          previousCharIsSpace: true,
          str: acc.str + &#39; &#39;
        };
      }
    } else {
      return {
        previousCharIsSpace: false,
        str: acc.str + c
      };
    }
  }, {
    previousCharIsSpace: false,
    str: &#39;&#39;
  });
  return result.str;
};
var normalize$1 = function (node, offset, count) {
  if (count === 0) {
    return;
  }
  var whitespace = node.data.slice(offset, offset + count);
  var isEndOfContent = offset + count &gt;= node.data.length;
  var isStartOfContent = offset === 0;
  node.replaceData(offset, count, normalizeContent(whitespace, isStartOfContent, isEndOfContent));
};
var normalizeWhitespaceAfter = function (node, offset) {
  var content = node.data.slice(offset);
  var whitespaceCount = content.length - lTrim(content).length;
  return normalize$1(node, offset, whitespaceCount);
};
var normalizeWhitespaceBefore = function (node, offset) {
  var content = node.data.slice(0, offset);
  var whitespaceCount = content.length - rTrim(content).length;
  return normalize$1(node, offset - whitespaceCount, whitespaceCount);
};
var mergeTextNodes = function (prevNode, nextNode, normalizeWhitespace) {
  var whitespaceOffset = rTrim(prevNode.data).length;
  prevNode.appendData(nextNode.data);
  remove$2(Element$$1.fromDom(nextNode));
  if (normalizeWhitespace) {
    normalizeWhitespaceAfter(prevNode, whitespaceOffset);
  }
  return prevNode;
};

var needsReposition = function (pos, elm) {
  var container = pos.container();
  var offset = pos.offset();
  return CaretPosition$1.isTextPosition(pos) === false &amp;&amp; container === elm.parentNode &amp;&amp; offset &gt; CaretPosition$1.before(elm).offset();
};
var reposition = function (elm, pos) {
  return needsReposition(pos, elm) ? CaretPosition$1(pos.container(), pos.offset() - 1) : pos;
};
var beforeOrStartOf = function (node) {
  return NodeType.isText(node) ? CaretPosition$1(node, 0) : CaretPosition$1.before(node);
};
var afterOrEndOf = function (node) {
  return NodeType.isText(node) ? CaretPosition$1(node, node.data.length) : CaretPosition$1.after(node);
};
var getPreviousSiblingCaretPosition = function (elm) {
  if (isCaretCandidate(elm.previousSibling)) {
    return Option.some(afterOrEndOf(elm.previousSibling));
  } else {
    return elm.previousSibling ? CaretFinder.lastPositionIn(elm.previousSibling) : Option.none();
  }
};
var getNextSiblingCaretPosition = function (elm) {
  if (isCaretCandidate(elm.nextSibling)) {
    return Option.some(beforeOrStartOf(elm.nextSibling));
  } else {
    return elm.nextSibling ? CaretFinder.firstPositionIn(elm.nextSibling) : Option.none();
  }
};
var findCaretPositionBackwardsFromElm = function (rootElement, elm) {
  var startPosition = CaretPosition$1.before(elm.previousSibling ? elm.previousSibling : elm.parentNode);
  return CaretFinder.prevPosition(rootElement, startPosition).fold(function () {
    return CaretFinder.nextPosition(rootElement, CaretPosition$1.after(elm));
  }, Option.some);
};
var findCaretPositionForwardsFromElm = function (rootElement, elm) {
  return CaretFinder.nextPosition(rootElement, CaretPosition$1.after(elm)).fold(function () {
    return CaretFinder.prevPosition(rootElement, CaretPosition$1.before(elm));
  }, Option.some);
};
var findCaretPositionBackwards = function (rootElement, elm) {
  return getPreviousSiblingCaretPosition(elm).orThunk(function () {
    return getNextSiblingCaretPosition(elm);
  }).orThunk(function () {
    return findCaretPositionBackwardsFromElm(rootElement, elm);
  });
};
var findCaretPositionForward = function (rootElement, elm) {
  return getNextSiblingCaretPosition(elm).orThunk(function () {
    return getPreviousSiblingCaretPosition(elm);
  }).orThunk(function () {
    return findCaretPositionForwardsFromElm(rootElement, elm);
  });
};
var findCaretPosition$1 = function (forward, rootElement, elm) {
  return forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
};
var findCaretPosOutsideElmAfterDelete = function (forward, rootElement, elm) {
  return findCaretPosition$1(forward, rootElement, elm).map(curry(reposition, elm));
};
var setSelection = function (editor, forward, pos) {
  pos.fold(function () {
    editor.focus();
  }, function (pos) {
    editor.selection.setRng(pos.toRange(), forward);
  });
};
var eqRawNode = function (rawNode) {
  return function (elm) {
    return elm.dom() === rawNode;
  };
};
var isBlock$2 = function (editor, elm) {
  return elm &amp;&amp; editor.schema.getBlockElements().hasOwnProperty(name(elm));
};
var paddEmptyBlock = function (elm) {
  if (Empty.isEmpty(elm)) {
    var br = Element$$1.fromHtml(&#39;&lt;br data-mce-bogus=&quot;1&quot;&gt;&#39;);
    empty(elm);
    append(elm, br);
    return Option.some(CaretPosition$1.before(br.dom()));
  } else {
    return Option.none();
  }
};
var deleteNormalized = function (elm, afterDeletePosOpt, normalizeWhitespace) {
  var prevTextOpt = prevSibling(elm).filter(function (e) {
    return NodeType.isText(e.dom());
  });
  var nextTextOpt = nextSibling(elm).filter(function (e) {
    return NodeType.isText(e.dom());
  });
  remove$2(elm);
  return liftN([
    prevTextOpt,
    nextTextOpt,
    afterDeletePosOpt
  ], function (prev, next, pos) {
    var prevNode = prev.dom(), nextNode = next.dom();
    var offset = prevNode.data.length;
    mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
    return pos.container() === nextNode ? CaretPosition$1(prevNode, offset) : pos;
  }).orThunk(function () {
    if (normalizeWhitespace) {
      prevTextOpt.each(function (elm) {
        return normalizeWhitespaceBefore(elm.dom(), elm.dom().length);
      });
      nextTextOpt.each(function (elm) {
        return normalizeWhitespaceAfter(elm.dom(), 0);
      });
    }
    return afterDeletePosOpt;
  });
};
var isInlineElement = function (editor, element) {
  return has(editor.schema.getTextInlineElements(), name(element));
};
var deleteElement = function (editor, forward, elm, moveCaret) {
  if (moveCaret === void 0) {
    moveCaret = true;
  }
  var afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom());
  var parentBlock = ancestor(elm, curry(isBlock$2, editor), eqRawNode(editor.getBody()));
  var normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
  if (editor.dom.isEmpty(editor.getBody())) {
    editor.setContent(&#39;&#39;);
    editor.selection.setCursorLocation();
  } else {
    parentBlock.bind(paddEmptyBlock).fold(function () {
      if (moveCaret) {
        setSelection(editor, forward, normalizedAfterDeletePos);
      }
    }, function (paddPos) {
      if (moveCaret) {
        setSelection(editor, forward, Option.some(paddPos));
      }
    });
  }
};
var DeleteElement = { deleteElement: deleteElement };

var deleteElement$1 = function (editor, forward) {
  return function (element) {
    editor._selectionOverrides.hideFakeCaret();
    DeleteElement.deleteElement(editor, forward, Element$$1.fromDom(element));
    return true;
  };
};
var moveToElement = function (editor, forward) {
  return function (element) {
    var pos = forward ? CaretPosition$1.before(element) : CaretPosition$1.after(element);
    editor.selection.setRng(pos.toRange());
    return true;
  };
};
var moveToPosition = function (editor) {
  return function (pos) {
    editor.selection.setRng(pos.toRange());
    return true;
  };
};
var backspaceDeleteCaret = function (editor, forward) {
  var result = read$2(editor.getBody(), forward, editor.selection.getRng()).map(function (deleteAction) {
    return deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor));
  });
  return result.getOr(false);
};
var deleteOffscreenSelection = function (rootElement) {
  each(descendants$1(rootElement, &#39;.mce-offscreen-selection&#39;), remove$2);
};
var backspaceDeleteRange = function (editor, forward) {
  var selectedElement = editor.selection.getNode();
  if (NodeType.isContentEditableFalse(selectedElement)) {
    deleteOffscreenSelection(Element$$1.fromDom(editor.getBody()));
    DeleteElement.deleteElement(editor, forward, Element$$1.fromDom(editor.selection.getNode()));
    DeleteUtils.paddEmptyBody(editor);
    return true;
  } else {
    return false;
  }
};
var getContentEditableRoot = function (root, node) {
  while (node &amp;&amp; node !== root) {
    if (NodeType.isContentEditableTrue(node) || NodeType.isContentEditableFalse(node)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
};
var paddEmptyElement = function (editor) {
  var br;
  var ceRoot = getContentEditableRoot(editor.getBody(), editor.selection.getNode());
  if (NodeType.isContentEditableTrue(ceRoot) &amp;&amp; editor.dom.isBlock(ceRoot) &amp;&amp; editor.dom.isEmpty(ceRoot)) {
    br = editor.dom.create(&#39;br&#39;, { &#39;data-mce-bogus&#39;: &#39;1&#39; });
    editor.dom.setHTML(ceRoot, &#39;&#39;);
    ceRoot.appendChild(br);
    editor.selection.setRng(CaretPosition$1.before(br).toRange());
  }
  return true;
};
var backspaceDelete$2 = function (editor, forward) {
  if (editor.selection.isCollapsed()) {
    return backspaceDeleteCaret(editor, forward);
  } else {
    return backspaceDeleteRange(editor, forward);
  }
};
var CefDelete = {
  backspaceDelete: backspaceDelete$2,
  paddEmptyElement: paddEmptyElement
};

var isText$8 = NodeType.isText;
var startsWithCaretContainer$1 = function (node) {
  return isText$8(node) &amp;&amp; node.data[0] === Zwsp.ZWSP;
};
var endsWithCaretContainer$1 = function (node) {
  return isText$8(node) &amp;&amp; node.data[node.data.length - 1] === Zwsp.ZWSP;
};
var createZwsp = function (node) {
  return node.ownerDocument.createTextNode(Zwsp.ZWSP);
};
var insertBefore$1 = function (node) {
  if (isText$8(node.previousSibling)) {
    if (endsWithCaretContainer$1(node.previousSibling)) {
      return node.previousSibling;
    } else {
      node.previousSibling.appendData(Zwsp.ZWSP);
      return node.previousSibling;
    }
  } else if (isText$8(node)) {
    if (startsWithCaretContainer$1(node)) {
      return node;
    } else {
      node.insertData(0, Zwsp.ZWSP);
      return node;
    }
  } else {
    var newNode = createZwsp(node);
    node.parentNode.insertBefore(newNode, node);
    return newNode;
  }
};
var insertAfter$1 = function (node) {
  if (isText$8(node.nextSibling)) {
    if (startsWithCaretContainer$1(node.nextSibling)) {
      return node.nextSibling;
    } else {
      node.nextSibling.insertData(0, Zwsp.ZWSP);
      return node.nextSibling;
    }
  } else if (isText$8(node)) {
    if (endsWithCaretContainer$1(node)) {
      return node;
    } else {
      node.appendData(Zwsp.ZWSP);
      return node;
    }
  } else {
    var newNode = createZwsp(node);
    if (node.nextSibling) {
      node.parentNode.insertBefore(newNode, node.nextSibling);
    } else {
      node.parentNode.appendChild(newNode);
    }
    return newNode;
  }
};
var insertInline$1 = function (before, node) {
  return before ? insertBefore$1(node) : insertAfter$1(node);
};
var insertInlineBefore = curry(insertInline$1, true);
var insertInlineAfter = curry(insertInline$1, false);

var insertInlinePos = function (pos, before) {
  if (NodeType.isText(pos.container())) {
    return insertInline$1(before, pos.container());
  } else {
    return insertInline$1(before, pos.getNode());
  }
};
var isPosCaretContainer = function (pos, caret) {
  var caretNode = caret.get();
  return caretNode &amp;&amp; pos.container() === caretNode &amp;&amp; isCaretContainerInline(caretNode);
};
var renderCaret = function (caret, location) {
  return location.fold(function (element) {
    CaretContainerRemove.remove(caret.get());
    var text = insertInlineBefore(element);
    caret.set(text);
    return Option.some(CaretPosition$1(text, text.length - 1));
  }, function (element) {
    return CaretFinder.firstPositionIn(element).map(function (pos) {
      if (!isPosCaretContainer(pos, caret)) {
        CaretContainerRemove.remove(caret.get());
        var text = insertInlinePos(pos, true);
        caret.set(text);
        return CaretPosition$1(text, 1);
      } else {
        return CaretPosition$1(caret.get(), 1);
      }
    });
  }, function (element) {
    return CaretFinder.lastPositionIn(element).map(function (pos) {
      if (!isPosCaretContainer(pos, caret)) {
        CaretContainerRemove.remove(caret.get());
        var text = insertInlinePos(pos, false);
        caret.set(text);
        return CaretPosition$1(text, text.length - 1);
      } else {
        return CaretPosition$1(caret.get(), caret.get().length - 1);
      }
    });
  }, function (element) {
    CaretContainerRemove.remove(caret.get());
    var text = insertInlineAfter(element);
    caret.set(text);
    return Option.some(CaretPosition$1(text, 1));
  });
};
var BoundaryCaret = { renderCaret: renderCaret };

var evaluateUntil = function (fns, args) {
  for (var i = 0; i &lt; fns.length; i++) {
    var result = fns[i].apply(null, args);
    if (result.isSome()) {
      return result;
    }
  }
  return Option.none();
};
var LazyEvaluator = { evaluateUntil: evaluateUntil };

var Location = Adt.generate([
  { before: [&#39;element&#39;] },
  { start: [&#39;element&#39;] },
  { end: [&#39;element&#39;] },
  { after: [&#39;element&#39;] }
]);
var rescope = function (rootNode, node) {
  var parentBlock = getParentBlock(node, rootNode);
  return parentBlock ? parentBlock : rootNode;
};
var before$3 = function (isInlineTarget, rootNode, pos) {
  var nPos = InlineUtils.normalizeForwards(pos);
  var scope = rescope(rootNode, nPos.container());
  return InlineUtils.findRootInline(isInlineTarget, scope, nPos).fold(function () {
    return CaretFinder.nextPosition(scope, nPos).bind(curry(InlineUtils.findRootInline, isInlineTarget, scope)).map(function (inline) {
      return Location.before(inline);
    });
  }, Option.none);
};
var isNotInsideFormatCaretContainer = function (rootNode, elm) {
  return getParentCaretContainer(rootNode, elm) === null;
};
var findInsideRootInline = function (isInlineTarget, rootNode, pos) {
  return InlineUtils.findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
};
var start = function (isInlineTarget, rootNode, pos) {
  var nPos = InlineUtils.normalizeBackwards(pos);
  return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(function (inline) {
    var prevPos = CaretFinder.prevPosition(inline, nPos);
    return prevPos.isNone() ? Option.some(Location.start(inline)) : Option.none();
  });
};
var end = function (isInlineTarget, rootNode, pos) {
  var nPos = InlineUtils.normalizeForwards(pos);
  return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(function (inline) {
    var nextPos = CaretFinder.nextPosition(inline, nPos);
    return nextPos.isNone() ? Option.some(Location.end(inline)) : Option.none();
  });
};
var after$3 = function (isInlineTarget, rootNode, pos) {
  var nPos = InlineUtils.normalizeBackwards(pos);
  var scope = rescope(rootNode, nPos.container());
  return InlineUtils.findRootInline(isInlineTarget, scope, nPos).fold(function () {
    return CaretFinder.prevPosition(scope, nPos).bind(curry(InlineUtils.findRootInline, isInlineTarget, scope)).map(function (inline) {
      return Location.after(inline);
    });
  }, Option.none);
};
var isValidLocation = function (location) {
  return InlineUtils.isRtl(getElement(location)) === false;
};
var readLocation = function (isInlineTarget, rootNode, pos) {
  var location = LazyEvaluator.evaluateUntil([
    before$3,
    start,
    end,
    after$3
  ], [
    isInlineTarget,
    rootNode,
    pos
  ]);
  return location.filter(isValidLocation);
};
var getElement = function (location) {
  return location.fold(identity, identity, identity, identity);
};
var getName = function (location) {
  return location.fold(constant(&#39;before&#39;), constant(&#39;start&#39;), constant(&#39;end&#39;), constant(&#39;after&#39;));
};
var outside = function (location) {
  return location.fold(Location.before, Location.before, Location.after, Location.after);
};
var inside = function (location) {
  return location.fold(Location.start, Location.start, Location.end, Location.end);
};
var isEq$1 = function (location1, location2) {
  return getName(location1) === getName(location2) &amp;&amp; getElement(location1) === getElement(location2);
};
var betweenInlines = function (forward, isInlineTarget, rootNode, from, to, location) {
  return liftN([
    InlineUtils.findRootInline(isInlineTarget, rootNode, from),
    InlineUtils.findRootInline(isInlineTarget, rootNode, to)
  ], function (fromInline, toInline) {
    if (fromInline !== toInline &amp;&amp; InlineUtils.hasSameParentBlock(rootNode, fromInline, toInline)) {
      return Location.after(forward ? fromInline : toInline);
    } else {
      return location;
    }
  }).getOr(location);
};
var skipNoMovement = function (fromLocation, toLocation) {
  return fromLocation.fold(constant(true), function (fromLocation) {
    return !isEq$1(fromLocation, toLocation);
  });
};
var findLocationTraverse = function (forward, isInlineTarget, rootNode, fromLocation, pos) {
  var from = InlineUtils.normalizePosition(forward, pos);
  var to = CaretFinder.fromPosition(forward, rootNode, from).map(curry(InlineUtils.normalizePosition, forward));
  var location = to.fold(function () {
    return fromLocation.map(outside);
  }, function (to) {
    return readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation));
  });
  return location.filter(isValidLocation);
};
var findLocationSimple = function (forward, location) {
  if (forward) {
    return location.fold(compose(Option.some, Location.start), Option.none, compose(Option.some, Location.after), Option.none);
  } else {
    return location.fold(Option.none, compose(Option.some, Location.before), Option.none, compose(Option.some, Location.end));
  }
};
var findLocation = function (forward, isInlineTarget, rootNode, pos) {
  var from = InlineUtils.normalizePosition(forward, pos);
  var fromLocation = readLocation(isInlineTarget, rootNode, from);
  return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(function () {
    return findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos);
  });
};
var BoundaryLocation = {
  readLocation: readLocation,
  findLocation: findLocation,
  prevLocation: curry(findLocation, false),
  nextLocation: curry(findLocation, true),
  getElement: getElement,
  outside: outside,
  inside: inside
};

var hasSelectionModifyApi = function (editor) {
  return isFunction(editor.selection.getSel().modify);
};
var moveRel = function (forward, selection, pos) {
  var delta = forward ? 1 : -1;
  selection.setRng(CaretPosition$1(pos.container(), pos.offset() + delta).toRange());
  selection.getSel().modify(&#39;move&#39;, forward ? &#39;forward&#39; : &#39;backward&#39;, &#39;word&#39;);
  return true;
};
var moveByWord = function (forward, editor) {
  var rng = editor.selection.getRng();
  var pos = forward ? CaretPosition$1.fromRangeEnd(rng) : CaretPosition$1.fromRangeStart(rng);
  if (!hasSelectionModifyApi(editor)) {
    return false;
  } else if (forward &amp;&amp; isBeforeInline(pos)) {
    return moveRel(true, editor.selection, pos);
  } else if (!forward &amp;&amp; isAfterInline(pos)) {
    return moveRel(false, editor.selection, pos);
  } else {
    return false;
  }
};
var WordSelection = {
  hasSelectionModifyApi: hasSelectionModifyApi,
  moveByWord: moveByWord
};

var setCaretPosition = function (editor, pos) {
  var rng = editor.dom.createRng();
  rng.setStart(pos.container(), pos.offset());
  rng.setEnd(pos.container(), pos.offset());
  editor.selection.setRng(rng);
};
var isFeatureEnabled = function (editor) {
  return editor.settings.inline_boundaries !== false;
};
var setSelected = function (state, elm) {
  if (state) {
    elm.setAttribute(&#39;data-mce-selected&#39;, &#39;inline-boundary&#39;);
  } else {
    elm.removeAttribute(&#39;data-mce-selected&#39;);
  }
};
var renderCaretLocation = function (editor, caret, location) {
  return BoundaryCaret.renderCaret(caret, location).map(function (pos) {
    setCaretPosition(editor, pos);
    return location;
  });
};
var findLocation$1 = function (editor, caret, forward) {
  var rootNode = editor.getBody();
  var from = CaretPosition$1.fromRangeStart(editor.selection.getRng());
  var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
  var location = BoundaryLocation.findLocation(forward, isInlineTarget, rootNode, from);
  return location.bind(function (location) {
    return renderCaretLocation(editor, caret, location);
  });
};
var toggleInlines = function (isInlineTarget, dom, elms) {
  var selectedInlines = filter(dom.select(&#39;*[data-mce-selected=&quot;inline-boundary&quot;]&#39;), isInlineTarget);
  var targetInlines = filter(elms, isInlineTarget);
  each(difference(selectedInlines, targetInlines), curry(setSelected, false));
  each(difference(targetInlines, selectedInlines), curry(setSelected, true));
};
var safeRemoveCaretContainer = function (editor, caret) {
  if (editor.selection.isCollapsed() &amp;&amp; editor.composing !== true &amp;&amp; caret.get()) {
    var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
    if (CaretPosition$1.isTextPosition(pos) &amp;&amp; InlineUtils.isAtZwsp(pos) === false) {
      setCaretPosition(editor, CaretContainerRemove.removeAndReposition(caret.get(), pos));
      caret.set(null);
    }
  }
};
var renderInsideInlineCaret = function (isInlineTarget, editor, caret, elms) {
  if (editor.selection.isCollapsed()) {
    var inlines = filter(elms, isInlineTarget);
    each(inlines, function (inline) {
      var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
      BoundaryLocation.readLocation(isInlineTarget, editor.getBody(), pos).bind(function (location) {
        return renderCaretLocation(editor, caret, location);
      });
    });
  }
};
var move = function (editor, caret, forward) {
  return function () {
    return isFeatureEnabled(editor) ? findLocation$1(editor, caret, forward).isSome() : false;
  };
};
var moveWord = function (forward, editor, caret) {
  return function () {
    return isFeatureEnabled(editor) ? WordSelection.moveByWord(forward, editor) : false;
  };
};
var setupSelectedState = function (editor) {
  var caret = Cell(null);
  var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
  editor.on(&#39;NodeChange&#39;, function (e) {
    if (isFeatureEnabled(editor)) {
      toggleInlines(isInlineTarget, editor.dom, e.parents);
      safeRemoveCaretContainer(editor, caret);
      renderInsideInlineCaret(isInlineTarget, editor, caret, e.parents);
    }
  });
  return caret;
};
var moveNextWord = curry(moveWord, true);
var movePrevWord = curry(moveWord, false);
var BoundarySelection = {
  move: move,
  moveNextWord: moveNextWord,
  movePrevWord: movePrevWord,
  setupSelectedState: setupSelectedState,
  setCaretPosition: setCaretPosition
};

var isFeatureEnabled$1 = function (editor) {
  return editor.settings.inline_boundaries !== false;
};
var rangeFromPositions = function (from, to) {
  var range = document.createRange();
  range.setStart(from.container(), from.offset());
  range.setEnd(to.container(), to.offset());
  return range;
};
var hasOnlyTwoOrLessPositionsLeft = function (elm) {
  return liftN([
    CaretFinder.firstPositionIn(elm),
    CaretFinder.lastPositionIn(elm)
  ], function (firstPos, lastPos) {
    var normalizedFirstPos = InlineUtils.normalizePosition(true, firstPos);
    var normalizedLastPos = InlineUtils.normalizePosition(false, lastPos);
    return CaretFinder.nextPosition(elm, normalizedFirstPos).map(function (pos) {
      return pos.isEqual(normalizedLastPos);
    }).getOr(true);
  }).getOr(true);
};
var setCaretLocation = function (editor, caret) {
  return function (location$$1) {
    return BoundaryCaret.renderCaret(caret, location$$1).map(function (pos) {
      BoundarySelection.setCaretPosition(editor, pos);
      return true;
    }).getOr(false);
  };
};
var deleteFromTo = function (editor, caret, from, to) {
  var rootNode = editor.getBody();
  var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
  editor.undoManager.ignore(function () {
    editor.selection.setRng(rangeFromPositions(from, to));
    editor.execCommand(&#39;Delete&#39;);
    BoundaryLocation.readLocation(isInlineTarget, rootNode, CaretPosition$1.fromRangeStart(editor.selection.getRng())).map(BoundaryLocation.inside).map(setCaretLocation(editor, caret));
  });
  editor.nodeChanged();
};
var rescope$1 = function (rootNode, node) {
  var parentBlock = getParentBlock(node, rootNode);
  return parentBlock ? parentBlock : rootNode;
};
var backspaceDeleteCollapsed = function (editor, caret, forward, from) {
  var rootNode = rescope$1(editor.getBody(), from.container());
  var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
  var fromLocation = BoundaryLocation.readLocation(isInlineTarget, rootNode, from);
  return fromLocation.bind(function (location$$1) {
    if (forward) {
      return location$$1.fold(constant(Option.some(BoundaryLocation.inside(location$$1))), Option.none, constant(Option.some(BoundaryLocation.outside(location$$1))), Option.none);
    } else {
      return location$$1.fold(Option.none, constant(Option.some(BoundaryLocation.outside(location$$1))), Option.none, constant(Option.some(BoundaryLocation.inside(location$$1))));
    }
  }).map(setCaretLocation(editor, caret)).getOrThunk(function () {
    var toPosition = CaretFinder.navigate(forward, rootNode, from);
    var toLocation = toPosition.bind(function (pos) {
      return BoundaryLocation.readLocation(isInlineTarget, rootNode, pos);
    });
    if (fromLocation.isSome() &amp;&amp; toLocation.isSome()) {
      return InlineUtils.findRootInline(isInlineTarget, rootNode, from).map(function (elm) {
        if (hasOnlyTwoOrLessPositionsLeft(elm)) {
          DeleteElement.deleteElement(editor, forward, Element$$1.fromDom(elm));
          return true;
        } else {
          return false;
        }
      }).getOr(false);
    } else {
      return toLocation.bind(function (_) {
        return toPosition.map(function (to) {
          if (forward) {
            deleteFromTo(editor, caret, from, to);
          } else {
            deleteFromTo(editor, caret, to, from);
          }
          return true;
        });
      }).getOr(false);
    }
  });
};
var backspaceDelete$3 = function (editor, caret, forward) {
  if (editor.selection.isCollapsed() &amp;&amp; isFeatureEnabled$1(editor)) {
    var from = CaretPosition$1.fromRangeStart(editor.selection.getRng());
    return backspaceDeleteCollapsed(editor, caret, forward, from);
  }
  return false;
};
var InlineBoundaryDelete = { backspaceDelete: backspaceDelete$3 };

var tableCellRng = Immutable(&#39;start&#39;, &#39;end&#39;);
var tableSelection = Immutable(&#39;rng&#39;, &#39;table&#39;, &#39;cells&#39;);
var deleteAction = Adt.generate([
  { removeTable: [&#39;element&#39;] },
  { emptyCells: [&#39;cells&#39;] }
]);
var isRootFromElement = function (root) {
  return curry(eq, root);
};
var getClosestCell = function (container, isRoot) {
  return closest$1(Element$$1.fromDom(container), &#39;td,th&#39;, isRoot);
};
var getClosestTable = function (cell, isRoot) {
  return ancestor$1(cell, &#39;table&#39;, isRoot);
};
var isExpandedCellRng = function (cellRng) {
  return eq(cellRng.start(), cellRng.end()) === false;
};
var getTableFromCellRng = function (cellRng, isRoot) {
  return getClosestTable(cellRng.start(), isRoot).bind(function (startParentTable) {
    return getClosestTable(cellRng.end(), isRoot).bind(function (endParentTable) {
      return eq(startParentTable, endParentTable) ? Option.some(startParentTable) : Option.none();
    });
  });
};
var getTableCells = function (table) {
  return descendants$1(table, &#39;td,th&#39;);
};
var getCellRangeFromStartTable = function (cellRng, isRoot) {
  return getClosestTable(cellRng.start(), isRoot).bind(function (table) {
    return last(getTableCells(table)).map(function (endCell) {
      return tableCellRng(cellRng.start(), endCell);
    });
  });
};
var partialSelection = function (isRoot, rng) {
  var startCell = getClosestCell(rng.startContainer, isRoot);
  var endCell = getClosestCell(rng.endContainer, isRoot);
  return rng.collapsed ? Option.none() : liftN([
    startCell,
    endCell
  ], tableCellRng).fold(function () {
    return startCell.fold(function () {
      return endCell.bind(function (endCell) {
        return getClosestTable(endCell, isRoot).bind(function (table) {
          return head(getTableCells(table)).map(function (startCell) {
            return tableCellRng(startCell, endCell);
          });
        });
      });
    }, function (startCell) {
      return getClosestTable(startCell, isRoot).bind(function (table) {
        return last(getTableCells(table)).map(function (endCell) {
          return tableCellRng(startCell, endCell);
        });
      });
    });
  }, function (cellRng) {
    return isWithinSameTable(isRoot, cellRng) ? Option.none() : getCellRangeFromStartTable(cellRng, isRoot);
  });
};
var isWithinSameTable = function (isRoot, cellRng) {
  return getTableFromCellRng(cellRng, isRoot).isSome();
};
var getCellRng = function (rng, isRoot) {
  var startCell = getClosestCell(rng.startContainer, isRoot);
  var endCell = getClosestCell(rng.endContainer, isRoot);
  return liftN([
    startCell,
    endCell
  ], tableCellRng).filter(isExpandedCellRng).filter(function (cellRng) {
    return isWithinSameTable(isRoot, cellRng);
  }).orThunk(function () {
    return partialSelection(isRoot, rng);
  });
};
var getTableSelectionFromCellRng = function (cellRng, isRoot) {
  return getTableFromCellRng(cellRng, isRoot).map(function (table) {
    return tableSelection(cellRng, table, getTableCells(table));
  });
};
var getTableSelectionFromRng = function (root, rng) {
  var isRoot = isRootFromElement(root);
  return getCellRng(rng, isRoot).bind(function (cellRng) {
    return getTableSelectionFromCellRng(cellRng, isRoot);
  });
};
var getCellIndex = function (cells, cell) {
  return findIndex(cells, function (x) {
    return eq(x, cell);
  });
};
var getSelectedCells = function (tableSelection) {
  return liftN([
    getCellIndex(tableSelection.cells(), tableSelection.rng().start()),
    getCellIndex(tableSelection.cells(), tableSelection.rng().end())
  ], function (startIndex, endIndex) {
    return tableSelection.cells().slice(startIndex, endIndex + 1);
  });
};
var getAction = function (tableSelection) {
  return getSelectedCells(tableSelection).map(function (selected) {
    var cells = tableSelection.cells();
    return selected.length === cells.length ? deleteAction.removeTable(tableSelection.table()) : deleteAction.emptyCells(selected);
  });
};
var getActionFromCells = function (cells) {
  return deleteAction.emptyCells(cells);
};
var getActionFromRange = function (root, rng) {
  return getTableSelectionFromRng(root, rng).bind(getAction);
};
var TableDeleteAction = {
  getActionFromRange: getActionFromRange,
  getActionFromCells: getActionFromCells
};

var getRanges = function (selection) {
  var ranges = [];
  if (selection) {
    for (var i = 0; i &lt; selection.rangeCount; i++) {
      ranges.push(selection.getRangeAt(i));
    }
  }
  return ranges;
};
var getSelectedNodes = function (ranges) {
  return bind(ranges, function (range$$1) {
    var node = getSelectedNode(range$$1);
    return node ? [Element$$1.fromDom(node)] : [];
  });
};
var hasMultipleRanges = function (selection) {
  return getRanges(selection).length &gt; 1;
};
var MultiRange = {
  getRanges: getRanges,
  getSelectedNodes: getSelectedNodes,
  hasMultipleRanges: hasMultipleRanges
};

var getCellsFromRanges = function (ranges) {
  return filter(MultiRange.getSelectedNodes(ranges), isTableCell);
};
var getCellsFromElement = function (elm) {
  var selectedCells = descendants$1(elm, &#39;td[data-mce-selected],th[data-mce-selected]&#39;);
  return selectedCells;
};
var getCellsFromElementOrRanges = function (ranges, element) {
  var selectedCells = getCellsFromElement(element);
  var rangeCells = getCellsFromRanges(ranges);
  return selectedCells.length &gt; 0 ? selectedCells : rangeCells;
};
var getCellsFromEditor = function (editor) {
  return getCellsFromElementOrRanges(MultiRange.getRanges(editor.selection.getSel()), Element$$1.fromDom(editor.getBody()));
};
var TableCellSelection = {
  getCellsFromRanges: getCellsFromRanges,
  getCellsFromElement: getCellsFromElement,
  getCellsFromElementOrRanges: getCellsFromElementOrRanges,
  getCellsFromEditor: getCellsFromEditor
};

var emptyCells = function (editor, cells) {
  each(cells, PaddingBr.fillWithPaddingBr);
  editor.selection.setCursorLocation(cells[0].dom(), 0);
  return true;
};
var deleteTableElement = function (editor, table) {
  DeleteElement.deleteElement(editor, false, table);
  return true;
};
var deleteCellRange = function (editor, rootElm, rng) {
  return TableDeleteAction.getActionFromRange(rootElm, rng).map(function (action) {
    return action.fold(curry(deleteTableElement, editor), curry(emptyCells, editor));
  });
};
var deleteCaptionRange = function (editor, caption) {
  return emptyElement(editor, caption);
};
var deleteTableRange = function (editor, rootElm, rng, startElm) {
  return getParentCaption(rootElm, startElm).fold(function () {
    return deleteCellRange(editor, rootElm, rng);
  }, function (caption) {
    return deleteCaptionRange(editor, caption);
  }).getOr(false);
};
var deleteRange$1 = function (editor, startElm) {
  var rootNode = Element$$1.fromDom(editor.getBody());
  var rng = editor.selection.getRng();
  var selectedCells = TableCellSelection.getCellsFromEditor(editor);
  return selectedCells.length !== 0 ? emptyCells(editor, selectedCells) : deleteTableRange(editor, rootNode, rng, startElm);
};
var getParentCell = function (rootElm, elm) {
  return find(Parents.parentsAndSelf(elm, rootElm), isTableCell);
};
var getParentCaption = function (rootElm, elm) {
  return find(Parents.parentsAndSelf(elm, rootElm), function (elm) {
    return name(elm) === &#39;caption&#39;;
  });
};
var deleteBetweenCells = function (editor, rootElm, forward, fromCell, from) {
  return CaretFinder.navigate(forward, editor.getBody(), from).bind(function (to) {
    return getParentCell(rootElm, Element$$1.fromDom(to.getNode())).map(function (toCell) {
      return eq(toCell, fromCell) === false;
    });
  });
};
var emptyElement = function (editor, elm) {
  PaddingBr.fillWithPaddingBr(elm);
  editor.selection.setCursorLocation(elm.dom(), 0);
  return Option.some(true);
};
var isDeleteOfLastCharPos = function (fromCaption, forward, from, to) {
  return CaretFinder.firstPositionIn(fromCaption.dom()).bind(function (first) {
    return CaretFinder.lastPositionIn(fromCaption.dom()).map(function (last$$1) {
      return forward ? from.isEqual(first) &amp;&amp; to.isEqual(last$$1) : from.isEqual(last$$1) &amp;&amp; to.isEqual(first);
    });
  }).getOr(true);
};
var emptyCaretCaption = function (editor, elm) {
  return emptyElement(editor, elm);
};
var validateCaretCaption = function (rootElm, fromCaption, to) {
  return getParentCaption(rootElm, Element$$1.fromDom(to.getNode())).map(function (toCaption) {
    return eq(toCaption, fromCaption) === false;
  });
};
var deleteCaretInsideCaption = function (editor, rootElm, forward, fromCaption, from) {
  return CaretFinder.navigate(forward, editor.getBody(), from).bind(function (to) {
    return isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to);
  }).or(Option.some(true));
};
var deleteCaretCells = function (editor, forward, rootElm, startElm) {
  var from = CaretPosition$1.fromRangeStart(editor.selection.getRng());
  return getParentCell(rootElm, startElm).bind(function (fromCell) {
    return Empty.isEmpty(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from);
  });
};
var deleteCaretCaption = function (editor, forward, rootElm, fromCaption) {
  var from = CaretPosition$1.fromRangeStart(editor.selection.getRng());
  return Empty.isEmpty(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);
};
var deleteCaret = function (editor, forward, startElm) {
  var rootElm = Element$$1.fromDom(editor.getBody());
  return getParentCaption(rootElm, startElm).fold(function () {
    return deleteCaretCells(editor, forward, rootElm, startElm);
  }, function (fromCaption) {
    return deleteCaretCaption(editor, forward, rootElm, fromCaption);
  }).getOr(false);
};
var backspaceDelete$4 = function (editor, forward) {
  var startElm = Element$$1.fromDom(editor.selection.getStart(true));
  var cells = TableCellSelection.getCellsFromEditor(editor);
  return editor.selection.isCollapsed() &amp;&amp; cells.length === 0 ? deleteCaret(editor, forward, startElm) : deleteRange$1(editor, startElm);
};
var TableDelete = { backspaceDelete: backspaceDelete$4 };

var nativeCommand = function (editor, command) {
  editor.getDoc().execCommand(command, false, null);
};
var deleteCommand = function (editor) {
  if (CefDelete.backspaceDelete(editor, false)) {
    return;
  } else if (InlineBoundaryDelete.backspaceDelete(editor, false)) {
    return;
  } else if (BlockBoundaryDelete.backspaceDelete(editor, false)) {
    return;
  } else if (TableDelete.backspaceDelete(editor)) {
    return;
  } else if (BlockRangeDelete.backspaceDelete(editor, false)) {
    return;
  } else {
    nativeCommand(editor, &#39;Delete&#39;);
    DeleteUtils.paddEmptyBody(editor);
  }
};
var forwardDeleteCommand = function (editor) {
  if (CefDelete.backspaceDelete(editor, true)) {
    return;
  } else if (InlineBoundaryDelete.backspaceDelete(editor, true)) {
    return;
  } else if (BlockBoundaryDelete.backspaceDelete(editor, true)) {
    return;
  } else if (TableDelete.backspaceDelete(editor)) {
    return;
  } else if (BlockRangeDelete.backspaceDelete(editor, true)) {
    return;
  } else {
    nativeCommand(editor, &#39;ForwardDelete&#39;);
  }
};
var DeleteCommands = {
  deleteCommand: deleteCommand,
  forwardDeleteCommand: forwardDeleteCommand
};

var getBodySetting = function (editor, name, defaultValue) {
  var value = editor.getParam(name, defaultValue);
  if (value.indexOf(&#39;=&#39;) !== -1) {
    var bodyObj = editor.getParam(name, &#39;&#39;, &#39;hash&#39;);
    return bodyObj.hasOwnProperty(editor.id) ? bodyObj[editor.id] : defaultValue;
  } else {
    return value;
  }
};
var getIframeAttrs = function (editor) {
  return editor.getParam(&#39;iframe_attrs&#39;, {});
};
var getDocType = function (editor) {
  return editor.getParam(&#39;doctype&#39;, &#39;&lt;!DOCTYPE html&gt;&#39;);
};
var getDocumentBaseUrl = function (editor) {
  return editor.getParam(&#39;document_base_url&#39;, &#39;&#39;);
};
var getBodyId = function (editor) {
  return getBodySetting(editor, &#39;body_id&#39;, &#39;tinymce&#39;);
};
var getBodyClass = function (editor) {
  return getBodySetting(editor, &#39;body_class&#39;, &#39;&#39;);
};
var getContentSecurityPolicy = function (editor) {
  return editor.getParam(&#39;content_security_policy&#39;, &#39;&#39;);
};
var shouldPutBrInPre = function (editor) {
  return editor.getParam(&#39;br_in_pre&#39;, true);
};
var getForcedRootBlock = function (editor) {
  if (editor.getParam(&#39;force_p_newlines&#39;, false)) {
    return &#39;p&#39;;
  }
  var block = editor.getParam(&#39;forced_root_block&#39;, &#39;p&#39;);
  return block === false ? &#39;&#39; : block;
};
var getForcedRootBlockAttrs = function (editor) {
  return editor.getParam(&#39;forced_root_block_attrs&#39;, {});
};
var getBrNewLineSelector = function (editor) {
  return editor.getParam(&#39;br_newline_selector&#39;, &#39;.mce-toc h2,figcaption,caption&#39;);
};
var getNoNewLineSelector = function (editor) {
  return editor.getParam(&#39;no_newline_selector&#39;, &#39;&#39;);
};
var shouldKeepStyles = function (editor) {
  return editor.getParam(&#39;keep_styles&#39;, true);
};
var shouldEndContainerOnEmptyBlock = function (editor) {
  return editor.getParam(&#39;end_container_on_empty_block&#39;, false);
};
var getFontStyleValues = function (editor) {
  return Tools.explode(editor.getParam(&#39;font_size_style_values&#39;, &#39;&#39;));
};
var getFontSizeClasses = function (editor) {
  return Tools.explode(editor.getParam(&#39;font_size_classes&#39;, &#39;&#39;));
};
var getImagesDataImgFilter = function (editor) {
  return editor.getParam(&#39;images_dataimg_filter&#39;, constant(true), &#39;function&#39;);
};
var isAutomaticUploadsEnabled = function (editor) {
  return editor.getParam(&#39;automatic_uploads&#39;, true, &#39;boolean&#39;);
};
var shouldReuseFileName = function (editor) {
  return editor.getParam(&#39;images_reuse_filename&#39;, false, &#39;boolean&#39;);
};
var shouldReplaceBlobUris = function (editor) {
  return editor.getParam(&#39;images_replace_blob_uris&#39;, true, &#39;boolean&#39;);
};
var getImageUploadUrl = function (editor) {
  return editor.getParam(&#39;images_upload_url&#39;, &#39;&#39;, &#39;string&#39;);
};
var getImageUploadBasePath = function (editor) {
  return editor.getParam(&#39;images_upload_base_path&#39;, &#39;&#39;, &#39;string&#39;);
};
var getImagesUploadCredentials = function (editor) {
  return editor.getParam(&#39;images_upload_credentials&#39;, false, &#39;boolean&#39;);
};
var getImagesUploadHandler = function (editor) {
  return editor.getParam(&#39;images_upload_handler&#39;, null, &#39;function&#39;);
};
var shouldUseContentCssCors = function (editor) {
  return editor.getParam(&#39;content_css_cors&#39;, false, &#39;boolean&#39;);
};
var Settings = {
  getIframeAttrs: getIframeAttrs,
  getDocType: getDocType,
  getDocumentBaseUrl: getDocumentBaseUrl,
  getBodyId: getBodyId,
  getBodyClass: getBodyClass,
  getContentSecurityPolicy: getContentSecurityPolicy,
  shouldPutBrInPre: shouldPutBrInPre,
  getForcedRootBlock: getForcedRootBlock,
  getForcedRootBlockAttrs: getForcedRootBlockAttrs,
  getBrNewLineSelector: getBrNewLineSelector,
  getNoNewLineSelector: getNoNewLineSelector,
  shouldKeepStyles: shouldKeepStyles,
  shouldEndContainerOnEmptyBlock: shouldEndContainerOnEmptyBlock,
  getFontStyleValues: getFontStyleValues,
  getFontSizeClasses: getFontSizeClasses,
  getImagesDataImgFilter: getImagesDataImgFilter,
  isAutomaticUploadsEnabled: isAutomaticUploadsEnabled,
  shouldReuseFileName: shouldReuseFileName,
  shouldReplaceBlobUris: shouldReplaceBlobUris,
  getImageUploadUrl: getImageUploadUrl,
  getImageUploadBasePath: getImageUploadBasePath,
  getImagesUploadCredentials: getImagesUploadCredentials,
  getImagesUploadHandler: getImagesUploadHandler,
  shouldUseContentCssCors: shouldUseContentCssCors
};

var getSpecifiedFontProp = function (propName, rootElm, elm) {
  var getProperty = function (elm) {
    return getRaw(elm, propName);
  };
  var isRoot = function (elm) {
    return eq(Element$$1.fromDom(rootElm), elm);
  };
  return closest(Element$$1.fromDom(elm), function (elm) {
    return getProperty(elm).isSome();
  }, isRoot).bind(getProperty);
};
var round$1 = function (number, precision) {
  var factor = Math.pow(10, precision);
  return Math.round(number * factor) / factor;
};
var toPt = function (fontSize, precision) {
  if (/[0-9.]+px$/.test(fontSize)) {
    return round$1(parseInt(fontSize, 10) * 72 / 96, precision || 0) + &#39;pt&#39;;
  }
  return fontSize;
};
var normalizeFontFamily = function (fontFamily) {
  return fontFamily.replace(/[\&#39;\&quot;\\]/g, &#39;&#39;).replace(/,\s+/g, &#39;,&#39;);
};
var getComputedFontProp = function (propName, elm) {
  return Option.from(DOMUtils$1.DOM.getStyle(elm, propName, true));
};
var getFontProp = function (propName) {
  return function (rootElm, elm) {
    return Option.from(elm).map(Element$$1.fromDom).filter(isElement).bind(function (element) {
      return getSpecifiedFontProp(propName, rootElm, element.dom()).or(getComputedFontProp(propName, element.dom()));
    }).getOr(&#39;&#39;);
  };
};
var FontInfo = {
  getFontSize: getFontProp(&#39;font-size&#39;),
  getFontFamily: compose(normalizeFontFamily, getFontProp(&#39;font-family&#39;)),
  toPt: toPt
};

var findFirstCaretElement = function (editor) {
  return CaretFinder.firstPositionIn(editor.getBody()).map(function (caret) {
    var container = caret.container();
    return NodeType.isText(container) ? container.parentNode : container;
  });
};
var isRangeAtStartOfNode = function (rng, root) {
  return rng.startContainer === root &amp;&amp; rng.startOffset === 0;
};
var getCaretElement = function (editor) {
  return Option.from(editor.selection.getRng()).bind(function (rng) {
    var root = editor.getBody();
    return isRangeAtStartOfNode(rng, root) ? Option.none() : Option.from(editor.selection.getStart(true));
  });
};
var fromFontSizeNumber = function (editor, value) {
  if (/^[0-9\.]+$/.test(value)) {
    var fontSizeNumber = parseInt(value, 10);
    if (fontSizeNumber &gt;= 1 &amp;&amp; fontSizeNumber &lt;= 7) {
      var fontSizes = Settings.getFontStyleValues(editor);
      var fontClasses = Settings.getFontSizeClasses(editor);
      if (fontClasses) {
        return fontClasses[fontSizeNumber - 1] || value;
      } else {
        return fontSizes[fontSizeNumber - 1] || value;
      }
    } else {
      return value;
    }
  } else {
    return value;
  }
};
var fontNameAction = function (editor, value) {
  editor.formatter.toggle(&#39;fontname&#39;, { value: fromFontSizeNumber(editor, value) });
  editor.nodeChanged();
};
var fontNameQuery = function (editor) {
  return getCaretElement(editor).fold(function () {
    return findFirstCaretElement(editor).map(function (caretElement) {
      return FontInfo.getFontFamily(editor.getBody(), caretElement);
    }).getOr(&#39;&#39;);
  }, function (caretElement) {
    return FontInfo.getFontFamily(editor.getBody(), caretElement);
  });
};
var fontSizeAction = function (editor, value) {
  editor.formatter.toggle(&#39;fontsize&#39;, { value: fromFontSizeNumber(editor, value) });
  editor.nodeChanged();
};
var fontSizeQuery = function (editor) {
  return getCaretElement(editor).fold(function () {
    return findFirstCaretElement(editor).map(function (caretElement) {
      return FontInfo.getFontSize(editor.getBody(), caretElement);
    }).getOr(&#39;&#39;);
  }, function (caretElement) {
    return FontInfo.getFontSize(editor.getBody(), caretElement);
  });
};

var isEq$2 = function (rng1, rng2) {
  return rng1 &amp;&amp; rng2 &amp;&amp; (rng1.startContainer === rng2.startContainer &amp;&amp; rng1.startOffset === rng2.startOffset) &amp;&amp; (rng1.endContainer === rng2.endContainer &amp;&amp; rng1.endOffset === rng2.endOffset);
};
var RangeCompare = { isEq: isEq$2 };

var findParent = function (node, rootNode, predicate) {
  while (node &amp;&amp; node !== rootNode) {
    if (predicate(node)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
};
var hasParent = function (node, rootNode, predicate) {
  return findParent(node, rootNode, predicate) !== null;
};
var hasParentWithName = function (node, rootNode, name) {
  return hasParent(node, rootNode, function (node) {
    return node.nodeName === name;
  });
};
var isTable$2 = function (node) {
  return node &amp;&amp; node.nodeName === &#39;TABLE&#39;;
};
var isTableCell$3 = function (node) {
  return node &amp;&amp; /^(TD|TH|CAPTION)$/.test(node.nodeName);
};
var isCeFalseCaretContainer = function (node, rootNode) {
  return isCaretContainer(node) &amp;&amp; hasParent(node, rootNode, isCaretNode) === false;
};
var hasBrBeforeAfter = function (dom, node, left) {
  var walker = new TreeWalker(node, dom.getParent(node.parentNode, dom.isBlock) || dom.getRoot());
  while (node = walker[left ? &#39;prev&#39; : &#39;next&#39;]()) {
    if (NodeType.isBr(node)) {
      return true;
    }
  }
};
var isPrevNode = function (node, name) {
  return node.previousSibling &amp;&amp; node.previousSibling.nodeName === name;
};
var hasContentEditableFalseParent = function (body, node) {
  while (node &amp;&amp; node !== body) {
    if (NodeType.isContentEditableFalse(node)) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};
var findTextNodeRelative = function (dom, isAfterNode, collapsed, left, startNode) {
  var walker, lastInlineElement, parentBlockContainer;
  var body = dom.getRoot();
  var node;
  var nonEmptyElementsMap = dom.schema.getNonEmptyElements();
  parentBlockContainer = dom.getParent(startNode.parentNode, dom.isBlock) || body;
  if (left &amp;&amp; NodeType.isBr(startNode) &amp;&amp; isAfterNode &amp;&amp; dom.isEmpty(parentBlockContainer)) {
    return Option.some(CaretPosition(startNode.parentNode, dom.nodeIndex(startNode)));
  }
  walker = new TreeWalker(startNode, parentBlockContainer);
  while (node = walker[left ? &#39;prev&#39; : &#39;next&#39;]()) {
    if (dom.getContentEditableParent(node) === &#39;false&#39; || isCeFalseCaretContainer(node, body)) {
      return Option.none();
    }
    if (NodeType.isText(node) &amp;&amp; node.nodeValue.length &gt; 0) {
      if (hasParentWithName(node, body, &#39;A&#39;) === false) {
        return Option.some(CaretPosition(node, left ? node.nodeValue.length : 0));
      }
      return Option.none();
    }
    if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
      return Option.none();
    }
    lastInlineElement = node;
  }
  if (collapsed &amp;&amp; lastInlineElement) {
    return Option.some(CaretPosition(lastInlineElement, 0));
  }
  return Option.none();
};
var normalizeEndPoint = function (dom, collapsed, start, rng) {
  var container, offset, walker;
  var body = dom.getRoot();
  var node, nonEmptyElementsMap;
  var directionLeft, isAfterNode, normalized = false;
  container = rng[(start ? &#39;start&#39; : &#39;end&#39;) + &#39;Container&#39;];
  offset = rng[(start ? &#39;start&#39; : &#39;end&#39;) + &#39;Offset&#39;];
  isAfterNode = NodeType.isElement(container) &amp;&amp; offset === container.childNodes.length;
  nonEmptyElementsMap = dom.schema.getNonEmptyElements();
  directionLeft = start;
  if (isCaretContainer(container)) {
    return Option.none();
  }
  if (NodeType.isElement(container) &amp;&amp; offset &gt; container.childNodes.length - 1) {
    directionLeft = false;
  }
  if (NodeType.isDocument(container)) {
    container = body;
    offset = 0;
  }
  if (container === body) {
    if (directionLeft) {
      node = container.childNodes[offset &gt; 0 ? offset - 1 : 0];
      if (node) {
        if (isCaretContainer(node)) {
          return Option.none();
        }
        if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {
          return Option.none();
        }
      }
    }
    if (container.hasChildNodes()) {
      offset = Math.min(!directionLeft &amp;&amp; offset &gt; 0 ? offset - 1 : offset, container.childNodes.length - 1);
      container = container.childNodes[offset];
      offset = NodeType.isText(container) &amp;&amp; isAfterNode ? container.data.length : 0;
      if (!collapsed &amp;&amp; container === body.lastChild &amp;&amp; isTable$2(container)) {
        return Option.none();
      }
      if (hasContentEditableFalseParent(body, container) || isCaretContainer(container)) {
        return Option.none();
      }
      if (container.hasChildNodes() &amp;&amp; isTable$2(container) === false) {
        node = container;
        walker = new TreeWalker(container, body);
        do {
          if (NodeType.isContentEditableFalse(node) || isCaretContainer(node)) {
            normalized = false;
            break;
          }
          if (NodeType.isText(node) &amp;&amp; node.nodeValue.length &gt; 0) {
            offset = directionLeft ? 0 : node.nodeValue.length;
            container = node;
            normalized = true;
            break;
          }
          if (nonEmptyElementsMap[node.nodeName.toLowerCase()] &amp;&amp; !isTableCell$3(node)) {
            offset = dom.nodeIndex(node);
            container = node.parentNode;
            if (!directionLeft) {
              offset++;
            }
            normalized = true;
            break;
          }
        } while (node = directionLeft ? walker.next() : walker.prev());
      }
    }
  }
  if (collapsed) {
    if (NodeType.isText(container) &amp;&amp; offset === 0) {
      findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(function (pos) {
        container = pos.container();
        offset = pos.offset();
        normalized = true;
      });
    }
    if (NodeType.isElement(container)) {
      node = container.childNodes[offset];
      if (!node) {
        node = container.childNodes[offset - 1];
      }
      if (node &amp;&amp; NodeType.isBr(node) &amp;&amp; !isPrevNode(node, &#39;A&#39;) &amp;&amp; !hasBrBeforeAfter(dom, node, false) &amp;&amp; !hasBrBeforeAfter(dom, node, true)) {
        findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(function (pos) {
          container = pos.container();
          offset = pos.offset();
          normalized = true;
        });
      }
    }
  }
  if (directionLeft &amp;&amp; !collapsed &amp;&amp; NodeType.isText(container) &amp;&amp; offset === container.nodeValue.length) {
    findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(function (pos) {
      container = pos.container();
      offset = pos.offset();
      normalized = true;
    });
  }
  return normalized ? Option.some(CaretPosition(container, offset)) : Option.none();
};
var normalize$2 = function (dom, rng) {
  var collapsed = rng.collapsed, normRng = rng.cloneRange();
  var startPos = CaretPosition.fromRangeStart(rng);
  normalizeEndPoint(dom, collapsed, true, normRng).each(function (pos) {
    if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
      normRng.setStart(pos.container(), pos.offset());
    }
  });
  if (!collapsed) {
    normalizeEndPoint(dom, collapsed, false, normRng).each(function (pos) {
      normRng.setEnd(pos.container(), pos.offset());
    });
  }
  if (collapsed) {
    normRng.collapse(true);
  }
  return RangeCompare.isEq(rng, normRng) ? Option.none() : Option.some(normRng);
};
var NormalizeRange = { normalize: normalize$2 };

var hasRightSideContent = function (schema, container, parentBlock) {
  var walker = new TreeWalker(container, parentBlock);
  var node;
  var nonEmptyElementsMap = schema.getNonEmptyElements();
  while (node = walker.next()) {
    if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || node.length &gt; 0) {
      return true;
    }
  }
};
var scrollToBr = function (dom, selection, brElm) {
  var marker = dom.create(&#39;span&#39;, {}, &#39;&amp;nbsp;&#39;);
  brElm.parentNode.insertBefore(marker, brElm);
  selection.scrollIntoView(marker);
  dom.remove(marker);
};
var moveSelectionToBr = function (dom, selection, brElm, extraBr) {
  var rng = dom.createRng();
  if (!extraBr) {
    rng.setStartAfter(brElm);
    rng.setEndAfter(brElm);
  } else {
    rng.setStartBefore(brElm);
    rng.setEndBefore(brElm);
  }
  selection.setRng(rng);
};
var insertBrAtCaret = function (editor, evt) {
  var selection = editor.selection, dom = editor.dom;
  var brElm, extraBr;
  var rng = selection.getRng();
  NormalizeRange.normalize(dom, rng).each(function (normRng) {
    rng.setStart(normRng.startContainer, normRng.startOffset);
    rng.setEnd(normRng.endContainer, normRng.endOffset);
  });
  var offset = rng.startOffset;
  var container = rng.startContainer;
  if (container.nodeType === 1 &amp;&amp; container.hasChildNodes()) {
    var isAfterLastNodeInContainer = offset &gt; container.childNodes.length - 1;
    container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
    if (isAfterLastNodeInContainer &amp;&amp; container.nodeType === 3) {
      offset = container.nodeValue.length;
    } else {
      offset = 0;
    }
  }
  var parentBlock = dom.getParent(container, dom.isBlock);
  var containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
  var containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : &#39;&#39;;
  var isControlKey = evt &amp;&amp; evt.ctrlKey;
  if (containerBlockName === &#39;LI&#39; &amp;&amp; !isControlKey) {
    parentBlock = containerBlock;
  }
  if (container &amp;&amp; container.nodeType === 3 &amp;&amp; offset &gt;= container.nodeValue.length) {
    if (!hasRightSideContent(editor.schema, container, parentBlock)) {
      brElm = dom.create(&#39;br&#39;);
      rng.insertNode(brElm);
      rng.setStartAfter(brElm);
      rng.setEndAfter(brElm);
      extraBr = true;
    }
  }
  brElm = dom.create(&#39;br&#39;);
  rng.insertNode(brElm);
  scrollToBr(dom, selection, brElm);
  moveSelectionToBr(dom, selection, brElm, extraBr);
  editor.undoManager.add();
};
var insertBrBefore = function (editor, inline) {
  var br = Element$$1.fromTag(&#39;br&#39;);
  before(Element$$1.fromDom(inline), br);
  editor.undoManager.add();
};
var insertBrAfter = function (editor, inline) {
  if (!hasBrAfter(editor.getBody(), inline)) {
    after(Element$$1.fromDom(inline), Element$$1.fromTag(&#39;br&#39;));
  }
  var br = Element$$1.fromTag(&#39;br&#39;);
  after(Element$$1.fromDom(inline), br);
  scrollToBr(editor.dom, editor.selection, br.dom());
  moveSelectionToBr(editor.dom, editor.selection, br.dom(), false);
  editor.undoManager.add();
};
var isBeforeBr$1 = function (pos) {
  return NodeType.isBr(pos.getNode());
};
var hasBrAfter = function (rootNode, startNode) {
  if (isBeforeBr$1(CaretPosition$1.after(startNode))) {
    return true;
  } else {
    return CaretFinder.nextPosition(rootNode, CaretPosition$1.after(startNode)).map(function (pos) {
      return NodeType.isBr(pos.getNode());
    }).getOr(false);
  }
};
var isAnchorLink = function (elm) {
  return elm &amp;&amp; elm.nodeName === &#39;A&#39; &amp;&amp; &#39;href&#39; in elm;
};
var isInsideAnchor = function (location) {
  return location.fold(constant(false), isAnchorLink, isAnchorLink, constant(false));
};
var readInlineAnchorLocation = function (editor) {
  var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
  var position = CaretPosition$1.fromRangeStart(editor.selection.getRng());
  return BoundaryLocation.readLocation(isInlineTarget, editor.getBody(), position).filter(isInsideAnchor);
};
var insertBrOutsideAnchor = function (editor, location) {
  location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);
};
var insert = function (editor, evt) {
  var anchorLocation = readInlineAnchorLocation(editor);
  if (anchorLocation.isSome()) {
    anchorLocation.each(curry(insertBrOutsideAnchor, editor));
  } else {
    insertBrAtCaret(editor, evt);
  }
};
var InsertBr = { insert: insert };

var adt = Adt.generate([
  { &#39;before&#39;: [&#39;element&#39;] },
  {
    &#39;on&#39;: [
      &#39;element&#39;,
      &#39;offset&#39;
    ]
  },
  { after: [&#39;element&#39;] }
]);

var type$1 = Adt.generate([
  { domRange: [&#39;rng&#39;] },
  {
    relative: [
      &#39;startSitu&#39;,
      &#39;finishSitu&#39;
    ]
  },
  {
    exact: [
      &#39;start&#39;,
      &#39;soffset&#39;,
      &#39;finish&#39;,
      &#39;foffset&#39;
    ]
  }
]);
var range$1 = Immutable(&#39;start&#39;, &#39;soffset&#39;, &#39;finish&#39;, &#39;foffset&#39;);

var browser$3 = PlatformDetection$1.detect().browser;
var clamp = function (offset, element) {
  var max = isText(element) ? get$6(element).length : children(element).length + 1;
  if (offset &gt; max) {
    return max;
  } else if (offset &lt; 0) {
    return 0;
  }
  return offset;
};
var normalizeRng = function (rng) {
  return range$1(rng.start(), clamp(rng.soffset(), rng.start()), rng.finish(), clamp(rng.foffset(), rng.finish()));
};
var isOrContains = function (root, elm) {
  return contains$3(root, elm) || eq(root, elm);
};
var isRngInRoot = function (root) {
  return function (rng) {
    return isOrContains(root, rng.start()) &amp;&amp; isOrContains(root, rng.finish());
  };
};
var shouldStore = function (editor) {
  return editor.inline === true || browser$3.isIE();
};
var nativeRangeToSelectionRange = function (r) {
  return range$1(Element$$1.fromDom(r.startContainer), r.startOffset, Element$$1.fromDom(r.endContainer), r.endOffset);
};
var readRange = function (win) {
  var selection = win.getSelection();
  var rng = !selection || selection.rangeCount === 0 ? Option.none() : Option.from(selection.getRangeAt(0));
  return rng.map(nativeRangeToSelectionRange);
};
var getBookmark$2 = function (root) {
  var win = defaultView(root);
  return readRange(win.dom()).filter(isRngInRoot(root));
};
var validate = function (root, bookmark) {
  return Option.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
};
var bookmarkToNativeRng = function (bookmark) {
  var rng = document.createRange();
  try {
    rng.setStart(bookmark.start().dom(), bookmark.soffset());
    rng.setEnd(bookmark.finish().dom(), bookmark.foffset());
    return Option.some(rng);
  } catch (_) {
    return Option.none();
  }
};
var store = function (editor) {
  var newBookmark = shouldStore(editor) ? getBookmark$2(Element$$1.fromDom(editor.getBody())) : Option.none();
  editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
};
var storeNative = function (editor, rng) {
  var root = Element$$1.fromDom(editor.getBody());
  var range = shouldStore(editor) ? Option.from(rng) : Option.none();
  var newBookmark = range.map(nativeRangeToSelectionRange).filter(isRngInRoot(root));
  editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
};
var getRng = function (editor) {
  var bookmark = editor.bookmark ? editor.bookmark : Option.none();
  return bookmark.bind(curry(validate, Element$$1.fromDom(editor.getBody()))).bind(bookmarkToNativeRng);
};
var restore = function (editor) {
  getRng(editor).each(function (rng) {
    editor.selection.setRng(rng);
  });
};
var SelectionBookmark = {
  store: store,
  storeNative: storeNative,
  readRange: readRange,
  restore: restore,
  getRng: getRng,
  getBookmark: getBookmark$2,
  validate: validate
};

var indentElement = function (dom, command, useMargin, value, unit, element) {
  if (dom.getContentEditable(element) === &#39;false&#39;) {
    return;
  }
  var indentStyleName = useMargin ? &#39;margin&#39; : &#39;padding&#39;;
  indentStyleName = element.nodeName === &#39;TABLE&#39; ? &#39;margin&#39; : indentStyleName;
  indentStyleName += dom.getStyle(element, &#39;direction&#39;, true) === &#39;rtl&#39; ? &#39;Right&#39; : &#39;Left&#39;;
  if (command === &#39;outdent&#39;) {
    var styleValue = Math.max(0, parseInt(element.style[indentStyleName] || 0, 10) - value);
    dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : &#39;&#39;);
  } else {
    var styleValue = parseInt(element.style[indentStyleName] || 0, 10) + value + unit;
    dom.setStyle(element, indentStyleName, styleValue);
  }
};
var isListComponent = function (el) {
  return isList(el) || isListItem(el);
};
var parentIsListComponent = function (el) {
  return parent(el).map(isListComponent).getOr(false);
};
var getBlocksToIndent = function (editor) {
  return filter(map(editor.selection.getSelectedBlocks(), Element$$1.fromDom), function (el) {
    return !isListComponent(el) &amp;&amp; !parentIsListComponent(el);
  });
};
var handle = function (editor, command) {
  var settings = editor.settings, dom = editor.dom, selection = editor.selection, formatter = editor.formatter;
  var indentUnit = /[a-z%]+$/i.exec(settings.indentation)[0];
  var indentValue = parseInt(settings.indentation, 10);
  var useMargin = editor.getParam(&#39;indent_use_margin&#39;, false);
  if (!editor.queryCommandState(&#39;InsertUnorderedList&#39;) &amp;&amp; !editor.queryCommandState(&#39;InsertOrderedList&#39;)) {
    if (!settings.forced_root_block &amp;&amp; !dom.getParent(selection.getNode(), dom.isBlock)) {
      formatter.apply(&#39;div&#39;);
    }
  }
  each(getBlocksToIndent(editor), function (block) {
    indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom());
  });
};

var each$a = Tools.each, extend$2 = Tools.extend;
var map$3 = Tools.map, inArray$2 = Tools.inArray;
function EditorCommands (editor) {
  var dom, selection, formatter;
  var commands = {
    state: {},
    exec: {},
    value: {}
  };
  var settings = editor.settings, bookmark;
  editor.on(&#39;PreInit&#39;, function () {
    dom = editor.dom;
    selection = editor.selection;
    settings = editor.settings;
    formatter = editor.formatter;
  });
  var execCommand = function (command, ui, value, args) {
    var func, customCommand, state = false;
    if (editor.removed) {
      return;
    }
    if (!/^(mceAddUndoLevel|mceEndUndoLevel|mceBeginUndoLevel|mceRepaint)$/.test(command) &amp;&amp; (!args || !args.skip_focus)) {
      editor.focus();
    } else {
      SelectionBookmark.restore(editor);
    }
    args = editor.fire(&#39;BeforeExecCommand&#39;, {
      command: command,
      ui: ui,
      value: value
    });
    if (args.isDefaultPrevented()) {
      return false;
    }
    customCommand = command.toLowerCase();
    if (func = commands.exec[customCommand]) {
      func(customCommand, ui, value);
      editor.fire(&#39;ExecCommand&#39;, {
        command: command,
        ui: ui,
        value: value
      });
      return true;
    }
    each$a(editor.plugins, function (p) {
      if (p.execCommand &amp;&amp; p.execCommand(command, ui, value)) {
        editor.fire(&#39;ExecCommand&#39;, {
          command: command,
          ui: ui,
          value: value
        });
        state = true;
        return false;
      }
    });
    if (state) {
      return state;
    }
    if (editor.theme &amp;&amp; editor.theme.execCommand &amp;&amp; editor.theme.execCommand(command, ui, value)) {
      editor.fire(&#39;ExecCommand&#39;, {
        command: command,
        ui: ui,
        value: value
      });
      return true;
    }
    try {
      state = editor.getDoc().execCommand(command, ui, value);
    } catch (ex) {
    }
    if (state) {
      editor.fire(&#39;ExecCommand&#39;, {
        command: command,
        ui: ui,
        value: value
      });
      return true;
    }
    return false;
  };
  var queryCommandState = function (command) {
    var func;
    if (editor.quirks.isHidden() || editor.removed) {
      return;
    }
    command = command.toLowerCase();
    if (func = commands.state[command]) {
      return func(command);
    }
    try {
      return editor.getDoc().queryCommandState(command);
    } catch (ex) {
    }
    return false;
  };
  var queryCommandValue = function (command) {
    var func;
    if (editor.quirks.isHidden() || editor.removed) {
      return;
    }
    command = command.toLowerCase();
    if (func = commands.value[command]) {
      return func(command);
    }
    try {
      return editor.getDoc().queryCommandValue(command);
    } catch (ex) {
    }
  };
  var addCommands = function (commandList, type) {
    type = type || &#39;exec&#39;;
    each$a(commandList, function (callback, command) {
      each$a(command.toLowerCase().split(&#39;,&#39;), function (command) {
        commands[type][command] = callback;
      });
    });
  };
  var addCommand = function (command, callback, scope) {
    command = command.toLowerCase();
    commands.exec[command] = function (command, ui, value, args) {
      return callback.call(scope || editor, ui, value, args);
    };
  };
  var queryCommandSupported = function (command) {
    command = command.toLowerCase();
    if (commands.exec[command]) {
      return true;
    }
    try {
      return editor.getDoc().queryCommandSupported(command);
    } catch (ex) {
    }
    return false;
  };
  var addQueryStateHandler = function (command, callback, scope) {
    command = command.toLowerCase();
    commands.state[command] = function () {
      return callback.call(scope || editor);
    };
  };
  var addQueryValueHandler = function (command, callback, scope) {
    command = command.toLowerCase();
    commands.value[command] = function () {
      return callback.call(scope || editor);
    };
  };
  var hasCustomCommand = function (command) {
    command = command.toLowerCase();
    return !!commands.exec[command];
  };
  extend$2(this, {
    execCommand: execCommand,
    queryCommandState: queryCommandState,
    queryCommandValue: queryCommandValue,
    queryCommandSupported: queryCommandSupported,
    addCommands: addCommands,
    addCommand: addCommand,
    addQueryStateHandler: addQueryStateHandler,
    addQueryValueHandler: addQueryValueHandler,
    hasCustomCommand: hasCustomCommand
  });
  var execNativeCommand = function (command, ui, value) {
    if (ui === undefined) {
      ui = false;
    }
    if (value === undefined) {
      value = null;
    }
    return editor.getDoc().execCommand(command, ui, value);
  };
  var isFormatMatch = function (name) {
    return formatter.match(name);
  };
  var toggleFormat = function (name, value) {
    formatter.toggle(name, value ? { value: value } : undefined);
    editor.nodeChanged();
  };
  var storeSelection = function (type) {
    bookmark = selection.getBookmark(type);
  };
  var restoreSelection = function () {
    selection.moveToBookmark(bookmark);
  };
  addCommands({
    &#39;mceResetDesignMode,mceBeginUndoLevel&#39;: function () {
    },
    &#39;mceEndUndoLevel,mceAddUndoLevel&#39;: function () {
      editor.undoManager.add();
    },
    &#39;Cut,Copy,Paste&#39;: function (command) {
      var doc = editor.getDoc();
      var failed;
      try {
        execNativeCommand(command);
      } catch (ex) {
        failed = true;
      }
      if (command === &#39;paste&#39; &amp;&amp; !doc.queryCommandEnabled(command)) {
        failed = true;
      }
      if (failed || !doc.queryCommandSupported(command)) {
        var msg = editor.translate(&#39;Your browser doesn\&#39;t support direct access to the clipboard. &#39; + &#39;Please use the Ctrl+X/C/V keyboard shortcuts instead.&#39;);
        if (Env.mac) {
          msg = msg.replace(/Ctrl\+/g, &#39;\u2318+&#39;);
        }
        editor.notificationManager.open({
          text: msg,
          type: &#39;error&#39;
        });
      }
    },
    &#39;unlink&#39;: function () {
      if (selection.isCollapsed()) {
        var elm = editor.dom.getParent(editor.selection.getStart(), &#39;a&#39;);
        if (elm) {
          editor.dom.remove(elm, true);
        }
        return;
      }
      formatter.remove(&#39;link&#39;);
    },
    &#39;JustifyLeft,JustifyCenter,JustifyRight,JustifyFull,JustifyNone&#39;: function (command) {
      var align = command.substring(7);
      if (align === &#39;full&#39;) {
        align = &#39;justify&#39;;
      }
      each$a(&#39;left,center,right,justify&#39;.split(&#39;,&#39;), function (name) {
        if (align !== name) {
          formatter.remove(&#39;align&#39; + name);
        }
      });
      if (align !== &#39;none&#39;) {
        toggleFormat(&#39;align&#39; + align);
      }
    },
    &#39;InsertUnorderedList,InsertOrderedList&#39;: function (command) {
      var listElm, listParent;
      execNativeCommand(command);
      listElm = dom.getParent(selection.getNode(), &#39;ol,ul&#39;);
      if (listElm) {
        listParent = listElm.parentNode;
        if (/^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
          storeSelection();
          dom.split(listParent, listElm);
          restoreSelection();
        }
      }
    },
    &#39;Bold,Italic,Underline,Strikethrough,Superscript,Subscript&#39;: function (command) {
      toggleFormat(command);
    },
    &#39;ForeColor,HiliteColor&#39;: function (command, ui, value) {
      toggleFormat(command, value);
    },
    &#39;FontName&#39;: function (command, ui, value) {
      fontNameAction(editor, value);
    },
    &#39;FontSize&#39;: function (command, ui, value) {
      fontSizeAction(editor, value);
    },
    &#39;RemoveFormat&#39;: function (command) {
      formatter.remove(command);
    },
    &#39;mceBlockQuote&#39;: function () {
      toggleFormat(&#39;blockquote&#39;);
    },
    &#39;FormatBlock&#39;: function (command, ui, value) {
      return toggleFormat(value || &#39;p&#39;);
    },
    &#39;mceCleanup&#39;: function () {
      var bookmark = selection.getBookmark();
      editor.setContent(editor.getContent());
      selection.moveToBookmark(bookmark);
    },
    &#39;mceRemoveNode&#39;: function (command, ui, value) {
      var node = value || selection.getNode();
      if (node !== editor.getBody()) {
        storeSelection();
        editor.dom.remove(node, true);
        restoreSelection();
      }
    },
    &#39;mceSelectNodeDepth&#39;: function (command, ui, value) {
      var counter = 0;
      dom.getParent(selection.getNode(), function (node) {
        if (node.nodeType === 1 &amp;&amp; counter++ === value) {
          selection.select(node);
          return false;
        }
      }, editor.getBody());
    },
    &#39;mceSelectNode&#39;: function (command, ui, value) {
      selection.select(value);
    },
    &#39;mceInsertContent&#39;: function (command, ui, value) {
      InsertContent.insertAtCaret(editor, value);
    },
    &#39;mceInsertRawHTML&#39;: function (command, ui, value) {
      selection.setContent(&#39;tiny_mce_marker&#39;);
      var content = editor.getContent();
      editor.setContent(content.replace(/tiny_mce_marker/g, function () {
        return value;
      }));
    },
    &#39;mceToggleFormat&#39;: function (command, ui, value) {
      toggleFormat(value);
    },
    &#39;mceSetContent&#39;: function (command, ui, value) {
      editor.setContent(value);
    },
    &#39;Indent,Outdent&#39;: function (command) {
      handle(editor, command);
    },
    &#39;mceRepaint&#39;: function () {
    },
    &#39;InsertHorizontalRule&#39;: function () {
      editor.execCommand(&#39;mceInsertContent&#39;, false, &#39;&lt;hr /&gt;&#39;);
    },
    &#39;mceToggleVisualAid&#39;: function () {
      editor.hasVisual = !editor.hasVisual;
      editor.addVisual();
    },
    &#39;mceReplaceContent&#39;: function (command, ui, value) {
      editor.execCommand(&#39;mceInsertContent&#39;, false, value.replace(/\{\$selection\}/g, selection.getContent({ format: &#39;text&#39; })));
    },
    &#39;mceInsertLink&#39;: function (command, ui, value) {
      var anchor;
      if (typeof value === &#39;string&#39;) {
        value = { href: value };
      }
      anchor = dom.getParent(selection.getNode(), &#39;a&#39;);
      value.href = value.href.replace(&#39; &#39;, &#39;%20&#39;);
      if (!anchor || !value.href) {
        formatter.remove(&#39;link&#39;);
      }
      if (value.href) {
        formatter.apply(&#39;link&#39;, value, anchor);
      }
    },
    &#39;selectAll&#39;: function () {
      var editingHost = dom.getParent(selection.getStart(), NodeType.isContentEditableTrue);
      if (editingHost) {
        var rng = dom.createRng();
        rng.selectNodeContents(editingHost);
        selection.setRng(rng);
      }
    },
    &#39;delete&#39;: function () {
      DeleteCommands.deleteCommand(editor);
    },
    &#39;forwardDelete&#39;: function () {
      DeleteCommands.forwardDeleteCommand(editor);
    },
    &#39;mceNewDocument&#39;: function () {
      editor.setContent(&#39;&#39;);
    },
    &#39;InsertLineBreak&#39;: function (command, ui, value) {
      InsertBr.insert(editor, value);
      return true;
    }
  });
  var alignStates = function (name) {
    return function () {
      var nodes = selection.isCollapsed() ? [dom.getParent(selection.getNode(), dom.isBlock)] : selection.getSelectedBlocks();
      var matches = map$3(nodes, function (node) {
        return !!formatter.matchNode(node, name);
      });
      return inArray$2(matches, true) !== -1;
    };
  };
  addCommands({
    &#39;JustifyLeft&#39;: alignStates(&#39;alignleft&#39;),
    &#39;JustifyCenter&#39;: alignStates(&#39;aligncenter&#39;),
    &#39;JustifyRight&#39;: alignStates(&#39;alignright&#39;),
    &#39;JustifyFull&#39;: alignStates(&#39;alignjustify&#39;),
    &#39;Bold,Italic,Underline,Strikethrough,Superscript,Subscript&#39;: function (command) {
      return isFormatMatch(command);
    },
    &#39;mceBlockQuote&#39;: function () {
      return isFormatMatch(&#39;blockquote&#39;);
    },
    &#39;Outdent&#39;: function () {
      var node;
      if (settings.inline_styles) {
        if ((node = dom.getParent(selection.getStart(), dom.isBlock)) &amp;&amp; parseInt(node.style.paddingLeft, 10) &gt; 0) {
          return true;
        }
        if ((node = dom.getParent(selection.getEnd(), dom.isBlock)) &amp;&amp; parseInt(node.style.paddingLeft, 10) &gt; 0) {
          return true;
        }
      }
      return queryCommandState(&#39;InsertUnorderedList&#39;) || queryCommandState(&#39;InsertOrderedList&#39;) || !settings.inline_styles &amp;&amp; !!dom.getParent(selection.getNode(), &#39;BLOCKQUOTE&#39;);
    },
    &#39;InsertUnorderedList,InsertOrderedList&#39;: function (command) {
      var list = dom.getParent(selection.getNode(), &#39;ul,ol&#39;);
      return list &amp;&amp; (command === &#39;insertunorderedlist&#39; &amp;&amp; list.tagName === &#39;UL&#39; || command === &#39;insertorderedlist&#39; &amp;&amp; list.tagName === &#39;OL&#39;);
    }
  }, &#39;state&#39;);
  addCommands({
    Undo: function () {
      editor.undoManager.undo();
    },
    Redo: function () {
      editor.undoManager.redo();
    }
  });
  addQueryValueHandler(&#39;FontName&#39;, function () {
    return fontNameQuery(editor);
  }, this);
  addQueryValueHandler(&#39;FontSize&#39;, function () {
    return fontSizeQuery(editor);
  }, this);
}

var nativeEvents = Tools.makeMap(&#39;focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange &#39; + &#39;mouseout mouseenter mouseleave wheel keydown keypress keyup input contextmenu dragstart dragend dragover &#39; + &#39;draggesture dragdrop drop drag submit &#39; + &#39;compositionstart compositionend compositionupdate touchstart touchmove touchend&#39;, &#39; &#39;);
var Dispatcher = function (settings) {
  var self = this;
  var scope, bindings = {}, toggleEvent;
  var returnFalse = function () {
    return false;
  };
  var returnTrue = function () {
    return true;
  };
  settings = settings || {};
  scope = settings.scope || self;
  toggleEvent = settings.toggleEvent || returnFalse;
  var fire = function (name, args) {
    var handlers, i, l, callback;
    name = name.toLowerCase();
    args = args || {};
    args.type = name;
    if (!args.target) {
      args.target = scope;
    }
    if (!args.preventDefault) {
      args.preventDefault = function () {
        args.isDefaultPrevented = returnTrue;
      };
      args.stopPropagation = function () {
        args.isPropagationStopped = returnTrue;
      };
      args.stopImmediatePropagation = function () {
        args.isImmediatePropagationStopped = returnTrue;
      };
      args.isDefaultPrevented = returnFalse;
      args.isPropagationStopped = returnFalse;
      args.isImmediatePropagationStopped = returnFalse;
    }
    if (settings.beforeFire) {
      settings.beforeFire(args);
    }
    handlers = bindings[name];
    if (handlers) {
      for (i = 0, l = handlers.length; i &lt; l; i++) {
        callback = handlers[i];
        if (callback.once) {
          off(name, callback.func);
        }
        if (args.isImmediatePropagationStopped()) {
          args.stopPropagation();
          return args;
        }
        if (callback.func.call(scope, args) === false) {
          args.preventDefault();
          return args;
        }
      }
    }
    return args;
  };
  var on = function (name, callback, prepend, extra) {
    var handlers, names, i;
    if (callback === false) {
      callback = returnFalse;
    }
    if (callback) {
      callback = { func: callback };
      if (extra) {
        Tools.extend(callback, extra);
      }
      names = name.toLowerCase().split(&#39; &#39;);
      i = names.length;
      while (i--) {
        name = names[i];
        handlers = bindings[name];
        if (!handlers) {
          handlers = bindings[name] = [];
          toggleEvent(name, true);
        }
        if (prepend) {
          handlers.unshift(callback);
        } else {
          handlers.push(callback);
        }
      }
    }
    return self;
  };
  var off = function (name, callback) {
    var i, handlers, bindingName, names, hi;
    if (name) {
      names = name.toLowerCase().split(&#39; &#39;);
      i = names.length;
      while (i--) {
        name = names[i];
        handlers = bindings[name];
        if (!name) {
          for (bindingName in bindings) {
            toggleEvent(bindingName, false);
            delete bindings[bindingName];
          }
          return self;
        }
        if (handlers) {
          if (!callback) {
            handlers.length = 0;
          } else {
            hi = handlers.length;
            while (hi--) {
              if (handlers[hi].func === callback) {
                handlers = handlers.slice(0, hi).concat(handlers.slice(hi + 1));
                bindings[name] = handlers;
              }
            }
          }
          if (!handlers.length) {
            toggleEvent(name, false);
            delete bindings[name];
          }
        }
      }
    } else {
      for (name in bindings) {
        toggleEvent(name, false);
      }
      bindings = {};
    }
    return self;
  };
  var once = function (name, callback, prepend) {
    return on(name, callback, prepend, { once: true });
  };
  var has = function (name) {
    name = name.toLowerCase();
    return !(!bindings[name] || bindings[name].length === 0);
  };
  self.fire = fire;
  self.on = on;
  self.off = off;
  self.once = once;
  self.has = has;
};
Dispatcher.isNative = function (name) {
  return !!nativeEvents[name.toLowerCase()];
};

var getEventDispatcher = function (obj) {
  if (!obj._eventDispatcher) {
    obj._eventDispatcher = new Dispatcher({
      scope: obj,
      toggleEvent: function (name, state) {
        if (Dispatcher.isNative(name) &amp;&amp; obj.toggleNativeEvent) {
          obj.toggleNativeEvent(name, state);
        }
      }
    });
  }
  return obj._eventDispatcher;
};
var Observable = {
  fire: function (name, args, bubble) {
    var self = this;
    if (self.removed &amp;&amp; name !== &#39;remove&#39;) {
      return args;
    }
    args = getEventDispatcher(self).fire(name, args, bubble);
    if (bubble !== false &amp;&amp; self.parent) {
      var parent = self.parent();
      while (parent &amp;&amp; !args.isPropagationStopped()) {
        parent.fire(name, args, false);
        parent = parent.parent();
      }
    }
    return args;
  },
  on: function (name, callback, prepend) {
    return getEventDispatcher(this).on(name, callback, prepend);
  },
  off: function (name, callback) {
    return getEventDispatcher(this).off(name, callback);
  },
  once: function (name, callback) {
    return getEventDispatcher(this).once(name, callback);
  },
  hasEventListeners: function (name) {
    return getEventDispatcher(this).has(name);
  }
};

var firePreProcess = function (editor, args) {
  return editor.fire(&#39;PreProcess&#39;, args);
};
var firePostProcess = function (editor, args) {
  return editor.fire(&#39;PostProcess&#39;, args);
};
var fireRemove = function (editor) {
  return editor.fire(&#39;remove&#39;);
};
var fireSwitchMode = function (editor, mode) {
  return editor.fire(&#39;SwitchMode&#39;, { mode: mode });
};
var fireObjectResizeStart = function (editor, target, width, height) {
  editor.fire(&#39;ObjectResizeStart&#39;, {
    target: target,
    width: width,
    height: height
  });
};
var fireObjectResized = function (editor, target, width, height) {
  editor.fire(&#39;ObjectResized&#39;, {
    target: target,
    width: width,
    height: height
  });
};
var Events = {
  firePreProcess: firePreProcess,
  firePostProcess: firePostProcess,
  fireRemove: fireRemove,
  fireSwitchMode: fireSwitchMode,
  fireObjectResizeStart: fireObjectResizeStart,
  fireObjectResized: fireObjectResized
};

var setEditorCommandState = function (editor, cmd, state) {
  try {
    editor.getDoc().execCommand(cmd, false, state);
  } catch (ex) {
  }
};
var toggleClass = function (elm, cls, state) {
  if (has$2(elm, cls) &amp;&amp; state === false) {
    remove$5(elm, cls);
  } else if (state) {
    add$2(elm, cls);
  }
};
var toggleReadOnly = function (editor, state) {
  toggleClass(Element$$1.fromDom(editor.getBody()), &#39;mce-content-readonly&#39;, state);
  if (state) {
    editor.selection.controlSelection.hideResizeRect();
    editor.readonly = true;
    editor.getBody().contentEditable = &#39;false&#39;;
  } else {
    editor.readonly = false;
    editor.getBody().contentEditable = &#39;true&#39;;
    setEditorCommandState(editor, &#39;StyleWithCSS&#39;, false);
    setEditorCommandState(editor, &#39;enableInlineTableEditing&#39;, false);
    setEditorCommandState(editor, &#39;enableObjectResizing&#39;, false);
    editor.focus();
    editor.nodeChanged();
  }
};
var setMode = function (editor, mode) {
  if (mode === getMode(editor)) {
    return;
  }
  if (editor.initialized) {
    toggleReadOnly(editor, mode === &#39;readonly&#39;);
  } else {
    editor.on(&#39;init&#39;, function () {
      toggleReadOnly(editor, mode === &#39;readonly&#39;);
    });
  }
  Events.fireSwitchMode(editor, mode);
};
var getMode = function (editor) {
  return editor.readonly ? &#39;readonly&#39; : &#39;design&#39;;
};
var isReadOnly = function (editor) {
  return editor.readonly === true;
};

var DOM$1 = DOMUtils$1.DOM;
var customEventRootDelegates;
var getEventTarget = function (editor, eventName) {
  if (eventName === &#39;selectionchange&#39;) {
    return editor.getDoc();
  }
  if (!editor.inline &amp;&amp; /^mouse|touch|click|contextmenu|drop|dragover|dragend/.test(eventName)) {
    return editor.getDoc().documentElement;
  }
  if (editor.settings.event_root) {
    if (!editor.eventRoot) {
      editor.eventRoot = DOM$1.select(editor.settings.event_root)[0];
    }
    return editor.eventRoot;
  }
  return editor.getBody();
};
var isListening = function (editor) {
  return !editor.hidden &amp;&amp; !editor.readonly;
};
var fireEvent = function (editor, eventName, e) {
  if (isListening(editor)) {
    editor.fire(eventName, e);
  } else if (isReadOnly(editor)) {
    e.preventDefault();
  }
};
var bindEventDelegate = function (editor, eventName) {
  var eventRootElm, delegate;
  if (!editor.delegates) {
    editor.delegates = {};
  }
  if (editor.delegates[eventName] || editor.removed) {
    return;
  }
  eventRootElm = getEventTarget(editor, eventName);
  if (editor.settings.event_root) {
    if (!customEventRootDelegates) {
      customEventRootDelegates = {};
      editor.editorManager.on(&#39;removeEditor&#39;, function () {
        var name;
        if (!editor.editorManager.activeEditor) {
          if (customEventRootDelegates) {
            for (name in customEventRootDelegates) {
              editor.dom.unbind(getEventTarget(editor, name));
            }
            customEventRootDelegates = null;
          }
        }
      });
    }
    if (customEventRootDelegates[eventName]) {
      return;
    }
    delegate = function (e) {
      var target = e.target;
      var editors = editor.editorManager.get();
      var i = editors.length;
      while (i--) {
        var body = editors[i].getBody();
        if (body === target || DOM$1.isChildOf(target, body)) {
          fireEvent(editors[i], eventName, e);
        }
      }
    };
    customEventRootDelegates[eventName] = delegate;
    DOM$1.bind(eventRootElm, eventName, delegate);
  } else {
    delegate = function (e) {
      fireEvent(editor, eventName, e);
    };
    DOM$1.bind(eventRootElm, eventName, delegate);
    editor.delegates[eventName] = delegate;
  }
};
var EditorObservable = {
  bindPendingEventDelegates: function () {
    var self = this;
    Tools.each(self._pendingNativeEvents, function (name) {
      bindEventDelegate(self, name);
    });
  },
  toggleNativeEvent: function (name, state) {
    var self = this;
    if (name === &#39;focus&#39; || name === &#39;blur&#39;) {
      return;
    }
    if (state) {
      if (self.initialized) {
        bindEventDelegate(self, name);
      } else {
        if (!self._pendingNativeEvents) {
          self._pendingNativeEvents = [name];
        } else {
          self._pendingNativeEvents.push(name);
        }
      }
    } else if (self.initialized) {
      self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
      delete self.delegates[name];
    }
  },
  unbindAllNativeEvents: function () {
    var self = this;
    var body = self.getBody();
    var dom = self.dom;
    var name;
    if (self.delegates) {
      for (name in self.delegates) {
        self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);
      }
      delete self.delegates;
    }
    if (!self.inline &amp;&amp; body &amp;&amp; dom) {
      body.onload = null;
      dom.unbind(self.getWin());
      dom.unbind(self.getDoc());
    }
    if (dom) {
      dom.unbind(body);
      dom.unbind(self.getContainer());
    }
  }
};
EditorObservable = Tools.extend({}, Observable, EditorObservable);
var EditorObservable$1 = EditorObservable;

var each$b = Tools.each, explode$2 = Tools.explode;
var keyCodeLookup = {
  f9: 120,
  f10: 121,
  f11: 122
};
var modifierNames = Tools.makeMap(&#39;alt,ctrl,shift,meta,access&#39;);
function Shortcuts (editor) {
  var self = this;
  var shortcuts = {};
  var pendingPatterns = [];
  var parseShortcut = function (pattern) {
    var id, key;
    var shortcut = {};
    each$b(explode$2(pattern, &#39;+&#39;), function (value) {
      if (value in modifierNames) {
        shortcut[value] = true;
      } else {
        if (/^[0-9]{2,}$/.test(value)) {
          shortcut.keyCode = parseInt(value, 10);
        } else {
          shortcut.charCode = value.charCodeAt(0);
          shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);
        }
      }
    });
    id = [shortcut.keyCode];
    for (key in modifierNames) {
      if (shortcut[key]) {
        id.push(key);
      } else {
        shortcut[key] = false;
      }
    }
    shortcut.id = id.join(&#39;,&#39;);
    if (shortcut.access) {
      shortcut.alt = true;
      if (Env.mac) {
        shortcut.ctrl = true;
      } else {
        shortcut.shift = true;
      }
    }
    if (shortcut.meta) {
      if (Env.mac) {
        shortcut.meta = true;
      } else {
        shortcut.ctrl = true;
        shortcut.meta = false;
      }
    }
    return shortcut;
  };
  var createShortcut = function (pattern, desc, cmdFunc, scope) {
    var shortcuts;
    shortcuts = Tools.map(explode$2(pattern, &#39;&gt;&#39;), parseShortcut);
    shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
      func: cmdFunc,
      scope: scope || editor
    });
    return Tools.extend(shortcuts[0], {
      desc: editor.translate(desc),
      subpatterns: shortcuts.slice(1)
    });
  };
  var hasModifier = function (e) {
    return e.altKey || e.ctrlKey || e.metaKey;
  };
  var isFunctionKey = function (e) {
    return e.type === &#39;keydown&#39; &amp;&amp; e.keyCode &gt;= 112 &amp;&amp; e.keyCode &lt;= 123;
  };
  var matchShortcut = function (e, shortcut) {
    if (!shortcut) {
      return false;
    }
    if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
      return false;
    }
    if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
      return false;
    }
    if (e.keyCode === shortcut.keyCode || e.charCode &amp;&amp; e.charCode === shortcut.charCode) {
      e.preventDefault();
      return true;
    }
    return false;
  };
  var executeShortcutAction = function (shortcut) {
    return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
  };
  editor.on(&#39;keyup keypress keydown&#39;, function (e) {
    if ((hasModifier(e) || isFunctionKey(e)) &amp;&amp; !e.isDefaultPrevented()) {
      each$b(shortcuts, function (shortcut) {
        if (matchShortcut(e, shortcut)) {
          pendingPatterns = shortcut.subpatterns.slice(0);
          if (e.type === &#39;keydown&#39;) {
            executeShortcutAction(shortcut);
          }
          return true;
        }
      });
      if (matchShortcut(e, pendingPatterns[0])) {
        if (pendingPatterns.length === 1) {
          if (e.type === &#39;keydown&#39;) {
            executeShortcutAction(pendingPatterns[0]);
          }
        }
        pendingPatterns.shift();
      }
    }
  });
  self.add = function (pattern, desc, cmdFunc, scope) {
    var cmd;
    cmd = cmdFunc;
    if (typeof cmdFunc === &#39;string&#39;) {
      cmdFunc = function () {
        editor.execCommand(cmd, false, null);
      };
    } else if (Tools.isArray(cmd)) {
      cmdFunc = function () {
        editor.execCommand(cmd[0], cmd[1], cmd[2]);
      };
    }
    each$b(explode$2(Tools.trim(pattern.toLowerCase())), function (pattern) {
      var shortcut = createShortcut(pattern, desc, cmdFunc, scope);
      shortcuts[shortcut.id] = shortcut;
    });
    return true;
  };
  self.remove = function (pattern) {
    var shortcut = createShortcut(pattern);
    if (shortcuts[shortcut.id]) {
      delete shortcuts[shortcut.id];
      return true;
    }
    return false;
  };
}

var hasFocus = function (element) {
  var doc = owner(element).dom();
  return element.dom() === doc.activeElement;
};
var active = function (_doc) {
  var doc = _doc !== undefined ? _doc.dom() : document;
  return Option.from(doc.activeElement).map(Element$$1.fromDom);
};
var search = function (element) {
  return active(owner(element)).filter(function (e) {
    return element.dom().contains(e.dom());
  });
};

var getContentEditableHost = function (editor, node) {
  return editor.dom.getParent(node, function (node) {
    return editor.dom.getContentEditable(node) === &#39;true&#39;;
  });
};
var getCollapsedNode = function (rng) {
  return rng.collapsed ? Option.from(getNode(rng.startContainer, rng.startOffset)).map(Element$$1.fromDom) : Option.none();
};
var getFocusInElement = function (root, rng) {
  return getCollapsedNode(rng).bind(function (node) {
    if (isTableSection(node)) {
      return Option.some(node);
    } else if (contains$3(root, node) === false) {
      return Option.some(root);
    } else {
      return Option.none();
    }
  });
};
var normalizeSelection = function (editor, rng) {
  getFocusInElement(Element$$1.fromDom(editor.getBody()), rng).bind(function (elm) {
    return CaretFinder.firstPositionIn(elm.dom());
  }).fold(function () {
    editor.selection.normalize();
    return;
  }, function (caretPos) {
    return editor.selection.setRng(caretPos.toRange());
  });
};
var focusBody = function (body) {
  if (body.setActive) {
    try {
      body.setActive();
    } catch (ex) {
      body.focus();
    }
  } else {
    body.focus();
  }
};
var hasElementFocus = function (elm) {
  return hasFocus(elm) || search(elm).isSome();
};
var hasIframeFocus = function (editor) {
  return editor.iframeElement &amp;&amp; hasFocus(Element$$1.fromDom(editor.iframeElement));
};
var hasInlineFocus = function (editor) {
  var rawBody = editor.getBody();
  return rawBody &amp;&amp; hasElementFocus(Element$$1.fromDom(rawBody));
};
var hasFocus$1 = function (editor) {
  return editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
};
var focusEditor = function (editor) {
  var selection = editor.selection, contentEditable = editor.settings.content_editable;
  var body = editor.getBody();
  var rng = selection.getRng();
  editor.quirks.refreshContentEditable();
  var contentEditableHost = getContentEditableHost(editor, selection.getNode());
  if (editor.$.contains(body, contentEditableHost)) {
    focusBody(contentEditableHost);
    normalizeSelection(editor, rng);
    activateEditor(editor);
    return;
  }
  if (editor.bookmark !== undefined &amp;&amp; hasFocus$1(editor) === false) {
    SelectionBookmark.getRng(editor).each(function (bookmarkRng) {
      editor.selection.setRng(bookmarkRng);
      rng = bookmarkRng;
    });
  }
  if (!contentEditable) {
    if (!Env.opera) {
      focusBody(body);
    }
    editor.getWin().focus();
  }
  if (Env.gecko || contentEditable) {
    focusBody(body);
    normalizeSelection(editor, rng);
  }
  activateEditor(editor);
};
var activateEditor = function (editor) {
  return editor.editorManager.setActive(editor);
};
var focus$1 = function (editor, skipFocus) {
  if (editor.removed) {
    return;
  }
  skipFocus ? activateEditor(editor) : focusEditor(editor);
};
var EditorFocus = {
  focus: focus$1,
  hasFocus: hasFocus$1
};

var getProp = function (propName, elm) {
  var rawElm = elm.dom();
  return rawElm[propName];
};
var getComputedSizeProp = function (propName, elm) {
  return parseInt(get$2(elm, propName), 10);
};
var getClientWidth = curry(getProp, &#39;clientWidth&#39;);
var getClientHeight = curry(getProp, &#39;clientHeight&#39;);
var getMarginTop = curry(getComputedSizeProp, &#39;margin-top&#39;);
var getMarginLeft = curry(getComputedSizeProp, &#39;margin-left&#39;);
var getBoundingClientRect$1 = function (elm) {
  return elm.dom().getBoundingClientRect();
};
var isInsideElementContentArea = function (bodyElm, clientX, clientY) {
  var clientWidth = getClientWidth(bodyElm);
  var clientHeight = getClientHeight(bodyElm);
  return clientX &gt;= 0 &amp;&amp; clientY &gt;= 0 &amp;&amp; clientX &lt;= clientWidth &amp;&amp; clientY &lt;= clientHeight;
};
var transpose = function (inline, elm, clientX, clientY) {
  var clientRect = getBoundingClientRect$1(elm);
  var deltaX = inline ? clientRect.left + elm.dom().clientLeft + getMarginLeft(elm) : 0;
  var deltaY = inline ? clientRect.top + elm.dom().clientTop + getMarginTop(elm) : 0;
  var x = clientX - deltaX;
  var y = clientY - deltaY;
  return {
    x: x,
    y: y
  };
};
var isXYInContentArea = function (editor, clientX, clientY) {
  var bodyElm = Element$$1.fromDom(editor.getBody());
  var targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
  var transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
  return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
};
var fromDomSafe = function (node) {
  return Option.from(node).map(Element$$1.fromDom);
};
var isEditorAttachedToDom = function (editor) {
  var rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
  return fromDomSafe(rawContainer).map(function (container) {
    return contains$3(owner(container), container);
  }).getOr(false);
};
var EditorView = {
  isXYInContentArea: isXYInContentArea,
  isEditorAttachedToDom: isEditorAttachedToDom
};

function NotificationManagerImpl () {
  var unimplemented = function () {
    throw new Error(&#39;Theme did not provide a NotificationManager implementation.&#39;);
  };
  return {
    open: unimplemented,
    close: unimplemented,
    reposition: unimplemented,
    getArgs: unimplemented
  };
}

function NotificationManager (editor) {
  var notifications = [];
  var getImplementation = function () {
    var theme = editor.theme;
    return theme &amp;&amp; theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
  };
  var getTopNotification = function () {
    return Option.from(notifications[0]);
  };
  var isEqual = function (a, b) {
    return a.type === b.type &amp;&amp; a.text === b.text &amp;&amp; !a.progressBar &amp;&amp; !a.timeout &amp;&amp; !b.progressBar &amp;&amp; !b.timeout;
  };
  var reposition = function () {
    if (notifications.length &gt; 0) {
      getImplementation().reposition(notifications);
    }
  };
  var addNotification = function (notification) {
    notifications.push(notification);
  };
  var closeNotification = function (notification) {
    findIndex(notifications, function (otherNotification) {
      return otherNotification === notification;
    }).each(function (index) {
      notifications.splice(index, 1);
    });
  };
  var open = function (args) {
    if (editor.removed || !EditorView.isEditorAttachedToDom(editor)) {
      return;
    }
    return find(notifications, function (notification) {
      return isEqual(getImplementation().getArgs(notification), args);
    }).getOrThunk(function () {
      editor.editorManager.setActive(editor);
      var notification = getImplementation().open(args, function () {
        closeNotification(notification);
        reposition();
      });
      addNotification(notification);
      reposition();
      return notification;
    });
  };
  var close = function () {
    getTopNotification().each(function (notification) {
      getImplementation().close(notification);
      closeNotification(notification);
      reposition();
    });
  };
  var getNotifications = function () {
    return notifications;
  };
  var registerEvents = function (editor) {
    editor.on(&#39;SkinLoaded&#39;, function () {
      var serviceMessage = editor.settings.service_message;
      if (serviceMessage) {
        open({
          text: serviceMessage,
          type: &#39;warning&#39;,
          timeout: 0,
          icon: &#39;&#39;
        });
      }
    });
    editor.on(&#39;ResizeEditor ResizeWindow&#39;, function () {
      Delay.requestAnimationFrame(reposition);
    });
    editor.on(&#39;remove&#39;, function () {
      each(notifications.slice(), function (notification) {
        getImplementation().close(notification);
      });
    });
  };
  registerEvents(editor);
  return {
    open: open,
    close: close,
    getNotifications: getNotifications
  };
}

function WindowManagerImpl () {
  var unimplemented = function () {
    throw new Error(&#39;Theme did not provide a WindowManager implementation.&#39;);
  };
  return {
    open: unimplemented,
    alert: unimplemented,
    confirm: unimplemented,
    close: unimplemented,
    getParams: unimplemented,
    setParams: unimplemented
  };
}

function WindowManager (editor) {
  var windows = [];
  var getImplementation = function () {
    var theme = editor.theme;
    return theme &amp;&amp; theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
  };
  var funcBind = function (scope, f) {
    return function () {
      return f ? f.apply(scope, arguments) : undefined;
    };
  };
  var fireOpenEvent = function (win) {
    editor.fire(&#39;OpenWindow&#39;, { win: win });
  };
  var fireCloseEvent = function (win) {
    editor.fire(&#39;CloseWindow&#39;, { win: win });
  };
  var addWindow = function (win) {
    windows.push(win);
    fireOpenEvent(win);
  };
  var closeWindow = function (win) {
    findIndex(windows, function (otherWindow) {
      return otherWindow === win;
    }).each(function (index) {
      windows.splice(index, 1);
      fireCloseEvent(win);
      if (windows.length === 0) {
        editor.focus();
      }
    });
  };
  var getTopWindow = function () {
    return Option.from(windows[windows.length - 1]);
  };
  var open = function (args, params) {
    editor.editorManager.setActive(editor);
    SelectionBookmark.store(editor);
    var win = getImplementation().open(args, params, closeWindow);
    addWindow(win);
    return win;
  };
  var alert = function (message, callback, scope) {
    var win = getImplementation().alert(message, funcBind(scope ? scope : this, callback), closeWindow);
    addWindow(win);
  };
  var confirm = function (message, callback, scope) {
    var win = getImplementation().confirm(message, funcBind(scope ? scope : this, callback), closeWindow);
    addWindow(win);
  };
  var close = function () {
    getTopWindow().each(function (win) {
      getImplementation().close(win);
      closeWindow(win);
    });
  };
  var getParams = function () {
    return getTopWindow().map(getImplementation().getParams).getOr(null);
  };
  var setParams = function (params) {
    getTopWindow().each(function (win) {
      getImplementation().setParams(win, params);
    });
  };
  var getWindows = function () {
    return windows;
  };
  editor.on(&#39;remove&#39;, function () {
    each(windows.slice(0), function (win) {
      getImplementation().close(win);
    });
  });
  return {
    windows: windows,
    open: open,
    alert: alert,
    confirm: confirm,
    close: close,
    getParams: getParams,
    setParams: setParams,
    getWindows: getWindows
  };
}

var PluginManager = AddOnManager.PluginManager;
var resolvePluginName = function (targetUrl, suffix) {
  for (var name$$1 in PluginManager.urls) {
    var matchUrl = PluginManager.urls[name$$1] + &#39;/plugin&#39; + suffix + &#39;.js&#39;;
    if (matchUrl === targetUrl) {
      return name$$1;
    }
  }
  return null;
};
var pluginUrlToMessage = function (editor, url) {
  var plugin = resolvePluginName(url, editor.suffix);
  return plugin ? &#39;Failed to load plugin: &#39; + plugin + &#39; from url &#39; + url : &#39;Failed to load plugin url: &#39; + url;
};
var displayNotification = function (editor, message) {
  editor.notificationManager.open({
    type: &#39;error&#39;,
    text: message
  });
};
var displayError = function (editor, message) {
  if (editor._skinLoaded) {
    displayNotification(editor, message);
  } else {
    editor.on(&#39;SkinLoaded&#39;, function () {
      displayNotification(editor, message);
    });
  }
};
var uploadError = function (editor, message) {
  displayError(editor, &#39;Failed to upload image: &#39; + message);
};
var pluginLoadError = function (editor, url) {
  displayError(editor, pluginUrlToMessage(editor, url));
};
var initError = function (message) {
  var x = [];
  for (var _i = 1; _i &lt; arguments.length; _i++) {
    x[_i - 1] = arguments[_i];
  }
  var console$$1 = window.console;
  if (console$$1) {
    if (console$$1.error) {
      console$$1.error.apply(console$$1, arguments);
    } else {
      console$$1.log.apply(console$$1, arguments);
    }
  }
};
var ErrorReporter = {
  pluginLoadError: pluginLoadError,
  uploadError: uploadError,
  displayError: displayError,
  initError: initError
};

var PluginManager$1 = AddOnManager.PluginManager;

var ThemeManager = AddOnManager.ThemeManager;

function XMLHttpRequest () {
  var f = Global$1.getOrDie(&#39;XMLHttpRequest&#39;);
  return new f();
}

function Uploader (uploadStatus, settings) {
  var pendingPromises = {};
  var pathJoin = function (path1, path2) {
    if (path1) {
      return path1.replace(/\/$/, &#39;&#39;) + &#39;/&#39; + path2.replace(/^\//, &#39;&#39;);
    }
    return path2;
  };
  var defaultHandler = function (blobInfo, success, failure, progress) {
    var xhr, formData;
    xhr = XMLHttpRequest();
    xhr.open(&#39;POST&#39;, settings.url);
    xhr.withCredentials = settings.credentials;
    xhr.upload.onprogress = function (e) {
      progress(e.loaded / e.total * 100);
    };
    xhr.onerror = function () {
      failure(&#39;Image upload failed due to a XHR Transport error. Code: &#39; + xhr.status);
    };
    xhr.onload = function () {
      var json;
      if (xhr.status &lt; 200 || xhr.status &gt;= 300) {
        failure(&#39;HTTP Error: &#39; + xhr.status);
        return;
      }
      json = JSON.parse(xhr.responseText);
      if (!json || typeof json.location !== &#39;string&#39;) {
        failure(&#39;Invalid JSON: &#39; + xhr.responseText);
        return;
      }
      success(pathJoin(settings.basePath, json.location));
    };
    formData = new FormData();
    formData.append(&#39;file&#39;, blobInfo.blob(), blobInfo.filename());
    xhr.send(formData);
  };
  var noUpload = function () {
    return new promiseObj(function (resolve) {
      resolve([]);
    });
  };
  var handlerSuccess = function (blobInfo, url) {
    return {
      url: url,
      blobInfo: blobInfo,
      status: true
    };
  };
  var handlerFailure = function (blobInfo, error) {
    return {
      url: &#39;&#39;,
      blobInfo: blobInfo,
      status: false,
      error: error
    };
  };
  var resolvePending = function (blobUri, result) {
    Tools.each(pendingPromises[blobUri], function (resolve) {
      resolve(result);
    });
    delete pendingPromises[blobUri];
  };
  var uploadBlobInfo = function (blobInfo, handler, openNotification) {
    uploadStatus.markPending(blobInfo.blobUri());
    return new promiseObj(function (resolve) {
      var notification, progress;
      var noop = function () {
      };
      try {
        var closeNotification_1 = function () {
          if (notification) {
            notification.close();
            progress = noop;
          }
        };
        var success = function (url) {
          closeNotification_1();
          uploadStatus.markUploaded(blobInfo.blobUri(), url);
          resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
          resolve(handlerSuccess(blobInfo, url));
        };
        var failure = function (error) {
          closeNotification_1();
          uploadStatus.removeFailed(blobInfo.blobUri());
          resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));
          resolve(handlerFailure(blobInfo, error));
        };
        progress = function (percent) {
          if (percent &lt; 0 || percent &gt; 100) {
            return;
          }
          if (!notification) {
            notification = openNotification();
          }
          notification.progressBar.value(percent);
        };
        handler(blobInfo, success, failure, progress);
      } catch (ex) {
        resolve(handlerFailure(blobInfo, ex.message));
      }
    });
  };
  var isDefaultHandler = function (handler) {
    return handler === defaultHandler;
  };
  var pendingUploadBlobInfo = function (blobInfo) {
    var blobUri = blobInfo.blobUri();
    return new promiseObj(function (resolve) {
      pendingPromises[blobUri] = pendingPromises[blobUri] || [];
      pendingPromises[blobUri].push(resolve);
    });
  };
  var uploadBlobs = function (blobInfos, openNotification) {
    blobInfos = Tools.grep(blobInfos, function (blobInfo) {
      return !uploadStatus.isUploaded(blobInfo.blobUri());
    });
    return promiseObj.all(Tools.map(blobInfos, function (blobInfo) {
      return uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, settings.handler, openNotification);
    }));
  };
  var upload = function (blobInfos, openNotification) {
    return !settings.url &amp;&amp; isDefaultHandler(settings.handler) ? noUpload() : uploadBlobs(blobInfos, openNotification);
  };
  if (isFunction(settings.handler) === false) {
    settings.handler = defaultHandler;
  }
  return { upload: upload };
}

function FileReader () {
  var f = Global$1.getOrDie(&#39;FileReader&#39;);
  return new f();
}

function Uint8Array (arr) {
  var f = Global$1.getOrDie(&#39;Uint8Array&#39;);
  return new f(arr);
}

var requestAnimationFrame$1 = function (callback) {
  var f = Global$1.getOrDie(&#39;requestAnimationFrame&#39;);
  f(callback);
};
var atob = function (base64) {
  var f = Global$1.getOrDie(&#39;atob&#39;);
  return f(base64);
};
var Window = {
  atob: atob,
  requestAnimationFrame: requestAnimationFrame$1
};

var blobUriToBlob = function (url) {
  return new promiseObj(function (resolve, reject) {
    var rejectWithError = function () {
      reject(&#39;Cannot convert &#39; + url + &#39; to Blob. Resource might not exist or is inaccessible.&#39;);
    };
    try {
      var xhr = XMLHttpRequest();
      xhr.open(&#39;GET&#39;, url, true);
      xhr.responseType = &#39;blob&#39;;
      xhr.onload = function () {
        if (this.status === 200) {
          resolve(this.response);
        } else {
          rejectWithError();
        }
      };
      xhr.onerror = rejectWithError;
      xhr.send();
    } catch (ex) {
      rejectWithError();
    }
  });
};
var parseDataUri = function (uri) {
  var type, matches;
  var uriParts = decodeURIComponent(uri).split(&#39;,&#39;);
  matches = /data:([^;]+)/.exec(uriParts[0]);
  if (matches) {
    type = matches[1];
  }
  return {
    type: type,
    data: uriParts[1]
  };
};
var dataUriToBlob = function (uri) {
  return new promiseObj(function (resolve) {
    var str, arr, i;
    var uriParts = parseDataUri(uri);
    try {
      str = Window.atob(uriParts.data);
    } catch (e) {
      resolve(new Blob([]));
      return;
    }
    arr = Uint8Array(str.length);
    for (i = 0; i &lt; arr.length; i++) {
      arr[i] = str.charCodeAt(i);
    }
    resolve(new Blob([arr], { type: uriParts.type }));
  });
};
var uriToBlob = function (url) {
  if (url.indexOf(&#39;blob:&#39;) === 0) {
    return blobUriToBlob(url);
  }
  if (url.indexOf(&#39;data:&#39;) === 0) {
    return dataUriToBlob(url);
  }
  return null;
};
var blobToDataUri = function (blob) {
  return new promiseObj(function (resolve) {
    var reader = FileReader();
    reader.onloadend = function () {
      resolve(reader.result);
    };
    reader.readAsDataURL(blob);
  });
};
var Conversions = {
  uriToBlob: uriToBlob,
  blobToDataUri: blobToDataUri,
  parseDataUri: parseDataUri
};

var count = 0;
var uniqueId = function (prefix) {
  return (prefix || &#39;blobid&#39;) + count++;
};
var imageToBlobInfo = function (blobCache, img, resolve, reject) {
  var base64, blobInfo;
  if (img.src.indexOf(&#39;blob:&#39;) === 0) {
    blobInfo = blobCache.getByUri(img.src);
    if (blobInfo) {
      resolve({
        image: img,
        blobInfo: blobInfo
      });
    } else {
      Conversions.uriToBlob(img.src).then(function (blob) {
        Conversions.blobToDataUri(blob).then(function (dataUri) {
          base64 = Conversions.parseDataUri(dataUri).data;
          blobInfo = blobCache.create(uniqueId(), blob, base64);
          blobCache.add(blobInfo);
          resolve({
            image: img,
            blobInfo: blobInfo
          });
        });
      }, function (err) {
        reject(err);
      });
    }
    return;
  }
  base64 = Conversions.parseDataUri(img.src).data;
  blobInfo = blobCache.findFirst(function (cachedBlobInfo) {
    return cachedBlobInfo.base64() === base64;
  });
  if (blobInfo) {
    resolve({
      image: img,
      blobInfo: blobInfo
    });
  } else {
    Conversions.uriToBlob(img.src).then(function (blob) {
      blobInfo = blobCache.create(uniqueId(), blob, base64);
      blobCache.add(blobInfo);
      resolve({
        image: img,
        blobInfo: blobInfo
      });
    }, function (err) {
      reject(err);
    });
  }
};
var getAllImages = function (elm) {
  return elm ? from$1(elm.getElementsByTagName(&#39;img&#39;)) : [];
};
function ImageScanner (uploadStatus, blobCache) {
  var cachedPromises = {};
  var findAll = function (elm, predicate) {
    var images;
    if (!predicate) {
      predicate = constant(true);
    }
    images = filter(getAllImages(elm), function (img) {
      var src = img.src;
      if (!Env.fileApi) {
        return false;
      }
      if (img.hasAttribute(&#39;data-mce-bogus&#39;)) {
        return false;
      }
      if (img.hasAttribute(&#39;data-mce-placeholder&#39;)) {
        return false;
      }
      if (!src || src === Env.transparentSrc) {
        return false;
      }
      if (src.indexOf(&#39;blob:&#39;) === 0) {
        return !uploadStatus.isUploaded(src) &amp;&amp; predicate(img);
      }
      if (src.indexOf(&#39;data:&#39;) === 0) {
        return predicate(img);
      }
      return false;
    });
    var promises = map(images, function (img) {
      if (cachedPromises[img.src]) {
        return new promiseObj(function (resolve) {
          cachedPromises[img.src].then(function (imageInfo) {
            if (typeof imageInfo === &#39;string&#39;) {
              return imageInfo;
            }
            resolve({
              image: img,
              blobInfo: imageInfo.blobInfo
            });
          });
        });
      }
      var newPromise = new promiseObj(function (resolve, reject) {
        imageToBlobInfo(blobCache, img, resolve, reject);
      }).then(function (result) {
        delete cachedPromises[result.image.src];
        return result;
      }).catch(function (error) {
        delete cachedPromises[img.src];
        return error;
      });
      cachedPromises[img.src] = newPromise;
      return newPromise;
    });
    return promiseObj.all(promises);
  };
  return { findAll: findAll };
}

var count$1 = 0;
var seed = function () {
  var rnd = function () {
    return Math.round(Math.random() * 4294967295).toString(36);
  };
  var now = new Date().getTime();
  return &#39;s&#39; + now.toString(36) + rnd() + rnd() + rnd();
};
var uuid = function (prefix) {
  return prefix + count$1++ + seed();
};
var Uuid = { uuid: uuid };

function BlobCache () {
  var cache = [];
  var mimeToExt = function (mime) {
    var mimes = {
      &#39;image/jpeg&#39;: &#39;jpg&#39;,
      &#39;image/jpg&#39;: &#39;jpg&#39;,
      &#39;image/gif&#39;: &#39;gif&#39;,
      &#39;image/png&#39;: &#39;png&#39;
    };
    return mimes[mime.toLowerCase()] || &#39;dat&#39;;
  };
  var create = function (o, blob, base64, filename) {
    if (isString(o)) {
      var id = o;
      return toBlobInfo({
        id: id,
        name: filename,
        blob: blob,
        base64: base64
      });
    } else if (isObject(o)) {
      return toBlobInfo(o);
    } else {
      throw new Error(&#39;Unknown input type&#39;);
    }
  };
  var toBlobInfo = function (o) {
    var id, name;
    if (!o.blob || !o.base64) {
      throw new Error(&#39;blob and base64 representations of the image are required for BlobInfo to be created&#39;);
    }
    id = o.id || Uuid.uuid(&#39;blobid&#39;);
    name = o.name || id;
    return {
      id: constant(id),
      name: constant(name),
      filename: constant(name + &#39;.&#39; + mimeToExt(o.blob.type)),
      blob: constant(o.blob),
      base64: constant(o.base64),
      blobUri: constant(o.blobUri || URL.createObjectURL(o.blob)),
      uri: constant(o.uri)
    };
  };
  var add = function (blobInfo) {
    if (!get(blobInfo.id())) {
      cache.push(blobInfo);
    }
  };
  var get = function (id) {
    return findFirst(function (cachedBlobInfo) {
      return cachedBlobInfo.id() === id;
    });
  };
  var findFirst = function (predicate) {
    return filter(cache, predicate)[0];
  };
  var getByUri = function (blobUri) {
    return findFirst(function (blobInfo) {
      return blobInfo.blobUri() === blobUri;
    });
  };
  var removeByUri = function (blobUri) {
    cache = filter(cache, function (blobInfo) {
      if (blobInfo.blobUri() === blobUri) {
        URL.revokeObjectURL(blobInfo.blobUri());
        return false;
      }
      return true;
    });
  };
  var destroy = function () {
    each(cache, function (cachedBlobInfo) {
      URL.revokeObjectURL(cachedBlobInfo.blobUri());
    });
    cache = [];
  };
  return {
    create: create,
    add: add,
    get: get,
    getByUri: getByUri,
    findFirst: findFirst,
    removeByUri: removeByUri,
    destroy: destroy
  };
}

function UploadStatus () {
  var PENDING = 1, UPLOADED = 2;
  var blobUriStatuses = {};
  var createStatus = function (status, resultUri) {
    return {
      status: status,
      resultUri: resultUri
    };
  };
  var hasBlobUri = function (blobUri) {
    return blobUri in blobUriStatuses;
  };
  var getResultUri = function (blobUri) {
    var result = blobUriStatuses[blobUri];
    return result ? result.resultUri : null;
  };
  var isPending = function (blobUri) {
    return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
  };
  var isUploaded = function (blobUri) {
    return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
  };
  var markPending = function (blobUri) {
    blobUriStatuses[blobUri] = createStatus(PENDING, null);
  };
  var markUploaded = function (blobUri, resultUri) {
    blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
  };
  var removeFailed = function (blobUri) {
    delete blobUriStatuses[blobUri];
  };
  var destroy = function () {
    blobUriStatuses = {};
  };
  return {
    hasBlobUri: hasBlobUri,
    getResultUri: getResultUri,
    isPending: isPending,
    isUploaded: isUploaded,
    markPending: markPending,
    markUploaded: markUploaded,
    removeFailed: removeFailed,
    destroy: destroy
  };
}

function EditorUpload (editor) {
  var blobCache = BlobCache();
  var uploader, imageScanner;
  var uploadStatus = UploadStatus();
  var urlFilters = [];
  var aliveGuard = function (callback) {
    return function (result) {
      if (editor.selection) {
        return callback(result);
      }
      return [];
    };
  };
  var cacheInvalidator = function () {
    return &#39;?&#39; + new Date().getTime();
  };
  var replaceString = function (content, search, replace) {
    var index = 0;
    do {
      index = content.indexOf(search, index);
      if (index !== -1) {
        content = content.substring(0, index) + replace + content.substr(index + search.length);
        index += replace.length - search.length + 1;
      }
    } while (index !== -1);
    return content;
  };
  var replaceImageUrl = function (content, targetUrl, replacementUrl) {
    content = replaceString(content, &#39;src=&quot;&#39; + targetUrl + &#39;&quot;&#39;, &#39;src=&quot;&#39; + replacementUrl + &#39;&quot;&#39;);
    content = replaceString(content, &#39;data-mce-src=&quot;&#39; + targetUrl + &#39;&quot;&#39;, &#39;data-mce-src=&quot;&#39; + replacementUrl + &#39;&quot;&#39;);
    return content;
  };
  var replaceUrlInUndoStack = function (targetUrl, replacementUrl) {
    each(editor.undoManager.data, function (level) {
      if (level.type === &#39;fragmented&#39;) {
        level.fragments = map(level.fragments, function (fragment) {
          return replaceImageUrl(fragment, targetUrl, replacementUrl);
        });
      } else {
        level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
      }
    });
  };
  var openNotification = function () {
    return editor.notificationManager.open({
      text: editor.translate(&#39;Image uploading...&#39;),
      type: &#39;info&#39;,
      timeout: -1,
      progressBar: true
    });
  };
  var replaceImageUri = function (image, resultUri) {
    blobCache.removeByUri(image.src);
    replaceUrlInUndoStack(image.src, resultUri);
    editor.$(image).attr({
      &#39;src&#39;: Settings.shouldReuseFileName(editor) ? resultUri + cacheInvalidator() : resultUri,
      &#39;data-mce-src&#39;: editor.convertURL(resultUri, &#39;src&#39;)
    });
  };
  var uploadImages = function (callback) {
    if (!uploader) {
      uploader = Uploader(uploadStatus, {
        url: Settings.getImageUploadUrl(editor),
        basePath: Settings.getImageUploadBasePath(editor),
        credentials: Settings.getImagesUploadCredentials(editor),
        handler: Settings.getImagesUploadHandler(editor)
      });
    }
    return scanForImages().then(aliveGuard(function (imageInfos) {
      var blobInfos;
      blobInfos = map(imageInfos, function (imageInfo) {
        return imageInfo.blobInfo;
      });
      return uploader.upload(blobInfos, openNotification).then(aliveGuard(function (result) {
        var filteredResult = map(result, function (uploadInfo, index) {
          var image = imageInfos[index].image;
          if (uploadInfo.status &amp;&amp; Settings.shouldReplaceBlobUris(editor)) {
            replaceImageUri(image, uploadInfo.url);
          } else if (uploadInfo.error) {
            ErrorReporter.uploadError(editor, uploadInfo.error);
          }
          return {
            element: image,
            status: uploadInfo.status
          };
        });
        if (callback) {
          callback(filteredResult);
        }
        return filteredResult;
      }));
    }));
  };
  var uploadImagesAuto = function (callback) {
    if (Settings.isAutomaticUploadsEnabled(editor)) {
      return uploadImages(callback);
    }
  };
  var isValidDataUriImage = function (imgElm) {
    if (forall(urlFilters, function (filter$$1) {
        return filter$$1(imgElm);
      }) === false) {
      return false;
    }
    if (imgElm.getAttribute(&#39;src&#39;).indexOf(&#39;data:&#39;) === 0) {
      var dataImgFilter = Settings.getImagesDataImgFilter(editor);
      return dataImgFilter(imgElm);
    }
    return true;
  };
  var addFilter = function (filter$$1) {
    urlFilters.push(filter$$1);
  };
  var scanForImages = function () {
    if (!imageScanner) {
      imageScanner = ImageScanner(uploadStatus, blobCache);
    }
    return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(function (result) {
      result = filter(result, function (resultItem) {
        if (typeof resultItem === &#39;string&#39;) {
          ErrorReporter.displayError(editor, resultItem);
          return false;
        }
        return true;
      });
      each(result, function (resultItem) {
        replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
        resultItem.image.src = resultItem.blobInfo.blobUri();
        resultItem.image.removeAttribute(&#39;data-mce-src&#39;);
      });
      return result;
    }));
  };
  var destroy = function () {
    blobCache.destroy();
    uploadStatus.destroy();
    imageScanner = uploader = null;
  };
  var replaceBlobUris = function (content) {
    return content.replace(/src=&quot;(blob:[^&quot;]+)&quot;/g, function (match, blobUri) {
      var resultUri = uploadStatus.getResultUri(blobUri);
      if (resultUri) {
        return &#39;src=&quot;&#39; + resultUri + &#39;&quot;&#39;;
      }
      var blobInfo = blobCache.getByUri(blobUri);
      if (!blobInfo) {
        blobInfo = foldl(editor.editorManager.get(), function (result, editor) {
          return result || editor.editorUpload &amp;&amp; editor.editorUpload.blobCache.getByUri(blobUri);
        }, null);
      }
      if (blobInfo) {
        var blob = blobInfo.blob();
        return &#39;src=&quot;data:&#39; + blob.type + &#39;;base64,&#39; + blobInfo.base64() + &#39;&quot;&#39;;
      }
      return match;
    });
  };
  editor.on(&#39;setContent&#39;, function () {
    if (Settings.isAutomaticUploadsEnabled(editor)) {
      uploadImagesAuto();
    } else {
      scanForImages();
    }
  });
  editor.on(&#39;RawSaveContent&#39;, function (e) {
    e.content = replaceBlobUris(e.content);
  });
  editor.on(&#39;getContent&#39;, function (e) {
    if (e.source_view || e.format === &#39;raw&#39;) {
      return;
    }
    e.content = replaceBlobUris(e.content);
  });
  editor.on(&#39;PostRender&#39;, function () {
    editor.parser.addNodeFilter(&#39;img&#39;, function (images) {
      each(images, function (img) {
        var src = img.attr(&#39;src&#39;);
        if (blobCache.getByUri(src)) {
          return;
        }
        var resultUri = uploadStatus.getResultUri(src);
        if (resultUri) {
          img.attr(&#39;src&#39;, resultUri);
        }
      });
    });
  });
  return {
    blobCache: blobCache,
    addFilter: addFilter,
    uploadImages: uploadImages,
    uploadImagesAuto: uploadImagesAuto,
    scanForImages: scanForImages,
    destroy: destroy
  };
}

var isBlockElement = function (blockElements, node) {
  return blockElements.hasOwnProperty(node.nodeName);
};
var isValidTarget = function (blockElements, node) {
  if (NodeType.isText(node)) {
    return true;
  } else if (NodeType.isElement(node)) {
    return !isBlockElement(blockElements, node) &amp;&amp; !Bookmarks.isBookmarkNode(node);
  } else {
    return false;
  }
};
var hasBlockParent = function (blockElements, root, node) {
  return exists(Parents.parents(Element$$1.fromDom(node), Element$$1.fromDom(root)), function (elm) {
    return isBlockElement(blockElements, elm.dom());
  });
};
var shouldRemoveTextNode = function (blockElements, node) {
  if (NodeType.isText(node)) {
    if (node.nodeValue.length === 0) {
      return true;
    } else if (/^\s+$/.test(node.nodeValue) &amp;&amp; (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {
      return true;
    }
  }
  return false;
};
var addRootBlocks = function (editor) {
  var settings = editor.settings, dom = editor.dom, selection = editor.selection;
  var schema = editor.schema, blockElements = schema.getBlockElements();
  var node = selection.getStart();
  var rootNode = editor.getBody();
  var rng;
  var startContainer, startOffset, endContainer, endOffset, rootBlockNode;
  var tempNode, wrapped, restoreSelection;
  var rootNodeName, forcedRootBlock;
  forcedRootBlock = settings.forced_root_block;
  if (!node || !NodeType.isElement(node) || !forcedRootBlock) {
    return;
  }
  rootNodeName = rootNode.nodeName.toLowerCase();
  if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, node)) {
    return;
  }
  rng = selection.getRng();
  startContainer = rng.startContainer;
  startOffset = rng.startOffset;
  endContainer = rng.endContainer;
  endOffset = rng.endOffset;
  restoreSelection = EditorFocus.hasFocus(editor);
  node = rootNode.firstChild;
  while (node) {
    if (isValidTarget(blockElements, node)) {
      if (shouldRemoveTextNode(blockElements, node)) {
        tempNode = node;
        node = node.nextSibling;
        dom.remove(tempNode);
        continue;
      }
      if (!rootBlockNode) {
        rootBlockNode = dom.create(forcedRootBlock, editor.settings.forced_root_block_attrs);
        node.parentNode.insertBefore(rootBlockNode, node);
        wrapped = true;
      }
      tempNode = node;
      node = node.nextSibling;
      rootBlockNode.appendChild(tempNode);
    } else {
      rootBlockNode = null;
      node = node.nextSibling;
    }
  }
  if (wrapped &amp;&amp; restoreSelection) {
    rng.setStart(startContainer, startOffset);
    rng.setEnd(endContainer, endOffset);
    selection.setRng(rng);
    editor.nodeChanged();
  }
};
var setup$2 = function (editor) {
  if (editor.settings.forced_root_block) {
    editor.on(&#39;NodeChange&#39;, curry(addRootBlocks, editor));
  }
};
var ForceBlocks = { setup: setup$2 };

var getStartNode = function (rng) {
  var sc = rng.startContainer, so = rng.startOffset;
  if (NodeType.isText(sc)) {
    return so === 0 ? Option.some(Element$$1.fromDom(sc)) : Option.none();
  } else {
    return Option.from(sc.childNodes[so]).map(Element$$1.fromDom);
  }
};
var getEndNode = function (rng) {
  var ec = rng.endContainer, eo = rng.endOffset;
  if (NodeType.isText(ec)) {
    return eo === ec.data.length ? Option.some(Element$$1.fromDom(ec)) : Option.none();
  } else {
    return Option.from(ec.childNodes[eo - 1]).map(Element$$1.fromDom);
  }
};
var getFirstChildren = function (node) {
  return firstChild(node).fold(constant([node]), function (child$$1) {
    return [node].concat(getFirstChildren(child$$1));
  });
};
var getLastChildren$1 = function (node) {
  return lastChild(node).fold(constant([node]), function (child$$1) {
    if (name(child$$1) === &#39;br&#39;) {
      return prevSibling(child$$1).map(function (sibling) {
        return [node].concat(getLastChildren$1(sibling));
      }).getOr([]);
    } else {
      return [node].concat(getLastChildren$1(child$$1));
    }
  });
};
var hasAllContentsSelected = function (elm, rng) {
  return liftN([
    getStartNode(rng),
    getEndNode(rng)
  ], function (startNode, endNode) {
    var start = find(getFirstChildren(elm), curry(eq, startNode));
    var end = find(getLastChildren$1(elm), curry(eq, endNode));
    return start.isSome() &amp;&amp; end.isSome();
  }).getOr(false);
};
var moveEndPoint$1 = function (dom, rng, node, start) {
  var root = node, walker = new TreeWalker(node, root);
  var nonEmptyElementsMap = dom.schema.getNonEmptyElements();
  do {
    if (node.nodeType === 3 &amp;&amp; Tools.trim(node.nodeValue).length !== 0) {
      if (start) {
        rng.setStart(node, 0);
      } else {
        rng.setEnd(node, node.nodeValue.length);
      }
      return;
    }
    if (nonEmptyElementsMap[node.nodeName] &amp;&amp; !/^(TD|TH)$/.test(node.nodeName)) {
      if (start) {
        rng.setStartBefore(node);
      } else {
        if (node.nodeName === &#39;BR&#39;) {
          rng.setEndBefore(node);
        } else {
          rng.setEndAfter(node);
        }
      }
      return;
    }
    if (Env.ie &amp;&amp; Env.ie &lt; 11 &amp;&amp; dom.isBlock(node) &amp;&amp; dom.isEmpty(node)) {
      if (start) {
        rng.setStart(node, 0);
      } else {
        rng.setEnd(node, 0);
      }
      return;
    }
  } while (node = start ? walker.next() : walker.prev());
  if (root.nodeName === &#39;BODY&#39;) {
    if (start) {
      rng.setStart(root, 0);
    } else {
      rng.setEnd(root, root.childNodes.length);
    }
  }
};
var hasAnyRanges = function (editor) {
  var sel = editor.selection.getSel();
  return sel &amp;&amp; sel.rangeCount &gt; 0;
};

function NodeChange (editor) {
  var lastRng, lastPath = [];
  var isSameElementPath = function (startElm) {
    var i, currentPath;
    currentPath = editor.$(startElm).parentsUntil(editor.getBody()).add(startElm);
    if (currentPath.length === lastPath.length) {
      for (i = currentPath.length; i &gt;= 0; i--) {
        if (currentPath[i] !== lastPath[i]) {
          break;
        }
      }
      if (i === -1) {
        lastPath = currentPath;
        return true;
      }
    }
    lastPath = currentPath;
    return false;
  };
  if (!(&#39;onselectionchange&#39; in editor.getDoc())) {
    editor.on(&#39;NodeChange Click MouseUp KeyUp Focus&#39;, function (e) {
      var nativeRng, fakeRng;
      nativeRng = editor.selection.getRng();
      fakeRng = {
        startContainer: nativeRng.startContainer,
        startOffset: nativeRng.startOffset,
        endContainer: nativeRng.endContainer,
        endOffset: nativeRng.endOffset
      };
      if (e.type === &#39;nodechange&#39; || !RangeCompare.isEq(fakeRng, lastRng)) {
        editor.fire(&#39;SelectionChange&#39;);
      }
      lastRng = fakeRng;
    });
  }
  editor.on(&#39;contextmenu&#39;, function () {
    editor.fire(&#39;SelectionChange&#39;);
  });
  editor.on(&#39;SelectionChange&#39;, function () {
    var startElm = editor.selection.getStart(true);
    if (!startElm || !Env.range &amp;&amp; editor.selection.isCollapsed()) {
      return;
    }
    if (hasAnyRanges(editor) &amp;&amp; !isSameElementPath(startElm) &amp;&amp; editor.dom.isChildOf(startElm, editor.getBody())) {
      editor.nodeChanged({ selectionChange: true });
    }
  });
  editor.on(&#39;MouseUp&#39;, function (e) {
    if (!e.isDefaultPrevented() &amp;&amp; hasAnyRanges(editor)) {
      if (editor.selection.getNode().nodeName === &#39;IMG&#39;) {
        Delay.setEditorTimeout(editor, function () {
          editor.nodeChanged();
        });
      } else {
        editor.nodeChanged();
      }
    }
  });
  this.nodeChanged = function (args) {
    var selection = editor.selection;
    var node, parents, root;
    if (editor.initialized &amp;&amp; selection &amp;&amp; !editor.settings.disable_nodechange &amp;&amp; !editor.readonly) {
      root = editor.getBody();
      node = selection.getStart(true) || root;
      if (node.ownerDocument !== editor.getDoc() || !editor.dom.isChildOf(node, root)) {
        node = root;
      }
      parents = [];
      editor.dom.getParent(node, function (node) {
        if (node === root) {
          return true;
        }
        parents.push(node);
      });
      args = args || {};
      args.element = node;
      args.parents = parents;
      editor.fire(&#39;NodeChange&#39;, args);
    }
  };
}

var getAbsolutePosition = function (elm) {
  var doc, docElem, win, clientRect;
  clientRect = elm.getBoundingClientRect();
  doc = elm.ownerDocument;
  docElem = doc.documentElement;
  win = doc.defaultView;
  return {
    top: clientRect.top + win.pageYOffset - docElem.clientTop,
    left: clientRect.left + win.pageXOffset - docElem.clientLeft
  };
};
var getBodyPosition = function (editor) {
  return editor.inline ? getAbsolutePosition(editor.getBody()) : {
    left: 0,
    top: 0
  };
};
var getScrollPosition = function (editor) {
  var body = editor.getBody();
  return editor.inline ? {
    left: body.scrollLeft,
    top: body.scrollTop
  } : {
    left: 0,
    top: 0
  };
};
var getBodyScroll = function (editor) {
  var body = editor.getBody(), docElm = editor.getDoc().documentElement;
  var inlineScroll = {
    left: body.scrollLeft,
    top: body.scrollTop
  };
  var iframeScroll = {
    left: body.scrollLeft || docElm.scrollLeft,
    top: body.scrollTop || docElm.scrollTop
  };
  return editor.inline ? inlineScroll : iframeScroll;
};
var getMousePosition = function (editor, event) {
  if (event.target.ownerDocument !== editor.getDoc()) {
    var iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
    var scrollPosition = getBodyScroll(editor);
    return {
      left: event.pageX - iframePosition.left + scrollPosition.left,
      top: event.pageY - iframePosition.top + scrollPosition.top
    };
  }
  return {
    left: event.pageX,
    top: event.pageY
  };
};
var calculatePosition = function (bodyPosition, scrollPosition, mousePosition) {
  return {
    pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
    pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
  };
};
var calc = function (editor, event) {
  return calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
};
var MousePosition = { calc: calc };

var isContentEditableFalse$6 = NodeType.isContentEditableFalse, isContentEditableTrue$3 = NodeType.isContentEditableTrue;
var isDraggable = function (rootElm, elm) {
  return isContentEditableFalse$6(elm) &amp;&amp; elm !== rootElm;
};
var isValidDropTarget = function (editor, targetElement, dragElement) {
  if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
    return false;
  }
  if (isContentEditableFalse$6(targetElement)) {
    return false;
  }
  return true;
};
var cloneElement = function (elm) {
  var cloneElm = elm.cloneNode(true);
  cloneElm.removeAttribute(&#39;data-mce-selected&#39;);
  return cloneElm;
};
var createGhost = function (editor, elm, width, height) {
  var clonedElm = elm.cloneNode(true);
  editor.dom.setStyles(clonedElm, {
    width: width,
    height: height
  });
  editor.dom.setAttrib(clonedElm, &#39;data-mce-selected&#39;, null);
  var ghostElm = editor.dom.create(&#39;div&#39;, {
    &#39;class&#39;: &#39;mce-drag-container&#39;,
    &#39;data-mce-bogus&#39;: &#39;all&#39;,
    &#39;unselectable&#39;: &#39;on&#39;,
    &#39;contenteditable&#39;: &#39;false&#39;
  });
  editor.dom.setStyles(ghostElm, {
    position: &#39;absolute&#39;,
    opacity: 0.5,
    overflow: &#39;hidden&#39;,
    border: 0,
    padding: 0,
    margin: 0,
    width: width,
    height: height
  });
  editor.dom.setStyles(clonedElm, {
    margin: 0,
    boxSizing: &#39;border-box&#39;
  });
  ghostElm.appendChild(clonedElm);
  return ghostElm;
};
var appendGhostToBody = function (ghostElm, bodyElm) {
  if (ghostElm.parentNode !== bodyElm) {
    bodyElm.appendChild(ghostElm);
  }
};
var moveGhost = function (ghostElm, position, width, height, maxX, maxY) {
  var overflowX = 0, overflowY = 0;
  ghostElm.style.left = position.pageX + &#39;px&#39;;
  ghostElm.style.top = position.pageY + &#39;px&#39;;
  if (position.pageX + width &gt; maxX) {
    overflowX = position.pageX + width - maxX;
  }
  if (position.pageY + height &gt; maxY) {
    overflowY = position.pageY + height - maxY;
  }
  ghostElm.style.width = width - overflowX + &#39;px&#39;;
  ghostElm.style.height = height - overflowY + &#39;px&#39;;
};
var removeElement = function (elm) {
  if (elm &amp;&amp; elm.parentNode) {
    elm.parentNode.removeChild(elm);
  }
};
var isLeftMouseButtonPressed = function (e) {
  return e.button === 0;
};
var hasDraggableElement = function (state) {
  return state.element;
};
var applyRelPos = function (state, position) {
  return {
    pageX: position.pageX - state.relX,
    pageY: position.pageY + 5
  };
};
var start$1 = function (state, editor) {
  return function (e) {
    if (isLeftMouseButtonPressed(e)) {
      var ceElm = find(editor.dom.getParents(e.target), Predicate.or(isContentEditableFalse$6, isContentEditableTrue$3)).getOr(null);
      if (isDraggable(editor.getBody(), ceElm)) {
        var elmPos = editor.dom.getPos(ceElm);
        var bodyElm = editor.getBody();
        var docElm = editor.getDoc().documentElement;
        state.element = ceElm;
        state.screenX = e.screenX;
        state.screenY = e.screenY;
        state.maxX = (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2;
        state.maxY = (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2;
        state.relX = e.pageX - elmPos.x;
        state.relY = e.pageY - elmPos.y;
        state.width = ceElm.offsetWidth;
        state.height = ceElm.offsetHeight;
        state.ghost = createGhost(editor, ceElm, state.width, state.height);
      }
    }
  };
};
var move$1 = function (state, editor) {
  var throttledPlaceCaretAt = Delay.throttle(function (clientX, clientY) {
    editor._selectionOverrides.hideFakeCaret();
    editor.selection.placeCaretAt(clientX, clientY);
  }, 0);
  return function (e) {
    var movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));
    if (hasDraggableElement(state) &amp;&amp; !state.dragging &amp;&amp; movement &gt; 10) {
      var args = editor.fire(&#39;dragstart&#39;, { target: state.element });
      if (args.isDefaultPrevented()) {
        return;
      }
      state.dragging = true;
      editor.focus();
    }
    if (state.dragging) {
      var targetPos = applyRelPos(state, MousePosition.calc(editor, e));
      appendGhostToBody(state.ghost, editor.getBody());
      moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY);
      throttledPlaceCaretAt(e.clientX, e.clientY);
    }
  };
};
var getRawTarget = function (selection) {
  var rng = selection.getSel().getRangeAt(0);
  var startContainer = rng.startContainer;
  return startContainer.nodeType === 3 ? startContainer.parentNode : startContainer;
};
var drop = function (state, editor) {
  return function (e) {
    if (state.dragging) {
      if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {
        var targetClone_1 = cloneElement(state.element);
        var args = editor.fire(&#39;drop&#39;, {
          targetClone: targetClone_1,
          clientX: e.clientX,
          clientY: e.clientY
        });
        if (!args.isDefaultPrevented()) {
          targetClone_1 = args.targetClone;
          editor.undoManager.transact(function () {
            removeElement(state.element);
            editor.insertContent(editor.dom.getOuterHTML(targetClone_1));
            editor._selectionOverrides.hideFakeCaret();
          });
        }
      }
    }
    removeDragState(state);
  };
};
var stop$$1 = function (state, editor) {
  return function () {
    if (state.dragging) {
      editor.fire(&#39;dragend&#39;);
    }
    removeDragState(state);
  };
};
var removeDragState = function (state) {
  state.dragging = false;
  state.element = null;
  removeElement(state.ghost);
};
var bindFakeDragEvents = function (editor) {
  var state = {};
  var pageDom, dragStartHandler, dragHandler, dropHandler, dragEndHandler, rootDocument;
  pageDom = DOMUtils$1.DOM;
  rootDocument = document;
  dragStartHandler = start$1(state, editor);
  dragHandler = move$1(state, editor);
  dropHandler = drop(state, editor);
  dragEndHandler = stop$$1(state, editor);
  editor.on(&#39;mousedown&#39;, dragStartHandler);
  editor.on(&#39;mousemove&#39;, dragHandler);
  editor.on(&#39;mouseup&#39;, dropHandler);
  pageDom.bind(rootDocument, &#39;mousemove&#39;, dragHandler);
  pageDom.bind(rootDocument, &#39;mouseup&#39;, dragEndHandler);
  editor.on(&#39;remove&#39;, function () {
    pageDom.unbind(rootDocument, &#39;mousemove&#39;, dragHandler);
    pageDom.unbind(rootDocument, &#39;mouseup&#39;, dragEndHandler);
  });
};
var blockIeDrop = function (editor) {
  editor.on(&#39;drop&#39;, function (e) {
    var realTarget = typeof e.clientX !== &#39;undefined&#39; ? editor.getDoc().elementFromPoint(e.clientX, e.clientY) : null;
    if (isContentEditableFalse$6(realTarget) || isContentEditableFalse$6(editor.dom.getContentEditableParent(realTarget))) {
      e.preventDefault();
    }
  });
};
var init = function (editor) {
  bindFakeDragEvents(editor);
  blockIeDrop(editor);
};
var DragDropOverrides = { init: init };

var getNodeClientRects = function (node) {
  var toArrayWithNode = function (clientRects) {
    return map(clientRects, function (clientRect) {
      clientRect = clone$2(clientRect);
      clientRect.node = node;
      return clientRect;
    });
  };
  if (NodeType.isElement(node)) {
    return toArrayWithNode(node.getClientRects());
  }
  if (NodeType.isText(node)) {
    var rng = node.ownerDocument.createRange();
    rng.setStart(node, 0);
    rng.setEnd(node, node.data.length);
    return toArrayWithNode(rng.getClientRects());
  }
};
var getClientRects = function (node) {
  return foldl(node, function (result, node) {
    return result.concat(getNodeClientRects(node));
  }, []);
};

var VDirection;
(function (VDirection) {
  VDirection[VDirection[&#39;Up&#39;] = -1] = &#39;Up&#39;;
  VDirection[VDirection[&#39;Down&#39;] = 1] = &#39;Down&#39;;
}(VDirection || (VDirection = {})));
var findUntil = function (direction, root, predicateFn, node) {
  while (node = findNode(node, direction, isEditableCaretCandidate, root)) {
    if (predicateFn(node)) {
      return;
    }
  }
};
var walkUntil = function (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) {
  var line = 0, node;
  var result = [];
  var targetClientRect;
  var add = function (node) {
    var i, clientRect, clientRects;
    clientRects = getClientRects([node]);
    if (direction === -1) {
      clientRects = clientRects.reverse();
    }
    for (i = 0; i &lt; clientRects.length; i++) {
      clientRect = clientRects[i];
      if (isBeflowFn(clientRect, targetClientRect)) {
        continue;
      }
      if (result.length &gt; 0 &amp;&amp; isAboveFn(clientRect, ArrUtils.last(result))) {
        line++;
      }
      clientRect.line = line;
      if (predicateFn(clientRect)) {
        return true;
      }
      result.push(clientRect);
    }
  };
  targetClientRect = ArrUtils.last(caretPosition.getClientRects());
  if (!targetClientRect) {
    return result;
  }
  node = caretPosition.getNode();
  add(node);
  findUntil(direction, root, add, node);
  return result;
};
var aboveLineNumber = function (lineNumber, clientRect) {
  return clientRect.line &gt; lineNumber;
};
var isLineNumber = function (lineNumber, clientRect) {
  return clientRect.line === lineNumber;
};
var upUntil = curry(walkUntil, VDirection.Up, isAbove, isBelow);
var downUntil = curry(walkUntil, VDirection.Down, isBelow, isAbove);
var positionsUntil = function (direction, root, predicateFn, node) {
  var caretWalker = CaretWalker(root);
  var walkFn, isBelowFn, isAboveFn, caretPosition;
  var result = [];
  var line = 0, clientRect, targetClientRect;
  var getClientRect = function (caretPosition) {
    if (direction === 1) {
      return ArrUtils.last(caretPosition.getClientRects());
    }
    return ArrUtils.last(caretPosition.getClientRects());
  };
  if (direction === 1) {
    walkFn = caretWalker.next;
    isBelowFn = isBelow;
    isAboveFn = isAbove;
    caretPosition = CaretPosition$1.after(node);
  } else {
    walkFn = caretWalker.prev;
    isBelowFn = isAbove;
    isAboveFn = isBelow;
    caretPosition = CaretPosition$1.before(node);
  }
  targetClientRect = getClientRect(caretPosition);
  do {
    if (!caretPosition.isVisible()) {
      continue;
    }
    clientRect = getClientRect(caretPosition);
    if (isAboveFn(clientRect, targetClientRect)) {
      continue;
    }
    if (result.length &gt; 0 &amp;&amp; isBelowFn(clientRect, ArrUtils.last(result))) {
      line++;
    }
    clientRect = clone$2(clientRect);
    clientRect.position = caretPosition;
    clientRect.line = line;
    if (predicateFn(clientRect)) {
      return result;
    }
    result.push(clientRect);
  } while (caretPosition = walkFn(caretPosition));
  return result;
};
var isAboveLine = function (lineNumber) {
  return function (clientRect) {
    return aboveLineNumber(lineNumber, clientRect);
  };
};
var isLine = function (lineNumber) {
  return function (clientRect) {
    return isLineNumber(lineNumber, clientRect);
  };
};

var isContentEditableFalse$7 = NodeType.isContentEditableFalse;
var findNode$1 = findNode;
var distanceToRectLeft = function (clientRect, clientX) {
  return Math.abs(clientRect.left - clientX);
};
var distanceToRectRight = function (clientRect, clientX) {
  return Math.abs(clientRect.right - clientX);
};
var isInside = function (clientX, clientRect) {
  return clientX &gt;= clientRect.left &amp;&amp; clientX &lt;= clientRect.right;
};
var findClosestClientRect = function (clientRects, clientX) {
  return ArrUtils.reduce(clientRects, function (oldClientRect, clientRect) {
    var oldDistance, newDistance;
    oldDistance = Math.min(distanceToRectLeft(oldClientRect, clientX), distanceToRectRight(oldClientRect, clientX));
    newDistance = Math.min(distanceToRectLeft(clientRect, clientX), distanceToRectRight(clientRect, clientX));
    if (isInside(clientX, clientRect)) {
      return clientRect;
    }
    if (isInside(clientX, oldClientRect)) {
      return oldClientRect;
    }
    if (newDistance === oldDistance &amp;&amp; isContentEditableFalse$7(clientRect.node)) {
      return clientRect;
    }
    if (newDistance &lt; oldDistance) {
      return clientRect;
    }
    return oldClientRect;
  });
};
var walkUntil$1 = function (direction, root, predicateFn, node) {
  while (node = findNode$1(node, direction, isEditableCaretCandidate, root)) {
    if (predicateFn(node)) {
      return;
    }
  }
};
var findLineNodeRects = function (root, targetNodeRect) {
  var clientRects = [];
  var collect = function (checkPosFn, node) {
    var lineRects;
    lineRects = filter(getClientRects([node]), function (clientRect) {
      return !checkPosFn(clientRect, targetNodeRect);
    });
    clientRects = clientRects.concat(lineRects);
    return lineRects.length === 0;
  };
  clientRects.push(targetNodeRect);
  walkUntil$1(VDirection.Up, root, curry(collect, isAbove), targetNodeRect.node);
  walkUntil$1(VDirection.Down, root, curry(collect, isBelow), targetNodeRect.node);
  return clientRects;
};
var getFakeCaretTargets = function (root) {
  return filter(from$1(root.getElementsByTagName(&#39;*&#39;)), isFakeCaretTarget);
};
var caretInfo = function (clientRect, clientX) {
  return {
    node: clientRect.node,
    before: distanceToRectLeft(clientRect, clientX) &lt; distanceToRectRight(clientRect, clientX)
  };
};
var closestCaret = function (root, clientX, clientY) {
  var closestNodeRect;
  var contentEditableFalseNodeRects = getClientRects(getFakeCaretTargets(root));
  var targetNodeRects = filter(contentEditableFalseNodeRects, function (rect) {
    return clientY &gt;= rect.top &amp;&amp; clientY &lt;= rect.bottom;
  });
  closestNodeRect = findClosestClientRect(targetNodeRects, clientX);
  if (closestNodeRect) {
    closestNodeRect = findClosestClientRect(findLineNodeRects(root, closestNodeRect), clientX);
    if (closestNodeRect &amp;&amp; isFakeCaretTarget(closestNodeRect.node)) {
      return caretInfo(closestNodeRect, clientX);
    }
  }
  return null;
};

var isXYWithinRange = function (clientX, clientY, range$$1) {
  if (range$$1.collapsed) {
    return false;
  }
  return foldl(range$$1.getClientRects(), function (state, rect) {
    return state || containsXY(rect, clientX, clientY);
  }, false);
};
var RangePoint = { isXYWithinRange: isXYWithinRange };

var isContentEditableTrue$4 = NodeType.isContentEditableTrue;
var isContentEditableFalse$8 = NodeType.isContentEditableFalse;
var showCaret = function (direction, editor, node, before, scrollIntoView) {
  return editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView);
};
var getNodeRange = function (node) {
  var rng = node.ownerDocument.createRange();
  rng.selectNode(node);
  return rng;
};
var selectNode = function (editor, node) {
  var e = editor.fire(&#39;BeforeObjectSelected&#39;, { target: node });
  if (e.isDefaultPrevented()) {
    return null;
  }
  return getNodeRange(node);
};
var renderCaretAtRange = function (editor, range, scrollIntoView) {
  var normalizedRange = normalizeRange(1, editor.getBody(), range);
  var caretPosition = CaretPosition$1.fromRangeStart(normalizedRange);
  var caretPositionNode = caretPosition.getNode();
  if (isContentEditableFalse$8(caretPositionNode)) {
    return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
  }
  var caretPositionBeforeNode = caretPosition.getNode(true);
  if (isContentEditableFalse$8(caretPositionBeforeNode)) {
    return showCaret(1, editor, caretPositionBeforeNode, false, false);
  }
  var ceRoot = editor.dom.getParent(caretPosition.getNode(), function (node) {
    return isContentEditableFalse$8(node) || isContentEditableTrue$4(node);
  });
  if (isContentEditableFalse$8(ceRoot)) {
    return showCaret(1, editor, ceRoot, false, scrollIntoView);
  }
  return null;
};
var renderRangeCaret = function (editor, range, scrollIntoView) {
  if (!range || !range.collapsed) {
    return range;
  }
  var caretRange = renderCaretAtRange(editor, range, scrollIntoView);
  if (caretRange) {
    return caretRange;
  }
  return range;
};

var setup$3 = function (editor) {
  var renderFocusCaret = first$1(function () {
    if (!editor.removed) {
      var rng = editor.selection.getRng();
      if (rng.collapsed) {
        var caretRange = renderRangeCaret(editor, editor.selection.getRng(), false);
        editor.selection.setRng(caretRange);
      }
    }
  }, 0);
  editor.on(&#39;focus&#39;, function () {
    renderFocusCaret.throttle();
  });
  editor.on(&#39;blur&#39;, function () {
    renderFocusCaret.cancel();
  });
};
var CefFocus = { setup: setup$3 };

var VK = {
  BACKSPACE: 8,
  DELETE: 46,
  DOWN: 40,
  ENTER: 13,
  LEFT: 37,
  RIGHT: 39,
  SPACEBAR: 32,
  TAB: 9,
  UP: 38,
  modifierPressed: function (e) {
    return e.shiftKey || e.ctrlKey || e.altKey || this.metaKeyPressed(e);
  },
  metaKeyPressed: function (e) {
    return Env.mac ? e.metaKey : e.ctrlKey &amp;&amp; !e.altKey;
  }
};

var isContentEditableTrue$5 = NodeType.isContentEditableTrue;
var isContentEditableFalse$9 = NodeType.isContentEditableFalse;
var isAfterContentEditableFalse$1 = isAfterContentEditableFalse;
var isBeforeContentEditableFalse$1 = isBeforeContentEditableFalse;
var getContentEditableRoot$1 = function (editor, node) {
  var root = editor.getBody();
  while (node &amp;&amp; node !== root) {
    if (isContentEditableTrue$5(node) || isContentEditableFalse$9(node)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
};
var SelectionOverrides = function (editor) {
  var isBlock = function (node) {
    return editor.dom.isBlock(node);
  };
  var rootNode = editor.getBody();
  var fakeCaret = FakeCaret(editor.getBody(), isBlock, function () {
    return EditorFocus.hasFocus(editor);
  });
  var realSelectionId = &#39;sel-&#39; + editor.dom.uniqueId();
  var selectedContentEditableNode;
  var isFakeSelectionElement = function (elm) {
    return editor.dom.hasClass(elm, &#39;mce-offscreen-selection&#39;);
  };
  var getRealSelectionElement = function () {
    var container = editor.dom.get(realSelectionId);
    return container ? container.getElementsByTagName(&#39;*&#39;)[0] : container;
  };
  var setRange = function (range$$1) {
    if (range$$1) {
      editor.selection.setRng(range$$1);
    }
  };
  var getRange = function () {
    return editor.selection.getRng();
  };
  var showCaret$$1 = function (direction, node, before, scrollIntoView) {
    if (scrollIntoView === void 0) {
      scrollIntoView = true;
    }
    var e;
    e = editor.fire(&#39;ShowCaret&#39;, {
      target: node,
      direction: direction,
      before: before
    });
    if (e.isDefaultPrevented()) {
      return null;
    }
    if (scrollIntoView) {
      editor.selection.scrollIntoView(node, direction === -1);
    }
    return fakeCaret.show(before, node);
  };
  var getNormalizedRangeEndPoint$$1 = function (direction, range$$1) {
    range$$1 = normalizeRange(direction, rootNode, range$$1);
    if (direction === -1) {
      return CaretPosition$1.fromRangeStart(range$$1);
    }
    return CaretPosition$1.fromRangeEnd(range$$1);
  };
  var showBlockCaretContainer = function (blockCaretContainer) {
    if (blockCaretContainer.hasAttribute(&#39;data-mce-caret&#39;)) {
      showCaretContainerBlock(blockCaretContainer);
      setRange(getRange());
      editor.selection.scrollIntoView(blockCaretContainer[0]);
    }
  };
  var registerEvents = function () {
    editor.on(&#39;mouseup&#39;, function (e) {
      var range$$1 = getRange();
      if (range$$1.collapsed &amp;&amp; EditorView.isXYInContentArea(editor, e.clientX, e.clientY)) {
        setRange(renderCaretAtRange(editor, range$$1, false));
      }
    });
    editor.on(&#39;click&#39;, function (e) {
      var contentEditableRoot;
      contentEditableRoot = getContentEditableRoot$1(editor, e.target);
      if (contentEditableRoot) {
        if (isContentEditableFalse$9(contentEditableRoot)) {
          e.preventDefault();
          editor.focus();
        }
        if (isContentEditableTrue$5(contentEditableRoot)) {
          if (editor.dom.isChildOf(contentEditableRoot, editor.selection.getNode())) {
            removeContentEditableSelection();
          }
        }
      }
    });
    editor.on(&#39;blur NewBlock&#39;, function () {
      removeContentEditableSelection();
    });
    editor.on(&#39;ResizeWindow FullscreenStateChanged&#39;, function () {
      return fakeCaret.reposition();
    });
    var handleTouchSelect = function (editor) {
      var moved = false;
      editor.on(&#39;touchstart&#39;, function () {
        moved = false;
      });
      editor.on(&#39;touchmove&#39;, function () {
        moved = true;
      });
      editor.on(&#39;touchend&#39;, function (e) {
        var contentEditableRoot = getContentEditableRoot$1(editor, e.target);
        if (isContentEditableFalse$9(contentEditableRoot)) {
          if (!moved) {
            e.preventDefault();
            setContentEditableSelection(selectNode(editor, contentEditableRoot));
          }
        }
      });
    };
    var hasNormalCaretPosition = function (elm) {
      var caretWalker = CaretWalker(elm);
      if (!elm.firstChild) {
        return false;
      }
      var startPos = CaretPosition$1.before(elm.firstChild);
      var newPos = caretWalker.next(startPos);
      return newPos &amp;&amp; !isBeforeContentEditableFalse$1(newPos) &amp;&amp; !isAfterContentEditableFalse$1(newPos);
    };
    var isInSameBlock$$1 = function (node1, node2) {
      var block1 = editor.dom.getParent(node1, editor.dom.isBlock);
      var block2 = editor.dom.getParent(node2, editor.dom.isBlock);
      return block1 === block2;
    };
    var hasBetterMouseTarget = function (targetNode, caretNode) {
      var targetBlock = editor.dom.getParent(targetNode, editor.dom.isBlock);
      var caretBlock = editor.dom.getParent(caretNode, editor.dom.isBlock);
      if (targetBlock &amp;&amp; editor.dom.isChildOf(targetBlock, caretBlock) &amp;&amp; isContentEditableFalse$9(getContentEditableRoot$1(editor, targetBlock)) === false) {
        return true;
      }
      return targetBlock &amp;&amp; !isInSameBlock$$1(targetBlock, caretBlock) &amp;&amp; hasNormalCaretPosition(targetBlock);
    };
    handleTouchSelect(editor);
    editor.on(&#39;mousedown&#39;, function (e) {
      var contentEditableRoot;
      var targetElm = e.target;
      if (targetElm !== rootNode &amp;&amp; targetElm.nodeName !== &#39;HTML&#39; &amp;&amp; !editor.dom.isChildOf(targetElm, rootNode)) {
        return;
      }
      if (EditorView.isXYInContentArea(editor, e.clientX, e.clientY) === false) {
        return;
      }
      contentEditableRoot = getContentEditableRoot$1(editor, targetElm);
      if (contentEditableRoot) {
        if (isContentEditableFalse$9(contentEditableRoot)) {
          e.preventDefault();
          setContentEditableSelection(selectNode(editor, contentEditableRoot));
        } else {
          removeContentEditableSelection();
          if (!(isContentEditableTrue$5(contentEditableRoot) &amp;&amp; e.shiftKey) &amp;&amp; !RangePoint.isXYWithinRange(e.clientX, e.clientY, editor.selection.getRng())) {
            hideFakeCaret();
            editor.selection.placeCaretAt(e.clientX, e.clientY);
          }
        }
      } else if (isFakeCaretTarget(targetElm) === false) {
        removeContentEditableSelection();
        hideFakeCaret();
        var caretInfo = closestCaret(rootNode, e.clientX, e.clientY);
        if (caretInfo) {
          if (!hasBetterMouseTarget(e.target, caretInfo.node)) {
            e.preventDefault();
            var range$$1 = showCaret$$1(1, caretInfo.node, caretInfo.before, false);
            editor.getBody().focus();
            setRange(range$$1);
          }
        }
      }
    });
    editor.on(&#39;keypress&#39;, function (e) {
      if (VK.modifierPressed(e)) {
        return;
      }
      switch (e.keyCode) {
      default:
        if (isContentEditableFalse$9(editor.selection.getNode())) {
          e.preventDefault();
        }
        break;
      }
    });
    editor.on(&#39;getSelectionRange&#39;, function (e) {
      var rng = e.range;
      if (selectedContentEditableNode) {
        if (!selectedContentEditableNode.parentNode) {
          selectedContentEditableNode = null;
          return;
        }
        rng = rng.cloneRange();
        rng.selectNode(selectedContentEditableNode);
        e.range = rng;
      }
    });
    editor.on(&#39;setSelectionRange&#39;, function (e) {
      var rng;
      rng = setContentEditableSelection(e.range, e.forward);
      if (rng) {
        e.range = rng;
      }
    });
    var isPasteBin = function (node) {
      return node.id === &#39;mcepastebin&#39;;
    };
    editor.on(&#39;AfterSetSelectionRange&#39;, function (e) {
      var rng = e.range;
      if (!isRangeInCaretContainer(rng) &amp;&amp; !isPasteBin(rng.startContainer.parentNode)) {
        hideFakeCaret();
      }
      if (!isFakeSelectionElement(rng.startContainer.parentNode)) {
        removeContentEditableSelection();
      }
    });
    editor.on(&#39;copy&#39;, function (e) {
      var clipboardData = e.clipboardData;
      if (!e.isDefaultPrevented() &amp;&amp; e.clipboardData &amp;&amp; !Env.ie) {
        var realSelectionElement = getRealSelectionElement();
        if (realSelectionElement) {
          e.preventDefault();
          clipboardData.clearData();
          clipboardData.setData(&#39;text/html&#39;, realSelectionElement.outerHTML);
          clipboardData.setData(&#39;text/plain&#39;, realSelectionElement.outerText);
        }
      }
    });
    DragDropOverrides.init(editor);
    CefFocus.setup(editor);
  };
  var addCss = function () {
    var styles = editor.contentStyles, rootClass = &#39;.mce-content-body&#39;;
    styles.push(fakeCaret.getCss());
    styles.push(rootClass + &#39; .mce-offscreen-selection {&#39; + &#39;position: absolute;&#39; + &#39;left: -9999999999px;&#39; + &#39;max-width: 1000000px;&#39; + &#39;}&#39; + rootClass + &#39; *[contentEditable=false] {&#39; + &#39;cursor: default;&#39; + &#39;}&#39; + rootClass + &#39; *[contentEditable=true] {&#39; + &#39;cursor: text;&#39; + &#39;}&#39;);
  };
  var isWithinCaretContainer = function (node) {
    return isCaretContainer(node) || startsWithCaretContainer(node) || endsWithCaretContainer(node);
  };
  var isRangeInCaretContainer = function (rng) {
    return isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
  };
  var setContentEditableSelection = function (range$$1, forward) {
    var node;
    var $ = editor.$;
    var dom = editor.dom;
    var $realSelectionContainer, sel, startContainer, startOffset, endOffset, e, caretPosition, targetClone, origTargetClone;
    if (!range$$1) {
      return null;
    }
    if (range$$1.collapsed) {
      if (!isRangeInCaretContainer(range$$1)) {
        if (forward === false) {
          caretPosition = getNormalizedRangeEndPoint$$1(-1, range$$1);
          if (isFakeCaretTarget(caretPosition.getNode(true))) {
            return showCaret$$1(-1, caretPosition.getNode(true), false, false);
          }
          if (isFakeCaretTarget(caretPosition.getNode())) {
            return showCaret$$1(-1, caretPosition.getNode(), !caretPosition.isAtEnd(), false);
          }
        } else {
          caretPosition = getNormalizedRangeEndPoint$$1(1, range$$1);
          if (isFakeCaretTarget(caretPosition.getNode())) {
            return showCaret$$1(1, caretPosition.getNode(), !caretPosition.isAtEnd(), false);
          }
          if (isFakeCaretTarget(caretPosition.getNode(true))) {
            return showCaret$$1(1, caretPosition.getNode(true), false, false);
          }
        }
      }
      return null;
    }
    startContainer = range$$1.startContainer;
    startOffset = range$$1.startOffset;
    endOffset = range$$1.endOffset;
    if (startContainer.nodeType === 3 &amp;&amp; startOffset === 0 &amp;&amp; isContentEditableFalse$9(startContainer.parentNode)) {
      startContainer = startContainer.parentNode;
      startOffset = dom.nodeIndex(startContainer);
      startContainer = startContainer.parentNode;
    }
    if (startContainer.nodeType !== 1) {
      return null;
    }
    if (endOffset === startOffset + 1) {
      node = startContainer.childNodes[startOffset];
    }
    if (!isContentEditableFalse$9(node)) {
      return null;
    }
    targetClone = origTargetClone = node.cloneNode(true);
    e = editor.fire(&#39;ObjectSelected&#39;, {
      target: node,
      targetClone: targetClone
    });
    if (e.isDefaultPrevented()) {
      return null;
    }
    $realSelectionContainer = descendant$1(Element$$1.fromDom(editor.getBody()), &#39;#&#39; + realSelectionId).fold(function () {
      return $([]);
    }, function (elm) {
      return $([elm.dom()]);
    });
    targetClone = e.targetClone;
    if ($realSelectionContainer.length === 0) {
      $realSelectionContainer = $(&#39;&lt;div data-mce-bogus=&quot;all&quot; class=&quot;mce-offscreen-selection&quot;&gt;&lt;/div&gt;&#39;).attr(&#39;id&#39;, realSelectionId);
      $realSelectionContainer.appendTo(editor.getBody());
    }
    range$$1 = editor.dom.createRng();
    if (targetClone === origTargetClone &amp;&amp; Env.ie) {
      $realSelectionContainer.empty().append(&#39;&lt;p style=&quot;font-size: 0&quot; data-mce-bogus=&quot;all&quot;&gt;\xA0&lt;/p&gt;&#39;).append(targetClone);
      range$$1.setStartAfter($realSelectionContainer[0].firstChild.firstChild);
      range$$1.setEndAfter(targetClone);
    } else {
      $realSelectionContainer.empty().append(&#39;\xA0&#39;).append(targetClone).append(&#39;\xA0&#39;);
      range$$1.setStart($realSelectionContainer[0].firstChild, 1);
      range$$1.setEnd($realSelectionContainer[0].lastChild, 0);
    }
    $realSelectionContainer.css({ top: dom.getPos(node, editor.getBody()).y });
    $realSelectionContainer[0].focus();
    sel = editor.selection.getSel();
    sel.removeAllRanges();
    sel.addRange(range$$1);
    each(descendants$1(Element$$1.fromDom(editor.getBody()), &#39;*[data-mce-selected]&#39;), function (elm) {
      remove(elm, &#39;data-mce-selected&#39;);
    });
    node.setAttribute(&#39;data-mce-selected&#39;, &#39;1&#39;);
    selectedContentEditableNode = node;
    hideFakeCaret();
    return range$$1;
  };
  var removeContentEditableSelection = function () {
    if (selectedContentEditableNode) {
      selectedContentEditableNode.removeAttribute(&#39;data-mce-selected&#39;);
      descendant$1(Element$$1.fromDom(editor.getBody()), &#39;#&#39; + realSelectionId).each(remove$2);
      selectedContentEditableNode = null;
    }
    descendant$1(Element$$1.fromDom(editor.getBody()), &#39;#&#39; + realSelectionId).each(remove$2);
    selectedContentEditableNode = null;
  };
  var destroy = function () {
    fakeCaret.destroy();
    selectedContentEditableNode = null;
  };
  var hideFakeCaret = function () {
    fakeCaret.hide();
  };
  if (Env.ceFalse) {
    registerEvents();
    addCss();
  }
  return {
    showCaret: showCaret$$1,
    showBlockCaretContainer: showBlockCaretContainer,
    hideFakeCaret: hideFakeCaret,
    destroy: destroy
  };
};

var isValidPrefixAttrName = function (name) {
  return name.indexOf(&#39;data-&#39;) === 0 || name.indexOf(&#39;aria-&#39;) === 0;
};
var trimComments = function (text) {
  return text.replace(/&lt;!--|--&gt;/g, &#39;&#39;);
};
var isInvalidUri = function (settings, uri) {
  if (settings.allow_html_data_urls) {
    return false;
  } else if (/^data:image\//i.test(uri)) {
    return settings.allow_svg_data_urls === false &amp;&amp; /^data:image\/svg\+xml/i.test(uri);
  } else {
    return /^data:/i.test(uri);
  }
};
var findEndTagIndex = function (schema, html, startIndex) {
  var count = 1, index, matches, tokenRegExp, shortEndedElements;
  shortEndedElements = schema.getShortEndedElements();
  tokenRegExp = /&lt;([!?\/])?([A-Za-z0-9\-_\:\.]+)((?:\s+[^&quot;\&#39;&gt;]+(?:(?:&quot;[^&quot;]*&quot;)|(?:\&#39;[^\&#39;]*\&#39;)|[^&gt;]*))*|\/|\s+)&gt;/g;
  tokenRegExp.lastIndex = index = startIndex;
  while (matches = tokenRegExp.exec(html)) {
    index = tokenRegExp.lastIndex;
    if (matches[1] === &#39;/&#39;) {
      count--;
    } else if (!matches[1]) {
      if (matches[2] in shortEndedElements) {
        continue;
      }
      count++;
    }
    if (count === 0) {
      break;
    }
  }
  return index;
};
function SaxParser(settings, schema) {
  if (schema === void 0) {
    schema = Schema();
  }
  var noop = function () {
  };
  settings = settings || {};
  if (settings.fix_self_closing !== false) {
    settings.fix_self_closing = true;
  }
  var comment = settings.comment ? settings.comment : noop;
  var cdata = settings.cdata ? settings.cdata : noop;
  var text = settings.text ? settings.text : noop;
  var start = settings.start ? settings.start : noop;
  var end = settings.end ? settings.end : noop;
  var pi = settings.pi ? settings.pi : noop;
  var doctype = settings.doctype ? settings.doctype : noop;
  var parse = function (html) {
    var matches, index = 0, value, endRegExp;
    var stack = [];
    var attrList, i, textData, name;
    var isInternalElement, removeInternalElements, shortEndedElements, fillAttrsMap, isShortEnded;
    var validate, elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
    var attributesRequired, attributesDefault, attributesForced, processHtml;
    var anyAttributesRequired, selfClosing, tokenRegExp, attrRegExp, specialElements, attrValue, idCount = 0;
    var decode = Entities.decode;
    var fixSelfClosing;
    var filteredUrlAttrs = Tools.makeMap(&#39;src,href,data,background,formaction,poster,xlink:href&#39;);
    var scriptUriRegExp = /((java|vb)script|mhtml):/i;
    var processEndTag = function (name) {
      var pos, i;
      pos = stack.length;
      while (pos--) {
        if (stack[pos].name === name) {
          break;
        }
      }
      if (pos &gt;= 0) {
        for (i = stack.length - 1; i &gt;= pos; i--) {
          name = stack[i];
          if (name.valid) {
            end(name.name);
          }
        }
        stack.length = pos;
      }
    };
    var parseAttribute = function (match, name, value, val2, val3) {
      var attrRule, i;
      var trimRegExp = /[\s\u0000-\u001F]+/g;
      name = name.toLowerCase();
      value = name in fillAttrsMap ? name : decode(value || val2 || val3 || &#39;&#39;);
      if (validate &amp;&amp; !isInternalElement &amp;&amp; isValidPrefixAttrName(name) === false) {
        attrRule = validAttributesMap[name];
        if (!attrRule &amp;&amp; validAttributePatterns) {
          i = validAttributePatterns.length;
          while (i--) {
            attrRule = validAttributePatterns[i];
            if (attrRule.pattern.test(name)) {
              break;
            }
          }
          if (i === -1) {
            attrRule = null;
          }
        }
        if (!attrRule) {
          return;
        }
        if (attrRule.validValues &amp;&amp; !(value in attrRule.validValues)) {
          return;
        }
      }
      if (filteredUrlAttrs[name] &amp;&amp; !settings.allow_script_urls) {
        var uri = value.replace(trimRegExp, &#39;&#39;);
        try {
          uri = decodeURIComponent(uri);
        } catch (ex) {
          uri = unescape(uri);
        }
        if (scriptUriRegExp.test(uri)) {
          return;
        }
        if (isInvalidUri(settings, uri)) {
          return;
        }
      }
      if (isInternalElement &amp;&amp; (name in filteredUrlAttrs || name.indexOf(&#39;on&#39;) === 0)) {
        return;
      }
      attrList.map[name] = value;
      attrList.push({
        name: name,
        value: value
      });
    };
    tokenRegExp = new RegExp(&#39;&lt;(?:&#39; + &#39;(?:!--([\\w\\W]*?)--&gt;)|&#39; + &#39;(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]&gt;)|&#39; + &#39;(?:!DOCTYPE([\\w\\W]*?)&gt;)|&#39; + &#39;(?:\\?([^\\s\\/&lt;&gt;]+) ?([\\w\\W]*?)[?/]&gt;)|&#39; + &#39;(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)&gt;)|&#39; + &#39;(?:([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)((?:\\s+[^&quot;\&#39;&gt;]+(?:(?:&quot;[^&quot;]*&quot;)|(?:\&#39;[^\&#39;]*\&#39;)|[^&gt;]*))*|\\/|\\s+)&gt;)&#39; + &#39;)&#39;, &#39;g&#39;);
    attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\&quot;((?:[^\&quot;])*)\&quot;)|(?:\&#39;((?:[^\&#39;])*)\&#39;)|([^&gt;\s]+)))?/g;
    shortEndedElements = schema.getShortEndedElements();
    selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
    fillAttrsMap = schema.getBoolAttrs();
    validate = settings.validate;
    removeInternalElements = settings.remove_internals;
    fixSelfClosing = settings.fix_self_closing;
    specialElements = schema.getSpecialElements();
    processHtml = html + &#39;&gt;&#39;;
    while (matches = tokenRegExp.exec(processHtml)) {
      if (index &lt; matches.index) {
        text(decode(html.substr(index, matches.index - index)));
      }
      if (value = matches[6]) {
        value = value.toLowerCase();
        if (value.charAt(0) === &#39;:&#39;) {
          value = value.substr(1);
        }
        processEndTag(value);
      } else if (value = matches[7]) {
        if (matches.index + matches[0].length &gt; html.length) {
          text(decode(html.substr(matches.index)));
          index = matches.index + matches[0].length;
          continue;
        }
        value = value.toLowerCase();
        if (value.charAt(0) === &#39;:&#39;) {
          value = value.substr(1);
        }
        isShortEnded = value in shortEndedElements;
        if (fixSelfClosing &amp;&amp; selfClosing[value] &amp;&amp; stack.length &gt; 0 &amp;&amp; stack[stack.length - 1].name === value) {
          processEndTag(value);
        }
        if (!validate || (elementRule = schema.getElementRule(value))) {
          isValidElement = true;
          if (validate) {
            validAttributesMap = elementRule.attributes;
            validAttributePatterns = elementRule.attributePatterns;
          }
          if (attribsValue = matches[8]) {
            isInternalElement = attribsValue.indexOf(&#39;data-mce-type&#39;) !== -1;
            if (isInternalElement &amp;&amp; removeInternalElements) {
              isValidElement = false;
            }
            attrList = [];
            attrList.map = {};
            attribsValue.replace(attrRegExp, parseAttribute);
          } else {
            attrList = [];
            attrList.map = {};
          }
          if (validate &amp;&amp; !isInternalElement) {
            attributesRequired = elementRule.attributesRequired;
            attributesDefault = elementRule.attributesDefault;
            attributesForced = elementRule.attributesForced;
            anyAttributesRequired = elementRule.removeEmptyAttrs;
            if (anyAttributesRequired &amp;&amp; !attrList.length) {
              isValidElement = false;
            }
            if (attributesForced) {
              i = attributesForced.length;
              while (i--) {
                attr = attributesForced[i];
                name = attr.name;
                attrValue = attr.value;
                if (attrValue === &#39;{$uid}&#39;) {
                  attrValue = &#39;mce_&#39; + idCount++;
                }
                attrList.map[name] = attrValue;
                attrList.push({
                  name: name,
                  value: attrValue
                });
              }
            }
            if (attributesDefault) {
              i = attributesDefault.length;
              while (i--) {
                attr = attributesDefault[i];
                name = attr.name;
                if (!(name in attrList.map)) {
                  attrValue = attr.value;
                  if (attrValue === &#39;{$uid}&#39;) {
                    attrValue = &#39;mce_&#39; + idCount++;
                  }
                  attrList.map[name] = attrValue;
                  attrList.push({
                    name: name,
                    value: attrValue
                  });
                }
              }
            }
            if (attributesRequired) {
              i = attributesRequired.length;
              while (i--) {
                if (attributesRequired[i] in attrList.map) {
                  break;
                }
              }
              if (i === -1) {
                isValidElement = false;
              }
            }
            if (attr = attrList.map[&#39;data-mce-bogus&#39;]) {
              if (attr === &#39;all&#39;) {
                index = findEndTagIndex(schema, html, tokenRegExp.lastIndex);
                tokenRegExp.lastIndex = index;
                continue;
              }
              isValidElement = false;
            }
          }
          if (isValidElement) {
            start(value, attrList, isShortEnded);
          }
        } else {
          isValidElement = false;
        }
        if (endRegExp = specialElements[value]) {
          endRegExp.lastIndex = index = matches.index + matches[0].length;
          if (matches = endRegExp.exec(html)) {
            if (isValidElement) {
              textData = html.substr(index, matches.index - index);
            }
            index = matches.index + matches[0].length;
          } else {
            textData = html.substr(index);
            index = html.length;
          }
          if (isValidElement) {
            if (textData.length &gt; 0) {
              text(textData, true);
            }
            end(value);
          }
          tokenRegExp.lastIndex = index;
          continue;
        }
        if (!isShortEnded) {
          if (!attribsValue || attribsValue.indexOf(&#39;/&#39;) !== attribsValue.length - 1) {
            stack.push({
              name: value,
              valid: isValidElement
            });
          } else if (isValidElement) {
            end(value);
          }
        }
      } else if (value = matches[1]) {
        if (value.charAt(0) === &#39;&gt;&#39;) {
          value = &#39; &#39; + value;
        }
        if (!settings.allow_conditional_comments &amp;&amp; value.substr(0, 3).toLowerCase() === &#39;[if&#39;) {
          value = &#39; &#39; + value;
        }
        comment(value);
      } else if (value = matches[2]) {
        cdata(trimComments(value));
      } else if (value = matches[3]) {
        doctype(value);
      } else if (value = matches[4]) {
        pi(value, matches[5]);
      }
      index = matches.index + matches[0].length;
    }
    if (index &lt; html.length) {
      text(decode(html.substr(index)));
    }
    for (i = stack.length - 1; i &gt;= 0; i--) {
      value = stack[i];
      if (value.valid) {
        end(value.name);
      }
    }
  };
  return { parse: parse };
}
(function (SaxParser) {
  SaxParser.findEndTag = findEndTagIndex;
}(SaxParser || (SaxParser = {})));
var SaxParser$1 = SaxParser;

var trimHtml = function (tempAttrs, html) {
  var trimContentRegExp = new RegExp([&#39;\\s?(&#39; + tempAttrs.join(&#39;|&#39;) + &#39;)=&quot;[^&quot;]+&quot;&#39;].join(&#39;|&#39;), &#39;gi&#39;);
  return html.replace(trimContentRegExp, &#39;&#39;);
};
var trimInternal = function (serializer, html) {
  var content = html;
  var bogusAllRegExp = /&lt;(\w+) [^&gt;]*data-mce-bogus=&quot;all&quot;[^&gt;]*&gt;/g;
  var endTagIndex, index, matchLength, matches, shortEndedElements;
  var schema = serializer.schema;
  content = trimHtml(serializer.getTempAttrs(), content);
  shortEndedElements = schema.getShortEndedElements();
  while (matches = bogusAllRegExp.exec(content)) {
    index = bogusAllRegExp.lastIndex;
    matchLength = matches[0].length;
    if (shortEndedElements[matches[1]]) {
      endTagIndex = index;
    } else {
      endTagIndex = SaxParser$1.findEndTag(schema, content, index);
    }
    content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
    bogusAllRegExp.lastIndex = index - matchLength;
  }
  return Zwsp.trim(content);
};
var trimExternal = trimInternal;
var TrimHtml = {
  trimExternal: trimExternal,
  trimInternal: trimInternal
};

var KEEP = 0, INSERT = 1, DELETE = 2;
var diff = function (left, right) {
  var size = left.length + right.length + 2;
  var vDown = new Array(size);
  var vUp = new Array(size);
  var snake = function (start, end, diag) {
    return {
      start: start,
      end: end,
      diag: diag
    };
  };
  var buildScript = function (start1, end1, start2, end2, script) {
    var middle = getMiddleSnake(start1, end1, start2, end2);
    if (middle === null || middle.start === end1 &amp;&amp; middle.diag === end1 - end2 || middle.end === start1 &amp;&amp; middle.diag === start1 - start2) {
      var i = start1;
      var j = start2;
      while (i &lt; end1 || j &lt; end2) {
        if (i &lt; end1 &amp;&amp; j &lt; end2 &amp;&amp; left[i] === right[j]) {
          script.push([
            KEEP,
            left[i]
          ]);
          ++i;
          ++j;
        } else {
          if (end1 - start1 &gt; end2 - start2) {
            script.push([
              DELETE,
              left[i]
            ]);
            ++i;
          } else {
            script.push([
              INSERT,
              right[j]
            ]);
            ++j;
          }
        }
      }
    } else {
      buildScript(start1, middle.start, start2, middle.start - middle.diag, script);
      for (var i2 = middle.start; i2 &lt; middle.end; ++i2) {
        script.push([
          KEEP,
          left[i2]
        ]);
      }
      buildScript(middle.end, end1, middle.end - middle.diag, end2, script);
    }
  };
  var buildSnake = function (start, diag, end1, end2) {
    var end = start;
    while (end - diag &lt; end2 &amp;&amp; end &lt; end1 &amp;&amp; left[end] === right[end - diag]) {
      ++end;
    }
    return snake(start, end, diag);
  };
  var getMiddleSnake = function (start1, end1, start2, end2) {
    var m = end1 - start1;
    var n = end2 - start2;
    if (m === 0 || n === 0) {
      return null;
    }
    var delta = m - n;
    var sum = n + m;
    var offset = (sum % 2 === 0 ? sum : sum + 1) / 2;
    vDown[1 + offset] = start1;
    vUp[1 + offset] = end1 + 1;
    var d, k, i, x, y;
    for (d = 0; d &lt;= offset; ++d) {
      for (k = -d; k &lt;= d; k += 2) {
        i = k + offset;
        if (k === -d || k !== d &amp;&amp; vDown[i - 1] &lt; vDown[i + 1]) {
          vDown[i] = vDown[i + 1];
        } else {
          vDown[i] = vDown[i - 1] + 1;
        }
        x = vDown[i];
        y = x - start1 + start2 - k;
        while (x &lt; end1 &amp;&amp; y &lt; end2 &amp;&amp; left[x] === right[y]) {
          vDown[i] = ++x;
          ++y;
        }
        if (delta % 2 !== 0 &amp;&amp; delta - d &lt;= k &amp;&amp; k &lt;= delta + d) {
          if (vUp[i - delta] &lt;= vDown[i]) {
            return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);
          }
        }
      }
      for (k = delta - d; k &lt;= delta + d; k += 2) {
        i = k + offset - delta;
        if (k === delta - d || k !== delta + d &amp;&amp; vUp[i + 1] &lt;= vUp[i - 1]) {
          vUp[i] = vUp[i + 1] - 1;
        } else {
          vUp[i] = vUp[i - 1];
        }
        x = vUp[i] - 1;
        y = x - start1 + start2 - k;
        while (x &gt;= start1 &amp;&amp; y &gt;= start2 &amp;&amp; left[x] === right[y]) {
          vUp[i] = x--;
          y--;
        }
        if (delta % 2 === 0 &amp;&amp; -d &lt;= k &amp;&amp; k &lt;= d) {
          if (vUp[i] &lt;= vDown[i + delta]) {
            return buildSnake(vUp[i], k + start1 - start2, end1, end2);
          }
        }
      }
    }
  };
  var script = [];
  buildScript(0, left.length, 0, right.length, script);
  return script;
};
var Diff = {
  KEEP: KEEP,
  DELETE: DELETE,
  INSERT: INSERT,
  diff: diff
};

var getOuterHtml = function (elm) {
  if (NodeType.isElement(elm)) {
    return elm.outerHTML;
  } else if (NodeType.isText(elm)) {
    return Entities.encodeRaw(elm.data, false);
  } else if (NodeType.isComment(elm)) {
    return &#39;&lt;!--&#39; + elm.data + &#39;--&gt;&#39;;
  }
  return &#39;&#39;;
};
var createFragment$1 = function (html) {
  var frag, node, container;
  container = document.createElement(&#39;div&#39;);
  frag = document.createDocumentFragment();
  if (html) {
    container.innerHTML = html;
  }
  while (node = container.firstChild) {
    frag.appendChild(node);
  }
  return frag;
};
var insertAt = function (elm, html, index) {
  var fragment = createFragment$1(html);
  if (elm.hasChildNodes() &amp;&amp; index &lt; elm.childNodes.length) {
    var target = elm.childNodes[index];
    target.parentNode.insertBefore(fragment, target);
  } else {
    elm.appendChild(fragment);
  }
};
var removeAt = function (elm, index) {
  if (elm.hasChildNodes() &amp;&amp; index &lt; elm.childNodes.length) {
    var target = elm.childNodes[index];
    target.parentNode.removeChild(target);
  }
};
var applyDiff = function (diff, elm) {
  var index = 0;
  each(diff, function (action) {
    if (action[0] === Diff.KEEP) {
      index++;
    } else if (action[0] === Diff.INSERT) {
      insertAt(elm, action[1], index);
      index++;
    } else if (action[0] === Diff.DELETE) {
      removeAt(elm, index);
    }
  });
};
var read$3 = function (elm) {
  return filter(map(from$1(elm.childNodes), getOuterHtml), function (item) {
    return item.length &gt; 0;
  });
};
var write = function (fragments, elm) {
  var currentFragments = map(from$1(elm.childNodes), getOuterHtml);
  applyDiff(Diff.diff(currentFragments, fragments), elm);
  return elm;
};
var Fragments = {
  read: read$3,
  write: write
};

var undoLevelDocument = Cell(Option.none());
var lazyTempDocument = function () {
  return undoLevelDocument.get().getOrThunk(function () {
    var doc = document.implementation.createHTMLDocument(&#39;undo&#39;);
    undoLevelDocument.set(Option.some(doc));
    return doc;
  });
};
var hasIframes = function (html) {
  return html.indexOf(&#39;&lt;/iframe&gt;&#39;) !== -1;
};
var createFragmentedLevel = function (fragments) {
  return {
    type: &#39;fragmented&#39;,
    fragments: fragments,
    content: &#39;&#39;,
    bookmark: null,
    beforeBookmark: null
  };
};
var createCompleteLevel = function (content) {
  return {
    type: &#39;complete&#39;,
    fragments: null,
    content: content,
    bookmark: null,
    beforeBookmark: null
  };
};
var createFromEditor = function (editor) {
  var fragments, content, trimmedFragments;
  fragments = Fragments.read(editor.getBody());
  trimmedFragments = bind(fragments, function (html) {
    var trimmed = TrimHtml.trimInternal(editor.serializer, html);
    return trimmed.length &gt; 0 ? [trimmed] : [];
  });
  content = trimmedFragments.join(&#39;&#39;);
  return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
};
var applyToEditor = function (editor, level, before) {
  if (level.type === &#39;fragmented&#39;) {
    Fragments.write(level.fragments, editor.getBody());
  } else {
    editor.setContent(level.content, { format: &#39;raw&#39; });
  }
  editor.selection.moveToBookmark(before ? level.beforeBookmark : level.bookmark);
};
var getLevelContent = function (level) {
  return level.type === &#39;fragmented&#39; ? level.fragments.join(&#39;&#39;) : level.content;
};
var getCleanLevelContent = function (level) {
  var elm = Element$$1.fromTag(&#39;body&#39;, lazyTempDocument());
  set$2(elm, getLevelContent(level));
  each(descendants$1(elm, &#39;*[data-mce-bogus]&#39;), unwrap);
  return get$5(elm);
};
var hasEqualContent = function (level1, level2) {
  return getLevelContent(level1) === getLevelContent(level2);
};
var hasEqualCleanedContent = function (level1, level2) {
  return getCleanLevelContent(level1) === getCleanLevelContent(level2);
};
var isEq$3 = function (level1, level2) {
  if (!level1 || !level2) {
    return false;
  } else if (hasEqualContent(level1, level2)) {
    return true;
  } else {
    return hasEqualCleanedContent(level1, level2);
  }
};
var Levels = {
  createFragmentedLevel: createFragmentedLevel,
  createCompleteLevel: createCompleteLevel,
  createFromEditor: createFromEditor,
  applyToEditor: applyToEditor,
  isEq: isEq$3
};

function UndoManager (editor) {
  var self = this, index = 0, data = [], beforeBookmark, isFirstTypedCharacter, locks = 0;
  var isUnlocked = function () {
    return locks === 0;
  };
  var setTyping = function (typing) {
    if (isUnlocked()) {
      self.typing = typing;
    }
  };
  var setDirty = function (state) {
    editor.setDirty(state);
  };
  var addNonTypingUndoLevel = function (e) {
    setTyping(false);
    self.add({}, e);
  };
  var endTyping = function () {
    if (self.typing) {
      setTyping(false);
      self.add();
    }
  };
  editor.on(&#39;init&#39;, function () {
    self.add();
  });
  editor.on(&#39;BeforeExecCommand&#39;, function (e) {
    var cmd = e.command;
    if (cmd !== &#39;Undo&#39; &amp;&amp; cmd !== &#39;Redo&#39; &amp;&amp; cmd !== &#39;mceRepaint&#39;) {
      endTyping();
      self.beforeChange();
    }
  });
  editor.on(&#39;ExecCommand&#39;, function (e) {
    var cmd = e.command;
    if (cmd !== &#39;Undo&#39; &amp;&amp; cmd !== &#39;Redo&#39; &amp;&amp; cmd !== &#39;mceRepaint&#39;) {
      addNonTypingUndoLevel(e);
    }
  });
  editor.on(&#39;ObjectResizeStart Cut&#39;, function () {
    self.beforeChange();
  });
  editor.on(&#39;SaveContent ObjectResized blur&#39;, addNonTypingUndoLevel);
  editor.on(&#39;DragEnd&#39;, addNonTypingUndoLevel);
  editor.on(&#39;KeyUp&#39;, function (e) {
    var keyCode = e.keyCode;
    if (e.isDefaultPrevented()) {
      return;
    }
    if (keyCode &gt;= 33 &amp;&amp; keyCode &lt;= 36 || keyCode &gt;= 37 &amp;&amp; keyCode &lt;= 40 || keyCode === 45 || e.ctrlKey) {
      addNonTypingUndoLevel();
      editor.nodeChanged();
    }
    if (keyCode === 46 || keyCode === 8) {
      editor.nodeChanged();
    }
    if (isFirstTypedCharacter &amp;&amp; self.typing &amp;&amp; Levels.isEq(Levels.createFromEditor(editor), data[0]) === false) {
      if (editor.isDirty() === false) {
        setDirty(true);
        editor.fire(&#39;change&#39;, {
          level: data[0],
          lastLevel: null
        });
      }
      editor.fire(&#39;TypingUndo&#39;);
      isFirstTypedCharacter = false;
      editor.nodeChanged();
    }
  });
  editor.on(&#39;KeyDown&#39;, function (e) {
    var keyCode = e.keyCode;
    if (e.isDefaultPrevented()) {
      return;
    }
    if (keyCode &gt;= 33 &amp;&amp; keyCode &lt;= 36 || keyCode &gt;= 37 &amp;&amp; keyCode &lt;= 40 || keyCode === 45) {
      if (self.typing) {
        addNonTypingUndoLevel(e);
      }
      return;
    }
    var modKey = e.ctrlKey &amp;&amp; !e.altKey || e.metaKey;
    if ((keyCode &lt; 16 || keyCode &gt; 20) &amp;&amp; keyCode !== 224 &amp;&amp; keyCode !== 91 &amp;&amp; !self.typing &amp;&amp; !modKey) {
      self.beforeChange();
      setTyping(true);
      self.add({}, e);
      isFirstTypedCharacter = true;
    }
  });
  editor.on(&#39;MouseDown&#39;, function (e) {
    if (self.typing) {
      addNonTypingUndoLevel(e);
    }
  });
  var isInsertReplacementText = function (event) {
    return event.inputType === &#39;insertReplacementText&#39;;
  };
  var isInsertTextDataNull = function (event) {
    return event.inputType === &#39;insertText&#39; &amp;&amp; event.data === null;
  };
  editor.on(&#39;input&#39;, function (e) {
    if (e.inputType &amp;&amp; (isInsertReplacementText(e) || isInsertTextDataNull(e))) {
      addNonTypingUndoLevel(e);
    }
  });
  editor.addShortcut(&#39;meta+z&#39;, &#39;&#39;, &#39;Undo&#39;);
  editor.addShortcut(&#39;meta+y,meta+shift+z&#39;, &#39;&#39;, &#39;Redo&#39;);
  editor.on(&#39;AddUndo Undo Redo ClearUndos&#39;, function (e) {
    if (!e.isDefaultPrevented()) {
      editor.nodeChanged();
    }
  });
  self = {
    data: data,
    typing: false,
    beforeChange: function () {
      if (isUnlocked()) {
        beforeBookmark = GetBookmark.getUndoBookmark(editor.selection);
      }
    },
    add: function (level, event) {
      var i;
      var settings = editor.settings;
      var lastLevel, currentLevel;
      currentLevel = Levels.createFromEditor(editor);
      level = level || {};
      level = Tools.extend(level, currentLevel);
      if (isUnlocked() === false || editor.removed) {
        return null;
      }
      lastLevel = data[index];
      if (editor.fire(&#39;BeforeAddUndo&#39;, {
          level: level,
          lastLevel: lastLevel,
          originalEvent: event
        }).isDefaultPrevented()) {
        return null;
      }
      if (lastLevel &amp;&amp; Levels.isEq(lastLevel, level)) {
        return null;
      }
      if (data[index]) {
        data[index].beforeBookmark = beforeBookmark;
      }
      if (settings.custom_undo_redo_levels) {
        if (data.length &gt; settings.custom_undo_redo_levels) {
          for (i = 0; i &lt; data.length - 1; i++) {
            data[i] = data[i + 1];
          }
          data.length--;
          index = data.length;
        }
      }
      level.bookmark = GetBookmark.getUndoBookmark(editor.selection);
      if (index &lt; data.length - 1) {
        data.length = index + 1;
      }
      data.push(level);
      index = data.length - 1;
      var args = {
        level: level,
        lastLevel: lastLevel,
        originalEvent: event
      };
      editor.fire(&#39;AddUndo&#39;, args);
      if (index &gt; 0) {
        setDirty(true);
        editor.fire(&#39;change&#39;, args);
      }
      return level;
    },
    undo: function () {
      var level;
      if (self.typing) {
        self.add();
        self.typing = false;
        setTyping(false);
      }
      if (index &gt; 0) {
        level = data[--index];
        Levels.applyToEditor(editor, level, true);
        setDirty(true);
        editor.fire(&#39;undo&#39;, { level: level });
      }
      return level;
    },
    redo: function () {
      var level;
      if (index &lt; data.length - 1) {
        level = data[++index];
        Levels.applyToEditor(editor, level, false);
        setDirty(true);
        editor.fire(&#39;redo&#39;, { level: level });
      }
      return level;
    },
    clear: function () {
      data = [];
      index = 0;
      self.typing = false;
      self.data = data;
      editor.fire(&#39;ClearUndos&#39;);
    },
    hasUndo: function () {
      return index &gt; 0 || self.typing &amp;&amp; data[0] &amp;&amp; !Levels.isEq(Levels.createFromEditor(editor), data[0]);
    },
    hasRedo: function () {
      return index &lt; data.length - 1 &amp;&amp; !self.typing;
    },
    transact: function (callback) {
      endTyping();
      self.beforeChange();
      self.ignore(callback);
      return self.add();
    },
    ignore: function (callback) {
      try {
        locks++;
        callback();
      } finally {
        locks--;
      }
    },
    extra: function (callback1, callback2) {
      var lastLevel, bookmark;
      if (self.transact(callback1)) {
        bookmark = data[index].bookmark;
        lastLevel = data[index - 1];
        Levels.applyToEditor(editor, lastLevel, true);
        if (self.transact(callback2)) {
          data[index - 1].beforeBookmark = bookmark;
        }
      }
    }
  };
  return self;
}

var isEq$4 = FormatUtils.isEq;
var matchesUnInheritedFormatSelector = function (ed, node, name) {
  var formatList = ed.formatter.get(name);
  if (formatList) {
    for (var i = 0; i &lt; formatList.length; i++) {
      if (formatList[i].inherit === false &amp;&amp; ed.dom.is(node, formatList[i].selector)) {
        return true;
      }
    }
  }
  return false;
};
var matchParents = function (editor, node, name, vars) {
  var root = editor.dom.getRoot();
  if (node === root) {
    return false;
  }
  node = editor.dom.getParent(node, function (node) {
    if (matchesUnInheritedFormatSelector(editor, node, name)) {
      return true;
    }
    return node.parentNode === root || !!matchNode(editor, node, name, vars, true);
  });
  return matchNode(editor, node, name, vars);
};
var matchName = function (dom, node, format) {
  if (isEq$4(node, format.inline)) {
    return true;
  }
  if (isEq$4(node, format.block)) {
    return true;
  }
  if (format.selector) {
    return node.nodeType === 1 &amp;&amp; dom.is(node, format.selector);
  }
};
var matchItems = function (dom, node, format, itemName, similar, vars) {
  var key, value;
  var items = format[itemName];
  var i;
  if (format.onmatch) {
    return format.onmatch(node, format, itemName);
  }
  if (items) {
    if (typeof items.length === &#39;undefined&#39;) {
      for (key in items) {
        if (items.hasOwnProperty(key)) {
          if (itemName === &#39;attributes&#39;) {
            value = dom.getAttrib(node, key);
          } else {
            value = FormatUtils.getStyle(dom, node, key);
          }
          if (similar &amp;&amp; !value &amp;&amp; !format.exact) {
            return;
          }
          if ((!similar || format.exact) &amp;&amp; !isEq$4(value, FormatUtils.normalizeStyleValue(dom, FormatUtils.replaceVars(items[key], vars), key))) {
            return;
          }
        }
      }
    } else {
      for (i = 0; i &lt; items.length; i++) {
        if (itemName === &#39;attributes&#39; ? dom.getAttrib(node, items[i]) : FormatUtils.getStyle(dom, node, items[i])) {
          return format;
        }
      }
    }
  }
  return format;
};
var matchNode = function (ed, node, name, vars, similar) {
  var formatList = ed.formatter.get(name);
  var format, i, x, classes;
  var dom = ed.dom;
  if (formatList &amp;&amp; node) {
    for (i = 0; i &lt; formatList.length; i++) {
      format = formatList[i];
      if (matchName(ed.dom, node, format) &amp;&amp; matchItems(dom, node, format, &#39;attributes&#39;, similar, vars) &amp;&amp; matchItems(dom, node, format, &#39;styles&#39;, similar, vars)) {
        if (classes = format.classes) {
          for (x = 0; x &lt; classes.length; x++) {
            if (!ed.dom.hasClass(node, classes[x])) {
              return;
            }
          }
        }
        return format;
      }
    }
  }
};
var match = function (editor, name, vars, node) {
  var startNode;
  if (node) {
    return matchParents(editor, node, name, vars);
  }
  node = editor.selection.getNode();
  if (matchParents(editor, node, name, vars)) {
    return true;
  }
  startNode = editor.selection.getStart();
  if (startNode !== node) {
    if (matchParents(editor, startNode, name, vars)) {
      return true;
    }
  }
  return false;
};
var matchAll = function (editor, names, vars) {
  var startElement;
  var matchedFormatNames = [];
  var checkedMap = {};
  startElement = editor.selection.getStart();
  editor.dom.getParent(startElement, function (node) {
    var i, name;
    for (i = 0; i &lt; names.length; i++) {
      name = names[i];
      if (!checkedMap[name] &amp;&amp; matchNode(editor, node, name, vars)) {
        checkedMap[name] = true;
        matchedFormatNames.push(name);
      }
    }
  }, editor.dom.getRoot());
  return matchedFormatNames;
};
var canApply = function (editor, name) {
  var formatList = editor.formatter.get(name);
  var startNode, parents, i, x, selector;
  var dom = editor.dom;
  if (formatList) {
    startNode = editor.selection.getStart();
    parents = FormatUtils.getParents(dom, startNode);
    for (x = formatList.length - 1; x &gt;= 0; x--) {
      selector = formatList[x].selector;
      if (!selector || formatList[x].defaultBlock) {
        return true;
      }
      for (i = parents.length - 1; i &gt;= 0; i--) {
        if (dom.is(parents[i], selector)) {
          return true;
        }
      }
    }
  }
  return false;
};
var MatchFormat = {
  matchNode: matchNode,
  matchName: matchName,
  match: match,
  matchAll: matchAll,
  canApply: canApply,
  matchesUnInheritedFormatSelector: matchesUnInheritedFormatSelector
};

var splitText = function (node, offset) {
  return node.splitText(offset);
};
var split$1 = function (rng) {
  var startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
  if (startContainer === endContainer &amp;&amp; NodeType.isText(startContainer)) {
    if (startOffset &gt; 0 &amp;&amp; startOffset &lt; startContainer.nodeValue.length) {
      endContainer = splitText(startContainer, startOffset);
      startContainer = endContainer.previousSibling;
      if (endOffset &gt; startOffset) {
        endOffset = endOffset - startOffset;
        startContainer = endContainer = splitText(endContainer, endOffset).previousSibling;
        endOffset = endContainer.nodeValue.length;
        startOffset = 0;
      } else {
        endOffset = 0;
      }
    }
  } else {
    if (NodeType.isText(startContainer) &amp;&amp; startOffset &gt; 0 &amp;&amp; startOffset &lt; startContainer.nodeValue.length) {
      startContainer = splitText(startContainer, startOffset);
      startOffset = 0;
    }
    if (NodeType.isText(endContainer) &amp;&amp; endOffset &gt; 0 &amp;&amp; endOffset &lt; endContainer.nodeValue.length) {
      endContainer = splitText(endContainer, endOffset).previousSibling;
      endOffset = endContainer.nodeValue.length;
    }
  }
  return {
    startContainer: startContainer,
    startOffset: startOffset,
    endContainer: endContainer,
    endOffset: endOffset
  };
};
var SplitRange = { split: split$1 };

var ZWSP$1 = Zwsp.ZWSP, CARET_ID$1 = &#39;_mce_caret&#39;;
var importNode = function (ownerDocument, node) {
  return ownerDocument.importNode(node, true);
};
var getEmptyCaretContainers = function (node) {
  var nodes = [];
  while (node) {
    if (node.nodeType === 3 &amp;&amp; node.nodeValue !== ZWSP$1 || node.childNodes.length &gt; 1) {
      return [];
    }
    if (node.nodeType === 1) {
      nodes.push(node);
    }
    node = node.firstChild;
  }
  return nodes;
};
var isCaretContainerEmpty = function (node) {
  return getEmptyCaretContainers(node).length &gt; 0;
};
var findFirstTextNode = function (node) {
  var walker;
  if (node) {
    walker = new TreeWalker(node, node);
    for (node = walker.current(); node; node = walker.next()) {
      if (node.nodeType === 3) {
        return node;
      }
    }
  }
  return null;
};
var createCaretContainer = function (fill) {
  var caretContainer = Element$$1.fromTag(&#39;span&#39;);
  setAll(caretContainer, {
    &#39;id&#39;: CARET_ID$1,
    &#39;data-mce-bogus&#39;: &#39;1&#39;,
    &#39;data-mce-type&#39;: &#39;format-caret&#39;
  });
  if (fill) {
    append(caretContainer, Element$$1.fromText(ZWSP$1));
  }
  return caretContainer;
};
var trimZwspFromCaretContainer = function (caretContainerNode) {
  var textNode = findFirstTextNode(caretContainerNode);
  if (textNode &amp;&amp; textNode.nodeValue.charAt(0) === ZWSP$1) {
    textNode.deleteData(0, 1);
  }
  return textNode;
};
var removeCaretContainerNode = function (editor, node, moveCaret) {
  if (moveCaret === void 0) {
    moveCaret = true;
  }
  var dom = editor.dom, selection = editor.selection;
  if (isCaretContainerEmpty(node)) {
    DeleteElement.deleteElement(editor, false, Element$$1.fromDom(node), moveCaret);
  } else {
    var rng = selection.getRng();
    var block = dom.getParent(node, dom.isBlock);
    var textNode = trimZwspFromCaretContainer(node);
    if (rng.startContainer === textNode &amp;&amp; rng.startOffset &gt; 0) {
      rng.setStart(textNode, rng.startOffset - 1);
    }
    if (rng.endContainer === textNode &amp;&amp; rng.endOffset &gt; 0) {
      rng.setEnd(textNode, rng.endOffset - 1);
    }
    dom.remove(node, true);
    if (block &amp;&amp; dom.isEmpty(block)) {
      PaddingBr.fillWithPaddingBr(Element$$1.fromDom(block));
    }
    selection.setRng(rng);
  }
};
var removeCaretContainer = function (editor, node, moveCaret) {
  if (moveCaret === void 0) {
    moveCaret = true;
  }
  var dom = editor.dom, selection = editor.selection;
  if (!node) {
    node = getParentCaretContainer(editor.getBody(), selection.getStart());
    if (!node) {
      while (node = dom.get(CARET_ID$1)) {
        removeCaretContainerNode(editor, node, false);
      }
    }
  } else {
    removeCaretContainerNode(editor, node, moveCaret);
  }
};
var insertCaretContainerNode = function (editor, caretContainer, formatNode) {
  var dom = editor.dom, block = dom.getParent(formatNode, curry(FormatUtils.isTextBlock, editor));
  if (block &amp;&amp; dom.isEmpty(block)) {
    formatNode.parentNode.replaceChild(caretContainer, formatNode);
  } else {
    PaddingBr.removeTrailingBr(Element$$1.fromDom(formatNode));
    if (dom.isEmpty(formatNode)) {
      formatNode.parentNode.replaceChild(caretContainer, formatNode);
    } else {
      dom.insertAfter(caretContainer, formatNode);
    }
  }
};
var appendNode = function (parentNode, node) {
  parentNode.appendChild(node);
  return node;
};
var insertFormatNodesIntoCaretContainer = function (formatNodes, caretContainer) {
  var innerMostFormatNode = foldr(formatNodes, function (parentNode, formatNode) {
    return appendNode(parentNode, formatNode.cloneNode(false));
  }, caretContainer);
  return appendNode(innerMostFormatNode, innerMostFormatNode.ownerDocument.createTextNode(ZWSP$1));
};
var applyCaretFormat = function (editor, name$$1, vars) {
  var rng, caretContainer, textNode, offset, bookmark, container, text;
  var selection = editor.selection;
  rng = selection.getRng(true);
  offset = rng.startOffset;
  container = rng.startContainer;
  text = container.nodeValue;
  caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
  if (caretContainer) {
    textNode = findFirstTextNode(caretContainer);
  }
  var wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
  if (text &amp;&amp; offset &gt; 0 &amp;&amp; offset &lt; text.length &amp;&amp; wordcharRegex.test(text.charAt(offset)) &amp;&amp; wordcharRegex.test(text.charAt(offset - 1))) {
    bookmark = selection.getBookmark();
    rng.collapse(true);
    rng = ExpandRange.expandRng(editor, rng, editor.formatter.get(name$$1));
    rng = SplitRange.split(rng);
    editor.formatter.apply(name$$1, vars, rng);
    selection.moveToBookmark(bookmark);
  } else {
    if (!caretContainer || textNode.nodeValue !== ZWSP$1) {
      caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom());
      textNode = caretContainer.firstChild;
      rng.insertNode(caretContainer);
      offset = 1;
      editor.formatter.apply(name$$1, vars, caretContainer);
    } else {
      editor.formatter.apply(name$$1, vars, caretContainer);
    }
    selection.setCursorLocation(textNode, offset);
  }
};
var removeCaretFormat = function (editor, name$$1, vars, similar) {
  var dom = editor.dom, selection = editor.selection;
  var container, offset, bookmark;
  var hasContentAfter, node, formatNode;
  var parents = [], rng = selection.getRng();
  var caretContainer;
  container = rng.startContainer;
  offset = rng.startOffset;
  node = container;
  if (container.nodeType === 3) {
    if (offset !== container.nodeValue.length) {
      hasContentAfter = true;
    }
    node = node.parentNode;
  }
  while (node) {
    if (MatchFormat.matchNode(editor, node, name$$1, vars, similar)) {
      formatNode = node;
      break;
    }
    if (node.nextSibling) {
      hasContentAfter = true;
    }
    parents.push(node);
    node = node.parentNode;
  }
  if (!formatNode) {
    return;
  }
  if (hasContentAfter) {
    bookmark = selection.getBookmark();
    rng.collapse(true);
    var expandedRng = ExpandRange.expandRng(editor, rng, editor.formatter.get(name$$1), true);
    expandedRng = SplitRange.split(expandedRng);
    editor.formatter.remove(name$$1, vars, expandedRng);
    selection.moveToBookmark(bookmark);
  } else {
    caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
    var newCaretContainer = createCaretContainer(false).dom();
    var caretNode = insertFormatNodesIntoCaretContainer(parents, newCaretContainer);
    if (caretContainer) {
      insertCaretContainerNode(editor, newCaretContainer, caretContainer);
    } else {
      insertCaretContainerNode(editor, newCaretContainer, formatNode);
    }
    removeCaretContainerNode(editor, caretContainer, false);
    selection.setCursorLocation(caretNode, 1);
    if (dom.isEmpty(formatNode)) {
      dom.remove(formatNode);
    }
  }
};
var disableCaretContainer = function (editor, keyCode) {
  var selection = editor.selection, body = editor.getBody();
  removeCaretContainer(editor, null, false);
  if ((keyCode === 8 || keyCode === 46) &amp;&amp; selection.isCollapsed() &amp;&amp; selection.getStart().innerHTML === ZWSP$1) {
    removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
  }
  if (keyCode === 37 || keyCode === 39) {
    removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
  }
};
var setup$4 = function (editor) {
  editor.on(&#39;mouseup keydown&#39;, function (e) {
    disableCaretContainer(editor, e.keyCode);
  });
};
var replaceWithCaretFormat = function (targetNode, formatNodes) {
  var caretContainer = createCaretContainer(false);
  var innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom());
  before(Element$$1.fromDom(targetNode), caretContainer);
  remove$2(Element$$1.fromDom(targetNode));
  return CaretPosition$1(innerMost, 0);
};
var isFormatElement = function (editor, element) {
  var inlineElements = editor.schema.getTextInlineElements();
  return inlineElements.hasOwnProperty(name(element)) &amp;&amp; !isCaretNode(element.dom()) &amp;&amp; !NodeType.isBogus(element.dom());
};
var isEmptyCaretFormatElement = function (element) {
  return isCaretNode(element.dom()) &amp;&amp; isCaretContainerEmpty(element.dom());
};

var postProcessHooks = {}, filter$2 = ArrUtils.filter, each$c = ArrUtils.each;
var addPostProcessHook = function (name, hook) {
  var hooks = postProcessHooks[name];
  if (!hooks) {
    postProcessHooks[name] = hooks = [];
  }
  postProcessHooks[name].push(hook);
};
var postProcess = function (name, editor) {
  each$c(postProcessHooks[name], function (hook) {
    hook(editor);
  });
};
addPostProcessHook(&#39;pre&#39;, function (editor) {
  var rng = editor.selection.getRng();
  var isPre, blocks;
  var hasPreSibling = function (pre) {
    return isPre(pre.previousSibling) &amp;&amp; ArrUtils.indexOf(blocks, pre.previousSibling) !== -1;
  };
  var joinPre = function (pre1, pre2) {
    DomQuery(pre2).remove();
    DomQuery(pre1).append(&#39;&lt;br&gt;&lt;br&gt;&#39;).append(pre2.childNodes);
  };
  isPre = NodeType.matchNodeNames(&#39;pre&#39;);
  if (!rng.collapsed) {
    blocks = editor.selection.getSelectedBlocks();
    each$c(filter$2(filter$2(blocks, isPre), hasPreSibling), function (pre) {
      joinPre(pre.previousSibling, pre);
    });
  }
});
var Hooks = { postProcess: postProcess };

var MCE_ATTR_RE = /^(src|href|style)$/;
var each$d = Tools.each;
var isEq$5 = FormatUtils.isEq;
var isTableCell$4 = function (node) {
  return /^(TH|TD)$/.test(node.nodeName);
};
var getContainer = function (ed, rng, start) {
  var container, offset, lastIdx;
  container = rng[start ? &#39;startContainer&#39; : &#39;endContainer&#39;];
  offset = rng[start ? &#39;startOffset&#39; : &#39;endOffset&#39;];
  if (NodeType.isElement(container)) {
    lastIdx = container.childNodes.length - 1;
    if (!start &amp;&amp; offset) {
      offset--;
    }
    container = container.childNodes[offset &gt; lastIdx ? lastIdx : offset];
  }
  if (NodeType.isText(container) &amp;&amp; start &amp;&amp; offset &gt;= container.nodeValue.length) {
    container = new TreeWalker(container, ed.getBody()).next() || container;
  }
  if (NodeType.isText(container) &amp;&amp; !start &amp;&amp; offset === 0) {
    container = new TreeWalker(container, ed.getBody()).prev() || container;
  }
  return container;
};
var wrap$2 = function (dom, node, name, attrs) {
  var wrapper = dom.create(name, attrs);
  node.parentNode.insertBefore(wrapper, node);
  wrapper.appendChild(node);
  return wrapper;
};
var wrapWithSiblings = function (dom, startNode, name, next, attrs) {
  var direction = (next ? &#39;next&#39; : &#39;previous&#39;) + &#39;Sibling&#39;;
  var wrapper = dom.create(name, attrs);
  startNode.parentNode.insertBefore(wrapper, startNode);
  var nodesToWrap = [startNode];
  var currNode = startNode;
  while (currNode = currNode[direction]) {
    nodesToWrap.push(currNode);
  }
  nodesToWrap.forEach(function (node) {
    return wrapper.appendChild(node);
  });
  return wrapper;
};
var matchName$1 = function (dom, node, format) {
  if (isEq$5(node, format.inline)) {
    return true;
  }
  if (isEq$5(node, format.block)) {
    return true;
  }
  if (format.selector) {
    return NodeType.isElement(node) &amp;&amp; dom.is(node, format.selector);
  }
};
var isColorFormatAndAnchor = function (node, format) {
  return format.links &amp;&amp; node.tagName === &#39;A&#39;;
};
var find$4 = function (dom, node, next, inc) {
  node = FormatUtils.getNonWhiteSpaceSibling(node, next, inc);
  return !node || (node.nodeName === &#39;BR&#39; || dom.isBlock(node));
};
var removeNode$1 = function (ed, node, format) {
  var parentNode = node.parentNode;
  var rootBlockElm;
  var dom = ed.dom, forcedRootBlock = ed.settings.forced_root_block;
  if (format.block) {
    if (!forcedRootBlock) {
      if (dom.isBlock(node) &amp;&amp; !dom.isBlock(parentNode)) {
        if (!find$4(dom, node, false) &amp;&amp; !find$4(dom, node.firstChild, true, 1)) {
          node.insertBefore(dom.create(&#39;br&#39;), node.firstChild);
        }
        if (!find$4(dom, node, true) &amp;&amp; !find$4(dom, node.lastChild, false, 1)) {
          node.appendChild(dom.create(&#39;br&#39;));
        }
      }
    } else {
      if (parentNode === dom.getRoot()) {
        if (!format.list_block || !isEq$5(node, format.list_block)) {
          each$d(Tools.grep(node.childNodes), function (node) {
            if (FormatUtils.isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {
              if (!rootBlockElm) {
                rootBlockElm = wrap$2(dom, node, forcedRootBlock);
                dom.setAttribs(rootBlockElm, ed.settings.forced_root_block_attrs);
              } else {
                rootBlockElm.appendChild(node);
              }
            } else {
              rootBlockElm = 0;
            }
          });
        }
      }
    }
  }
  if (format.selector &amp;&amp; format.inline &amp;&amp; !isEq$5(format.inline, node)) {
    return;
  }
  dom.remove(node, 1);
};
var removeFormat = function (ed, format, vars, node, compareNode) {
  var i, attrs, stylesModified;
  var dom = ed.dom;
  if (!matchName$1(dom, node, format) &amp;&amp; !isColorFormatAndAnchor(node, format)) {
    return false;
  }
  if (format.remove !== &#39;all&#39;) {
    each$d(format.styles, function (value, name) {
      value = FormatUtils.normalizeStyleValue(dom, FormatUtils.replaceVars(value, vars), name);
      if (typeof name === &#39;number&#39;) {
        name = value;
        compareNode = 0;
      }
      if (format.remove_similar || (!compareNode || isEq$5(FormatUtils.getStyle(dom, compareNode, name), value))) {
        dom.setStyle(node, name, &#39;&#39;);
      }
      stylesModified = 1;
    });
    if (stylesModified &amp;&amp; dom.getAttrib(node, &#39;style&#39;) === &#39;&#39;) {
      node.removeAttribute(&#39;style&#39;);
      node.removeAttribute(&#39;data-mce-style&#39;);
    }
    each$d(format.attributes, function (value, name) {
      var valueOut;
      value = FormatUtils.replaceVars(value, vars);
      if (typeof name === &#39;number&#39;) {
        name = value;
        compareNode = 0;
      }
      if (!compareNode || isEq$5(dom.getAttrib(compareNode, name), value)) {
        if (name === &#39;class&#39;) {
          value = dom.getAttrib(node, name);
          if (value) {
            valueOut = &#39;&#39;;
            each$d(value.split(/\s+/), function (cls) {
              if (/mce\-\w+/.test(cls)) {
                valueOut += (valueOut ? &#39; &#39; : &#39;&#39;) + cls;
              }
            });
            if (valueOut) {
              dom.setAttrib(node, name, valueOut);
              return;
            }
          }
        }
        if (name === &#39;class&#39;) {
          node.removeAttribute(&#39;className&#39;);
        }
        if (MCE_ATTR_RE.test(name)) {
          node.removeAttribute(&#39;data-mce-&#39; + name);
        }
        node.removeAttribute(name);
      }
    });
    each$d(format.classes, function (value) {
      value = FormatUtils.replaceVars(value, vars);
      if (!compareNode || dom.hasClass(compareNode, value)) {
        dom.removeClass(node, value);
      }
    });
    attrs = dom.getAttribs(node);
    for (i = 0; i &lt; attrs.length; i++) {
      var attrName = attrs[i].nodeName;
      if (attrName.indexOf(&#39;_&#39;) !== 0 &amp;&amp; attrName.indexOf(&#39;data-&#39;) !== 0) {
        return false;
      }
    }
  }
  if (format.remove !== &#39;none&#39;) {
    removeNode$1(ed, node, format);
    return true;
  }
};
var findFormatRoot = function (editor, container, name, vars, similar) {
  var formatRoot;
  each$d(FormatUtils.getParents(editor.dom, container.parentNode).reverse(), function (parent) {
    var format;
    if (!formatRoot &amp;&amp; parent.id !== &#39;_start&#39; &amp;&amp; parent.id !== &#39;_end&#39;) {
      format = MatchFormat.matchNode(editor, parent, name, vars, similar);
      if (format &amp;&amp; format.split !== false) {
        formatRoot = parent;
      }
    }
  });
  return formatRoot;
};
var wrapAndSplit = function (editor, formatList, formatRoot, container, target, split, format, vars) {
  var parent, clone, lastClone, firstClone, i, formatRootParent;
  var dom = editor.dom;
  if (formatRoot) {
    formatRootParent = formatRoot.parentNode;
    for (parent = container.parentNode; parent &amp;&amp; parent !== formatRootParent; parent = parent.parentNode) {
      clone = dom.clone(parent, false);
      for (i = 0; i &lt; formatList.length; i++) {
        if (removeFormat(editor, formatList[i], vars, clone, clone)) {
          clone = 0;
          break;
        }
      }
      if (clone) {
        if (lastClone) {
          clone.appendChild(lastClone);
        }
        if (!firstClone) {
          firstClone = clone;
        }
        lastClone = clone;
      }
    }
    if (split &amp;&amp; (!format.mixed || !dom.isBlock(formatRoot))) {
      container = dom.split(formatRoot, container);
    }
    if (lastClone) {
      target.parentNode.insertBefore(lastClone, target);
      firstClone.appendChild(target);
    }
  }
  return container;
};
var remove$8 = function (ed, name, vars, node, similar) {
  var formatList = ed.formatter.get(name), format = formatList[0];
  var bookmark, rng, contentEditable = true;
  var dom = ed.dom;
  var selection = ed.selection;
  var splitToFormatRoot = function (container) {
    var formatRoot = findFormatRoot(ed, container, name, vars, similar);
    return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
  };
  var isRemoveBookmarkNode = function (node) {
    return Bookmarks.isBookmarkNode(node) &amp;&amp; NodeType.isElement(node) &amp;&amp; (node.id === &#39;_start&#39; || node.id === &#39;_end&#39;);
  };
  var process = function (node) {
    var children, i, l, lastContentEditable, hasContentEditableState;
    if (NodeType.isElement(node) &amp;&amp; dom.getContentEditable(node)) {
      lastContentEditable = contentEditable;
      contentEditable = dom.getContentEditable(node) === &#39;true&#39;;
      hasContentEditableState = true;
    }
    children = Tools.grep(node.childNodes);
    if (contentEditable &amp;&amp; !hasContentEditableState) {
      for (i = 0, l = formatList.length; i &lt; l; i++) {
        if (removeFormat(ed, formatList[i], vars, node, node)) {
          break;
        }
      }
    }
    if (format.deep) {
      if (children.length) {
        for (i = 0, l = children.length; i &lt; l; i++) {
          process(children[i]);
        }
        if (hasContentEditableState) {
          contentEditable = lastContentEditable;
        }
      }
    }
  };
  var unwrap = function (start) {
    var node = dom.get(start ? &#39;_start&#39; : &#39;_end&#39;);
    var out = node[start ? &#39;firstChild&#39; : &#39;lastChild&#39;];
    if (isRemoveBookmarkNode(out)) {
      out = out[start ? &#39;firstChild&#39; : &#39;lastChild&#39;];
    }
    if (NodeType.isText(out) &amp;&amp; out.data.length === 0) {
      out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;
    }
    dom.remove(node, true);
    return out;
  };
  var removeRngStyle = function (rng) {
    var startContainer, endContainer;
    var commonAncestorContainer = rng.commonAncestorContainer;
    rng = ExpandRange.expandRng(ed, rng, formatList, true);
    if (format.split) {
      rng = SplitRange.split(rng);
      startContainer = getContainer(ed, rng, true);
      endContainer = getContainer(ed, rng);
      if (startContainer !== endContainer) {
        if (/^(TR|TH|TD)$/.test(startContainer.nodeName) &amp;&amp; startContainer.firstChild) {
          if (startContainer.nodeName === &#39;TR&#39;) {
            startContainer = startContainer.firstChild.firstChild || startContainer;
          } else {
            startContainer = startContainer.firstChild || startContainer;
          }
        }
        if (commonAncestorContainer &amp;&amp; /^T(HEAD|BODY|FOOT|R)$/.test(commonAncestorContainer.nodeName) &amp;&amp; isTableCell$4(endContainer) &amp;&amp; endContainer.firstChild) {
          endContainer = endContainer.firstChild || endContainer;
        }
        if (dom.isChildOf(startContainer, endContainer) &amp;&amp; startContainer !== endContainer &amp;&amp; !dom.isBlock(endContainer) &amp;&amp; !isTableCell$4(startContainer) &amp;&amp; !isTableCell$4(endContainer)) {
          var wrappedContent = wrapWithSiblings(dom, startContainer, &#39;span&#39;, true, {
            &#39;id&#39;: &#39;_start&#39;,
            &#39;data-mce-type&#39;: &#39;bookmark&#39;
          });
          splitToFormatRoot(wrappedContent);
          startContainer = unwrap(true);
          return;
        }
        startContainer = wrap$2(dom, startContainer, &#39;span&#39;, {
          &#39;id&#39;: &#39;_start&#39;,
          &#39;data-mce-type&#39;: &#39;bookmark&#39;
        });
        endContainer = wrap$2(dom, endContainer, &#39;span&#39;, {
          &#39;id&#39;: &#39;_end&#39;,
          &#39;data-mce-type&#39;: &#39;bookmark&#39;
        });
        splitToFormatRoot(startContainer);
        splitToFormatRoot(endContainer);
        startContainer = unwrap(true);
        endContainer = unwrap();
      } else {
        startContainer = endContainer = splitToFormatRoot(startContainer);
      }
      rng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
      rng.startOffset = dom.nodeIndex(startContainer);
      rng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
      rng.endOffset = dom.nodeIndex(endContainer) + 1;
    }
    RangeWalk.walk(dom, rng, function (nodes) {
      each$d(nodes, function (node) {
        process(node);
        if (NodeType.isElement(node) &amp;&amp; ed.dom.getStyle(node, &#39;text-decoration&#39;) === &#39;underline&#39; &amp;&amp; node.parentNode &amp;&amp; FormatUtils.getTextDecoration(dom, node.parentNode) === &#39;underline&#39;) {
          removeFormat(ed, {
            deep: false,
            exact: true,
            inline: &#39;span&#39;,
            styles: { textDecoration: &#39;underline&#39; }
          }, null, node);
        }
      });
    });
  };
  if (node) {
    if (node.nodeType) {
      rng = dom.createRng();
      rng.setStartBefore(node);
      rng.setEndAfter(node);
      removeRngStyle(rng);
    } else {
      removeRngStyle(node);
    }
    return;
  }
  if (dom.getContentEditable(selection.getNode()) === &#39;false&#39;) {
    node = selection.getNode();
    for (var i = 0, l = formatList.length; i &lt; l; i++) {
      if (formatList[i].ceFalseOverride) {
        if (removeFormat(ed, formatList[i], vars, node, node)) {
          break;
        }
      }
    }
    return;
  }
  if (!selection.isCollapsed() || !format.inline || dom.select(&#39;td[data-mce-selected],th[data-mce-selected]&#39;).length) {
    bookmark = GetBookmark.getPersistentBookmark(ed.selection, true);
    removeRngStyle(selection.getRng());
    selection.moveToBookmark(bookmark);
    if (format.inline &amp;&amp; MatchFormat.match(ed, name, vars, selection.getStart())) {
      FormatUtils.moveStart(dom, selection, selection.getRng());
    }
    ed.nodeChanged();
  } else {
    removeCaretFormat(ed, name, vars, similar);
  }
};
var RemoveFormat = {
  removeFormat: removeFormat,
  remove: remove$8
};

var each$e = Tools.each;
var isElementNode = function (node) {
  return node &amp;&amp; node.nodeType === 1 &amp;&amp; !Bookmarks.isBookmarkNode(node) &amp;&amp; !isCaretNode(node) &amp;&amp; !NodeType.isBogus(node);
};
var findElementSibling = function (node, siblingName) {
  var sibling;
  for (sibling = node; sibling; sibling = sibling[siblingName]) {
    if (sibling.nodeType === 3 &amp;&amp; sibling.nodeValue.length !== 0) {
      return node;
    }
    if (sibling.nodeType === 1 &amp;&amp; !Bookmarks.isBookmarkNode(sibling)) {
      return sibling;
    }
  }
  return node;
};
var mergeSiblingsNodes = function (dom, prev, next) {
  var sibling, tmpSibling;
  var elementUtils = new ElementUtils(dom);
  if (prev &amp;&amp; next) {
    prev = findElementSibling(prev, &#39;previousSibling&#39;);
    next = findElementSibling(next, &#39;nextSibling&#39;);
    if (elementUtils.compare(prev, next)) {
      for (sibling = prev.nextSibling; sibling &amp;&amp; sibling !== next;) {
        tmpSibling = sibling;
        sibling = sibling.nextSibling;
        prev.appendChild(tmpSibling);
      }
      dom.remove(next);
      Tools.each(Tools.grep(next.childNodes), function (node) {
        prev.appendChild(node);
      });
      return prev;
    }
  }
  return next;
};
var processChildElements = function (node, filter, process) {
  each$e(node.childNodes, function (node) {
    if (isElementNode(node)) {
      if (filter(node)) {
        process(node);
      }
      if (node.hasChildNodes()) {
        processChildElements(node, filter, process);
      }
    }
  });
};
var hasStyle = function (dom, name) {
  return curry(function (name, node) {
    return !!(node &amp;&amp; FormatUtils.getStyle(dom, node, name));
  }, name);
};
var applyStyle = function (dom, name, value) {
  return curry(function (name, value, node) {
    dom.setStyle(node, name, value);
    if (node.getAttribute(&#39;style&#39;) === &#39;&#39;) {
      node.removeAttribute(&#39;style&#39;);
    }
    unwrapEmptySpan(dom, node);
  }, name, value);
};
var unwrapEmptySpan = function (dom, node) {
  if (node.nodeName === &#39;SPAN&#39; &amp;&amp; dom.getAttribs(node).length === 0) {
    dom.remove(node, true);
  }
};
var processUnderlineAndColor = function (dom, node) {
  var textDecoration;
  if (node.nodeType === 1 &amp;&amp; node.parentNode &amp;&amp; node.parentNode.nodeType === 1) {
    textDecoration = FormatUtils.getTextDecoration(dom, node.parentNode);
    if (dom.getStyle(node, &#39;color&#39;) &amp;&amp; textDecoration) {
      dom.setStyle(node, &#39;text-decoration&#39;, textDecoration);
    } else if (dom.getStyle(node, &#39;text-decoration&#39;) === textDecoration) {
      dom.setStyle(node, &#39;text-decoration&#39;, null);
    }
  }
};
var mergeUnderlineAndColor = function (dom, format, vars, node) {
  if (format.styles.color || format.styles.textDecoration) {
    Tools.walk(node, curry(processUnderlineAndColor, dom), &#39;childNodes&#39;);
    processUnderlineAndColor(dom, node);
  }
};
var mergeBackgroundColorAndFontSize = function (dom, format, vars, node) {
  if (format.styles &amp;&amp; format.styles.backgroundColor) {
    processChildElements(node, hasStyle(dom, &#39;fontSize&#39;), applyStyle(dom, &#39;backgroundColor&#39;, FormatUtils.replaceVars(format.styles.backgroundColor, vars)));
  }
};
var mergeSubSup = function (dom, format, vars, node) {
  if (format.inline === &#39;sub&#39; || format.inline === &#39;sup&#39;) {
    processChildElements(node, hasStyle(dom, &#39;fontSize&#39;), applyStyle(dom, &#39;fontSize&#39;, &#39;&#39;));
    dom.remove(dom.select(format.inline === &#39;sup&#39; ? &#39;sub&#39; : &#39;sup&#39;, node), true);
  }
};
var mergeSiblings = function (dom, format, vars, node) {
  if (node &amp;&amp; format.merge_siblings !== false) {
    node = mergeSiblingsNodes(dom, FormatUtils.getNonWhiteSpaceSibling(node), node);
    node = mergeSiblingsNodes(dom, node, FormatUtils.getNonWhiteSpaceSibling(node, true));
  }
};
var clearChildStyles = function (dom, format, node) {
  if (format.clear_child_styles) {
    var selector = format.links ? &#39;*:not(a)&#39; : &#39;*&#39;;
    each$e(dom.select(selector, node), function (node) {
      if (isElementNode(node)) {
        each$e(format.styles, function (value, name) {
          dom.setStyle(node, name, &#39;&#39;);
        });
      }
    });
  }
};
var mergeWithChildren = function (editor, formatList, vars, node) {
  each$e(formatList, function (format) {
    each$e(editor.dom.select(format.inline, node), function (child) {
      if (!isElementNode(child)) {
        return;
      }
      RemoveFormat.removeFormat(editor, format, vars, child, format.exact ? child : null);
    });
    clearChildStyles(editor.dom, format, node);
  });
};
var mergeWithParents = function (editor, format, name, vars, node) {
  if (MatchFormat.matchNode(editor, node.parentNode, name, vars)) {
    if (RemoveFormat.removeFormat(editor, format, vars, node)) {
      return;
    }
  }
  if (format.merge_with_parents) {
    editor.dom.getParent(node.parentNode, function (parent) {
      if (MatchFormat.matchNode(editor, parent, name, vars)) {
        RemoveFormat.removeFormat(editor, format, vars, node);
        return true;
      }
    });
  }
};
var MergeFormats = {
  mergeWithChildren: mergeWithChildren,
  mergeUnderlineAndColor: mergeUnderlineAndColor,
  mergeBackgroundColorAndFontSize: mergeBackgroundColorAndFontSize,
  mergeSubSup: mergeSubSup,
  mergeSiblings: mergeSiblings,
  mergeWithParents: mergeWithParents
};

var each$f = Tools.each;
var isElementNode$1 = function (node) {
  return node &amp;&amp; node.nodeType === 1 &amp;&amp; !Bookmarks.isBookmarkNode(node) &amp;&amp; !isCaretNode(node) &amp;&amp; !NodeType.isBogus(node);
};
var applyFormat = function (ed, name, vars, node) {
  var formatList = ed.formatter.get(name);
  var format = formatList[0];
  var bookmark, rng;
  var isCollapsed = !node &amp;&amp; ed.selection.isCollapsed();
  var dom = ed.dom, selection = ed.selection;
  var setElementFormat = function (elm, fmt) {
    fmt = fmt || format;
    if (elm) {
      if (fmt.onformat) {
        fmt.onformat(elm, fmt, vars, node);
      }
      each$f(fmt.styles, function (value, name) {
        dom.setStyle(elm, name, FormatUtils.replaceVars(value, vars));
      });
      if (fmt.styles) {
        var styleVal = dom.getAttrib(elm, &#39;style&#39;);
        if (styleVal) {
          elm.setAttribute(&#39;data-mce-style&#39;, styleVal);
        }
      }
      each$f(fmt.attributes, function (value, name) {
        dom.setAttrib(elm, name, FormatUtils.replaceVars(value, vars));
      });
      each$f(fmt.classes, function (value) {
        value = FormatUtils.replaceVars(value, vars);
        if (!dom.hasClass(elm, value)) {
          dom.addClass(elm, value);
        }
      });
    }
  };
  var applyNodeStyle = function (formatList, node) {
    var found = false;
    if (!format.selector) {
      return false;
    }
    each$f(formatList, function (format) {
      if (&#39;collapsed&#39; in format &amp;&amp; format.collapsed !== isCollapsed) {
        return;
      }
      if (dom.is(node, format.selector) &amp;&amp; !isCaretNode(node)) {
        setElementFormat(node, format);
        found = true;
        return false;
      }
    });
    return found;
  };
  var applyRngStyle = function (dom, rng, bookmark, nodeSpecific) {
    var newWrappers = [];
    var wrapName, wrapElm, contentEditable = true;
    wrapName = format.inline || format.block;
    wrapElm = dom.create(wrapName);
    setElementFormat(wrapElm);
    RangeWalk.walk(dom, rng, function (nodes) {
      var currentWrapElm;
      var process = function (node) {
        var nodeName, parentName, hasContentEditableState, lastContentEditable;
        lastContentEditable = contentEditable;
        nodeName = node.nodeName.toLowerCase();
        parentName = node.parentNode.nodeName.toLowerCase();
        if (node.nodeType === 1 &amp;&amp; dom.getContentEditable(node)) {
          lastContentEditable = contentEditable;
          contentEditable = dom.getContentEditable(node) === &#39;true&#39;;
          hasContentEditableState = true;
        }
        if (FormatUtils.isEq(nodeName, &#39;br&#39;)) {
          currentWrapElm = 0;
          if (format.block) {
            dom.remove(node);
          }
          return;
        }
        if (format.wrapper &amp;&amp; MatchFormat.matchNode(ed, node, name, vars)) {
          currentWrapElm = 0;
          return;
        }
        if (contentEditable &amp;&amp; !hasContentEditableState &amp;&amp; format.block &amp;&amp; !format.wrapper &amp;&amp; FormatUtils.isTextBlock(ed, nodeName) &amp;&amp; FormatUtils.isValid(ed, parentName, wrapName)) {
          node = dom.rename(node, wrapName);
          setElementFormat(node);
          newWrappers.push(node);
          currentWrapElm = 0;
          return;
        }
        if (format.selector) {
          var found = applyNodeStyle(formatList, node);
          if (!format.inline || found) {
            currentWrapElm = 0;
            return;
          }
        }
        if (contentEditable &amp;&amp; !hasContentEditableState &amp;&amp; FormatUtils.isValid(ed, wrapName, nodeName) &amp;&amp; FormatUtils.isValid(ed, parentName, wrapName) &amp;&amp; !(!nodeSpecific &amp;&amp; node.nodeType === 3 &amp;&amp; node.nodeValue.length === 1 &amp;&amp; node.nodeValue.charCodeAt(0) === 65279) &amp;&amp; !isCaretNode(node) &amp;&amp; (!format.inline || !dom.isBlock(node))) {
          if (!currentWrapElm) {
            currentWrapElm = dom.clone(wrapElm, false);
            node.parentNode.insertBefore(currentWrapElm, node);
            newWrappers.push(currentWrapElm);
          }
          currentWrapElm.appendChild(node);
        } else {
          currentWrapElm = 0;
          each$f(Tools.grep(node.childNodes), process);
          if (hasContentEditableState) {
            contentEditable = lastContentEditable;
          }
          currentWrapElm = 0;
        }
      };
      each$f(nodes, process);
    });
    if (format.links === true) {
      each$f(newWrappers, function (node) {
        var process = function (node) {
          if (node.nodeName === &#39;A&#39;) {
            setElementFormat(node, format);
          }
          each$f(Tools.grep(node.childNodes), process);
        };
        process(node);
      });
    }
    each$f(newWrappers, function (node) {
      var childCount;
      var getChildCount = function (node) {
        var count = 0;
        each$f(node.childNodes, function (node) {
          if (!FormatUtils.isWhiteSpaceNode(node) &amp;&amp; !Bookmarks.isBookmarkNode(node)) {
            count++;
          }
        });
        return count;
      };
      var getChildElementNode = function (root) {
        var child = false;
        each$f(root.childNodes, function (node) {
          if (isElementNode$1(node)) {
            child = node;
            return false;
          }
        });
        return child;
      };
      var mergeStyles = function (node) {
        var child, clone;
        child = getChildElementNode(node);
        if (child &amp;&amp; !Bookmarks.isBookmarkNode(child) &amp;&amp; MatchFormat.matchName(dom, child, format)) {
          clone = dom.clone(child, false);
          setElementFormat(clone);
          dom.replace(clone, node, true);
          dom.remove(child, 1);
        }
        return clone || node;
      };
      childCount = getChildCount(node);
      if ((newWrappers.length &gt; 1 || !dom.isBlock(node)) &amp;&amp; childCount === 0) {
        dom.remove(node, 1);
        return;
      }
      if (format.inline || format.wrapper) {
        if (!format.exact &amp;&amp; childCount === 1) {
          node = mergeStyles(node);
        }
        MergeFormats.mergeWithChildren(ed, formatList, vars, node);
        MergeFormats.mergeWithParents(ed, format, name, vars, node);
        MergeFormats.mergeBackgroundColorAndFontSize(dom, format, vars, node);
        MergeFormats.mergeSubSup(dom, format, vars, node);
        MergeFormats.mergeSiblings(dom, format, vars, node);
      }
    });
  };
  if (dom.getContentEditable(selection.getNode()) === &#39;false&#39;) {
    node = selection.getNode();
    for (var i = 0, l = formatList.length; i &lt; l; i++) {
      if (formatList[i].ceFalseOverride &amp;&amp; dom.is(node, formatList[i].selector)) {
        setElementFormat(node, formatList[i]);
        return;
      }
    }
    return;
  }
  if (format) {
    if (node) {
      if (node.nodeType) {
        if (!applyNodeStyle(formatList, node)) {
          rng = dom.createRng();
          rng.setStartBefore(node);
          rng.setEndAfter(node);
          applyRngStyle(dom, ExpandRange.expandRng(ed, rng, formatList), null, true);
        }
      } else {
        applyRngStyle(dom, node, null, true);
      }
    } else {
      if (!isCollapsed || !format.inline || dom.select(&#39;td[data-mce-selected],th[data-mce-selected]&#39;).length) {
        var curSelNode = ed.selection.getNode();
        if (!ed.settings.forced_root_block &amp;&amp; formatList[0].defaultBlock &amp;&amp; !dom.getParent(curSelNode, dom.isBlock)) {
          applyFormat(ed, formatList[0].defaultBlock);
        }
        ed.selection.setRng(RangeNormalizer.normalize(ed.selection.getRng()));
        bookmark = GetBookmark.getPersistentBookmark(ed.selection, true);
        applyRngStyle(dom, ExpandRange.expandRng(ed, selection.getRng(), formatList), bookmark);
        if (format.styles) {
          MergeFormats.mergeUnderlineAndColor(dom, format, vars, curSelNode);
        }
        selection.moveToBookmark(bookmark);
        FormatUtils.moveStart(dom, selection, selection.getRng());
        ed.nodeChanged();
      } else {
        applyCaretFormat(ed, name, vars);
      }
    }
    Hooks.postProcess(name, ed);
  }
};
var ApplyFormat = { applyFormat: applyFormat };

var each$g = Tools.each;
var setup$5 = function (formatChangeData, editor) {
  var currentFormats = {};
  formatChangeData.set({});
  editor.on(&#39;NodeChange&#39;, function (e) {
    var parents = FormatUtils.getParents(editor.dom, e.element);
    var matchedFormats = {};
    parents = Tools.grep(parents, function (node) {
      return node.nodeType === 1 &amp;&amp; !node.getAttribute(&#39;data-mce-bogus&#39;);
    });
    each$g(formatChangeData.get(), function (callbacks, format) {
      each$g(parents, function (node) {
        if (editor.formatter.matchNode(node, format, {}, callbacks.similar)) {
          if (!currentFormats[format]) {
            each$g(callbacks, function (callback) {
              callback(true, {
                node: node,
                format: format,
                parents: parents
              });
            });
            currentFormats[format] = callbacks;
          }
          matchedFormats[format] = callbacks;
          return false;
        }
        if (MatchFormat.matchesUnInheritedFormatSelector(editor, node, format)) {
          return false;
        }
      });
    });
    each$g(currentFormats, function (callbacks, format) {
      if (!matchedFormats[format]) {
        delete currentFormats[format];
        each$g(callbacks, function (callback) {
          callback(false, {
            node: e.element,
            format: format,
            parents: parents
          });
        });
      }
    });
  });
};
var addListeners = function (formatChangeData, formats, callback, similar) {
  var formatChangeItems = formatChangeData.get();
  each$g(formats.split(&#39;,&#39;), function (format) {
    if (!formatChangeItems[format]) {
      formatChangeItems[format] = [];
      formatChangeItems[format].similar = similar;
    }
    formatChangeItems[format].push(callback);
  });
  formatChangeData.set(formatChangeItems);
};
var formatChanged = function (editor, formatChangeState, formats, callback, similar) {
  if (formatChangeState.get() === null) {
    setup$5(formatChangeState, editor);
  }
  addListeners(formatChangeState, formats, callback, similar);
};
var FormatChanged = { formatChanged: formatChanged };

var get$8 = function (dom) {
  var formats = {
    valigntop: [{
        selector: &#39;td,th&#39;,
        styles: { verticalAlign: &#39;top&#39; }
      }],
    valignmiddle: [{
        selector: &#39;td,th&#39;,
        styles: { verticalAlign: &#39;middle&#39; }
      }],
    valignbottom: [{
        selector: &#39;td,th&#39;,
        styles: { verticalAlign: &#39;bottom&#39; }
      }],
    alignleft: [
      {
        selector: &#39;figure.image&#39;,
        collapsed: false,
        classes: &#39;align-left&#39;,
        ceFalseOverride: true,
        preview: &#39;font-family font-size&#39;
      },
      {
        selector: &#39;figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li&#39;,
        styles: { textAlign: &#39;left&#39; },
        inherit: false,
        preview: false,
        defaultBlock: &#39;div&#39;
      },
      {
        selector: &#39;img,table&#39;,
        collapsed: false,
        styles: { float: &#39;left&#39; },
        preview: &#39;font-family font-size&#39;
      }
    ],
    aligncenter: [
      {
        selector: &#39;figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li&#39;,
        styles: { textAlign: &#39;center&#39; },
        inherit: false,
        preview: &#39;font-family font-size&#39;,
        defaultBlock: &#39;div&#39;
      },
      {
        selector: &#39;figure.image&#39;,
        collapsed: false,
        classes: &#39;align-center&#39;,
        ceFalseOverride: true,
        preview: &#39;font-family font-size&#39;
      },
      {
        selector: &#39;img&#39;,
        collapsed: false,
        styles: {
          display: &#39;block&#39;,
          marginLeft: &#39;auto&#39;,
          marginRight: &#39;auto&#39;
        },
        preview: false
      },
      {
        selector: &#39;table&#39;,
        collapsed: false,
        styles: {
          marginLeft: &#39;auto&#39;,
          marginRight: &#39;auto&#39;
        },
        preview: &#39;font-family font-size&#39;
      }
    ],
    alignright: [
      {
        selector: &#39;figure.image&#39;,
        collapsed: false,
        classes: &#39;align-right&#39;,
        ceFalseOverride: true,
        preview: &#39;font-family font-size&#39;
      },
      {
        selector: &#39;figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li&#39;,
        styles: { textAlign: &#39;right&#39; },
        inherit: false,
        preview: &#39;font-family font-size&#39;,
        defaultBlock: &#39;div&#39;
      },
      {
        selector: &#39;img,table&#39;,
        collapsed: false,
        styles: { float: &#39;right&#39; },
        preview: &#39;font-family font-size&#39;
      }
    ],
    alignjustify: [{
        selector: &#39;figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li&#39;,
        styles: { textAlign: &#39;justify&#39; },
        inherit: false,
        defaultBlock: &#39;div&#39;,
        preview: &#39;font-family font-size&#39;
      }],
    bold: [
      {
        inline: &#39;strong&#39;,
        remove: &#39;all&#39;
      },
      {
        inline: &#39;span&#39;,
        styles: { fontWeight: &#39;bold&#39; }
      },
      {
        inline: &#39;b&#39;,
        remove: &#39;all&#39;
      }
    ],
    italic: [
      {
        inline: &#39;em&#39;,
        remove: &#39;all&#39;
      },
      {
        inline: &#39;span&#39;,
        styles: { fontStyle: &#39;italic&#39; }
      },
      {
        inline: &#39;i&#39;,
        remove: &#39;all&#39;
      }
    ],
    underline: [
      {
        inline: &#39;span&#39;,
        styles: { textDecoration: &#39;underline&#39; },
        exact: true
      },
      {
        inline: &#39;u&#39;,
        remove: &#39;all&#39;
      }
    ],
    strikethrough: [
      {
        inline: &#39;span&#39;,
        styles: { textDecoration: &#39;line-through&#39; },
        exact: true
      },
      {
        inline: &#39;strike&#39;,
        remove: &#39;all&#39;
      }
    ],
    forecolor: {
      inline: &#39;span&#39;,
      styles: { color: &#39;%value&#39; },
      links: true,
      remove_similar: true,
      clear_child_styles: true
    },
    hilitecolor: {
      inline: &#39;span&#39;,
      styles: { backgroundColor: &#39;%value&#39; },
      links: true,
      remove_similar: true,
      clear_child_styles: true
    },
    fontname: {
      inline: &#39;span&#39;,
      toggle: false,
      styles: { fontFamily: &#39;%value&#39; },
      clear_child_styles: true
    },
    fontsize: {
      inline: &#39;span&#39;,
      toggle: false,
      styles: { fontSize: &#39;%value&#39; },
      clear_child_styles: true
    },
    fontsize_class: {
      inline: &#39;span&#39;,
      attributes: { class: &#39;%value&#39; }
    },
    blockquote: {
      block: &#39;blockquote&#39;,
      wrapper: 1,
      remove: &#39;all&#39;
    },
    subscript: { inline: &#39;sub&#39; },
    superscript: { inline: &#39;sup&#39; },
    code: { inline: &#39;code&#39; },
    link: {
      inline: &#39;a&#39;,
      selector: &#39;a&#39;,
      remove: &#39;all&#39;,
      split: true,
      deep: true,
      onmatch: function () {
        return true;
      },
      onformat: function (elm, fmt, vars) {
        Tools.each(vars, function (value, key) {
          dom.setAttrib(elm, key, value);
        });
      }
    },
    removeformat: [
      {
        selector: &#39;b,strong,em,i,font,u,strike,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins&#39;,
        remove: &#39;all&#39;,
        split: true,
        expand: false,
        block_expand: true,
        deep: true
      },
      {
        selector: &#39;span&#39;,
        attributes: [
          &#39;style&#39;,
          &#39;class&#39;
        ],
        remove: &#39;empty&#39;,
        split: true,
        expand: false,
        deep: true
      },
      {
        selector: &#39;*&#39;,
        attributes: [
          &#39;style&#39;,
          &#39;class&#39;
        ],
        split: false,
        expand: false,
        deep: true
      }
    ]
  };
  Tools.each(&#39;p h1 h2 h3 h4 h5 h6 div address pre div dt dd samp&#39;.split(/\s/), function (name) {
    formats[name] = {
      block: name,
      remove: &#39;all&#39;
    };
  });
  return formats;
};
var DefaultFormats = { get: get$8 };

function FormatRegistry (editor) {
  var formats = {};
  var get = function (name) {
    return name ? formats[name] : formats;
  };
  var register = function (name, format) {
    if (name) {
      if (typeof name !== &#39;string&#39;) {
        Tools.each(name, function (format, name) {
          register(name, format);
        });
      } else {
        format = format.length ? format : [format];
        Tools.each(format, function (format) {
          if (typeof format.deep === &#39;undefined&#39;) {
            format.deep = !format.selector;
          }
          if (typeof format.split === &#39;undefined&#39;) {
            format.split = !format.selector || format.inline;
          }
          if (typeof format.remove === &#39;undefined&#39; &amp;&amp; format.selector &amp;&amp; !format.inline) {
            format.remove = &#39;none&#39;;
          }
          if (format.selector &amp;&amp; format.inline) {
            format.mixed = true;
            format.block_expand = true;
          }
          if (typeof format.classes === &#39;string&#39;) {
            format.classes = format.classes.split(/\s+/);
          }
        });
        formats[name] = format;
      }
    }
  };
  var unregister = function (name) {
    if (name &amp;&amp; formats[name]) {
      delete formats[name];
    }
    return formats;
  };
  register(DefaultFormats.get(editor.dom));
  register(editor.settings.formats);
  return {
    get: get,
    register: register,
    unregister: unregister
  };
}

var each$h = Tools.each;
var dom = DOMUtils$1.DOM;
var parsedSelectorToHtml = function (ancestry, editor) {
  var elm, item, fragment;
  var schema = editor &amp;&amp; editor.schema || Schema({});
  var decorate = function (elm, item) {
    if (item.classes.length) {
      dom.addClass(elm, item.classes.join(&#39; &#39;));
    }
    dom.setAttribs(elm, item.attrs);
  };
  var createElement = function (sItem) {
    var elm;
    item = typeof sItem === &#39;string&#39; ? {
      name: sItem,
      classes: [],
      attrs: {}
    } : sItem;
    elm = dom.create(item.name);
    decorate(elm, item);
    return elm;
  };
  var getRequiredParent = function (elm, candidate) {
    var name = typeof elm !== &#39;string&#39; ? elm.nodeName.toLowerCase() : elm;
    var elmRule = schema.getElementRule(name);
    var parentsRequired = elmRule &amp;&amp; elmRule.parentsRequired;
    if (parentsRequired &amp;&amp; parentsRequired.length) {
      return candidate &amp;&amp; Tools.inArray(parentsRequired, candidate) !== -1 ? candidate : parentsRequired[0];
    } else {
      return false;
    }
  };
  var wrapInHtml = function (elm, ancestry, siblings) {
    var parent, parentCandidate, parentRequired;
    var ancestor = ancestry.length &gt; 0 &amp;&amp; ancestry[0];
    var ancestorName = ancestor &amp;&amp; ancestor.name;
    parentRequired = getRequiredParent(elm, ancestorName);
    if (parentRequired) {
      if (ancestorName === parentRequired) {
        parentCandidate = ancestry[0];
        ancestry = ancestry.slice(1);
      } else {
        parentCandidate = parentRequired;
      }
    } else if (ancestor) {
      parentCandidate = ancestry[0];
      ancestry = ancestry.slice(1);
    } else if (!siblings) {
      return elm;
    }
    if (parentCandidate) {
      parent = createElement(parentCandidate);
      parent.appendChild(elm);
    }
    if (siblings) {
      if (!parent) {
        parent = dom.create(&#39;div&#39;);
        parent.appendChild(elm);
      }
      Tools.each(siblings, function (sibling) {
        var siblingElm = createElement(sibling);
        parent.insertBefore(siblingElm, elm);
      });
    }
    return wrapInHtml(parent, ancestry, parentCandidate &amp;&amp; parentCandidate.siblings);
  };
  if (ancestry &amp;&amp; ancestry.length) {
    item = ancestry[0];
    elm = createElement(item);
    fragment = dom.create(&#39;div&#39;);
    fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), item.siblings));
    return fragment;
  } else {
    return &#39;&#39;;
  }
};
var selectorToHtml = function (selector, editor) {
  return parsedSelectorToHtml(parseSelector(selector), editor);
};
var parseSelectorItem = function (item) {
  var tagName;
  var obj = {
    classes: [],
    attrs: {}
  };
  item = obj.selector = Tools.trim(item);
  if (item !== &#39;*&#39;) {
    tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, function ($0, $1, $2, $3, $4) {
      switch ($1) {
      case &#39;#&#39;:
        obj.attrs.id = $2;
        break;
      case &#39;.&#39;:
        obj.classes.push($2);
        break;
      case &#39;:&#39;:
        if (Tools.inArray(&#39;checked disabled enabled read-only required&#39;.split(&#39; &#39;), $2) !== -1) {
          obj.attrs[$2] = $2;
        }
        break;
      }
      if ($3 === &#39;[&#39;) {
        var m = $4.match(/([\w\-]+)(?:\=\&quot;([^\&quot;]+))?/);
        if (m) {
          obj.attrs[m[1]] = m[2];
        }
      }
      return &#39;&#39;;
    });
  }
  obj.name = tagName || &#39;div&#39;;
  return obj;
};
var parseSelector = function (selector) {
  if (!selector || typeof selector !== &#39;string&#39;) {
    return [];
  }
  selector = selector.split(/\s*,\s*/)[0];
  selector = selector.replace(/\s*(~\+|~|\+|&gt;)\s*/g, &#39;$1&#39;);
  return Tools.map(selector.split(/(?:&gt;|\s+(?![^\[\]]+\]))/), function (item) {
    var siblings = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
    var obj = siblings.pop();
    if (siblings.length) {
      obj.siblings = siblings;
    }
    return obj;
  }).reverse();
};
var getCssText = function (editor, format) {
  var name, previewFrag, previewElm, items;
  var previewCss = &#39;&#39;, parentFontSize, previewStyles;
  previewStyles = editor.settings.preview_styles;
  if (previewStyles === false) {
    return &#39;&#39;;
  }
  if (typeof previewStyles !== &#39;string&#39;) {
    previewStyles = &#39;font-family font-size font-weight font-style text-decoration &#39; + &#39;text-transform color background-color border border-radius outline text-shadow&#39;;
  }
  var removeVars = function (val) {
    return val.replace(/%(\w+)/g, &#39;&#39;);
  };
  if (typeof format === &#39;string&#39;) {
    format = editor.formatter.get(format);
    if (!format) {
      return;
    }
    format = format[0];
  }
  if (&#39;preview&#39; in format) {
    previewStyles = format.preview;
    if (previewStyles === false) {
      return &#39;&#39;;
    }
  }
  name = format.block || format.inline || &#39;span&#39;;
  items = parseSelector(format.selector);
  if (items.length) {
    if (!items[0].name) {
      items[0].name = name;
    }
    name = format.selector;
    previewFrag = parsedSelectorToHtml(items, editor);
  } else {
    previewFrag = parsedSelectorToHtml([name], editor);
  }
  previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;
  each$h(format.styles, function (value, name) {
    value = removeVars(value);
    if (value) {
      dom.setStyle(previewElm, name, value);
    }
  });
  each$h(format.attributes, function (value, name) {
    value = removeVars(value);
    if (value) {
      dom.setAttrib(previewElm, name, value);
    }
  });
  each$h(format.classes, function (value) {
    value = removeVars(value);
    if (!dom.hasClass(previewElm, value)) {
      dom.addClass(previewElm, value);
    }
  });
  editor.fire(&#39;PreviewFormats&#39;);
  dom.setStyles(previewFrag, {
    position: &#39;absolute&#39;,
    left: -65535
  });
  editor.getBody().appendChild(previewFrag);
  parentFontSize = dom.getStyle(editor.getBody(), &#39;fontSize&#39;, true);
  parentFontSize = /px$/.test(parentFontSize) ? parseInt(parentFontSize, 10) : 0;
  each$h(previewStyles.split(&#39; &#39;), function (name) {
    var value = dom.getStyle(previewElm, name, true);
    if (name === &#39;background-color&#39; &amp;&amp; /transparent|rgba\s*\([^)]+,\s*0\)/.test(value)) {
      value = dom.getStyle(editor.getBody(), name, true);
      if (dom.toHex(value).toLowerCase() === &#39;#ffffff&#39;) {
        return;
      }
    }
    if (name === &#39;color&#39;) {
      if (dom.toHex(value).toLowerCase() === &#39;#000000&#39;) {
        return;
      }
    }
    if (name === &#39;font-size&#39;) {
      if (/em|%$/.test(value)) {
        if (parentFontSize === 0) {
          return;
        }
        var numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);
        value = numValue * parentFontSize + &#39;px&#39;;
      }
    }
    if (name === &#39;border&#39; &amp;&amp; value) {
      previewCss += &#39;padding:0 2px;&#39;;
    }
    previewCss += name + &#39;:&#39; + value + &#39;;&#39;;
  });
  editor.fire(&#39;AfterPreviewFormats&#39;);
  dom.remove(previewFrag);
  return previewCss;
};
var Preview = {
  getCssText: getCssText,
  parseSelector: parseSelector,
  selectorToHtml: selectorToHtml
};

var toggle$3 = function (editor, formats, name, vars, node) {
  var fmt = formats.get(name);
  if (MatchFormat.match(editor, name, vars, node) &amp;&amp; (!(&#39;toggle&#39; in fmt[0]) || fmt[0].toggle)) {
    RemoveFormat.remove(editor, name, vars, node);
  } else {
    ApplyFormat.applyFormat(editor, name, vars, node);
  }
};
var ToggleFormat = { toggle: toggle$3 };

var setup$6 = function (editor) {
  editor.addShortcut(&#39;meta+b&#39;, &#39;&#39;, &#39;Bold&#39;);
  editor.addShortcut(&#39;meta+i&#39;, &#39;&#39;, &#39;Italic&#39;);
  editor.addShortcut(&#39;meta+u&#39;, &#39;&#39;, &#39;Underline&#39;);
  for (var i = 1; i &lt;= 6; i++) {
    editor.addShortcut(&#39;access+&#39; + i, &#39;&#39;, [
      &#39;FormatBlock&#39;,
      false,
      &#39;h&#39; + i
    ]);
  }
  editor.addShortcut(&#39;access+7&#39;, &#39;&#39;, [
    &#39;FormatBlock&#39;,
    false,
    &#39;p&#39;
  ]);
  editor.addShortcut(&#39;access+8&#39;, &#39;&#39;, [
    &#39;FormatBlock&#39;,
    false,
    &#39;div&#39;
  ]);
  editor.addShortcut(&#39;access+9&#39;, &#39;&#39;, [
    &#39;FormatBlock&#39;,
    false,
    &#39;address&#39;
  ]);
};
var FormatShortcuts = { setup: setup$6 };

function Formatter (editor) {
  var formats = FormatRegistry(editor);
  var formatChangeState = Cell(null);
  FormatShortcuts.setup(editor);
  setup$4(editor);
  return {
    get: formats.get,
    register: formats.register,
    unregister: formats.unregister,
    apply: curry(ApplyFormat.applyFormat, editor),
    remove: curry(RemoveFormat.remove, editor),
    toggle: curry(ToggleFormat.toggle, editor, formats),
    match: curry(MatchFormat.match, editor),
    matchAll: curry(MatchFormat.matchAll, editor),
    matchNode: curry(MatchFormat.matchNode, editor),
    canApply: curry(MatchFormat.canApply, editor),
    formatChanged: curry(FormatChanged.formatChanged, editor, formatChangeState),
    getCssText: curry(Preview.getCssText, editor)
  };
}

var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var shallow$1 = function (old, nu) {
  return nu;
};
var baseMerge = function (merger) {
  return function () {
    var objects = new Array(arguments.length);
    for (var i = 0; i &lt; objects.length; i++)
      objects[i] = arguments[i];
    if (objects.length === 0)
      throw new Error(&#39;Can\&#39;t merge zero objects&#39;);
    var ret = {};
    for (var j = 0; j &lt; objects.length; j++) {
      var curObject = objects[j];
      for (var key in curObject)
        if (hasOwnProperty$2.call(curObject, key)) {
          ret[key] = merger(ret[key], curObject[key]);
        }
    }
    return ret;
  };
};
var merge = baseMerge(shallow$1);

var register = function (htmlParser, settings, dom) {
  htmlParser.addAttributeFilter(&#39;data-mce-tabindex&#39;, function (nodes, name) {
    var i = nodes.length, node;
    while (i--) {
      node = nodes[i];
      node.attr(&#39;tabindex&#39;, node.attributes.map[&#39;data-mce-tabindex&#39;]);
      node.attr(name, null);
    }
  });
  htmlParser.addAttributeFilter(&#39;src,href,style&#39;, function (nodes, name) {
    var i = nodes.length, node, value;
    var internalName = &#39;data-mce-&#39; + name;
    var urlConverter = settings.url_converter;
    var urlConverterScope = settings.url_converter_scope;
    while (i--) {
      node = nodes[i];
      value = node.attributes.map[internalName];
      if (value !== undefined) {
        node.attr(name, value.length &gt; 0 ? value : null);
        node.attr(internalName, null);
      } else {
        value = node.attributes.map[name];
        if (name === &#39;style&#39;) {
          value = dom.serializeStyle(dom.parseStyle(value), node.name);
        } else if (urlConverter) {
          value = urlConverter.call(urlConverterScope, value, name, node.name);
        }
        node.attr(name, value.length &gt; 0 ? value : null);
      }
    }
  });
  htmlParser.addAttributeFilter(&#39;class&#39;, function (nodes) {
    var i = nodes.length, node, value;
    while (i--) {
      node = nodes[i];
      value = node.attr(&#39;class&#39;);
      if (value) {
        value = node.attr(&#39;class&#39;).replace(/(?:^|\s)mce-item-\w+(?!\S)/g, &#39;&#39;);
        node.attr(&#39;class&#39;, value.length &gt; 0 ? value : null);
      }
    }
  });
  htmlParser.addAttributeFilter(&#39;data-mce-type&#39;, function (nodes, name, args) {
    var i = nodes.length, node;
    while (i--) {
      node = nodes[i];
      if (node.attributes.map[&#39;data-mce-type&#39;] === &#39;bookmark&#39; &amp;&amp; !args.cleanup) {
        node.remove();
      }
    }
  });
  htmlParser.addNodeFilter(&#39;noscript&#39;, function (nodes) {
    var i = nodes.length, node;
    while (i--) {
      node = nodes[i].firstChild;
      if (node) {
        node.value = Entities.decode(node.value);
      }
    }
  });
  htmlParser.addNodeFilter(&#39;script,style&#39;, function (nodes, name) {
    var i = nodes.length, node, value, type;
    var trim = function (value) {
      return value.replace(/(&lt;!--\[CDATA\[|\]\]--&gt;)/g, &#39;\n&#39;).replace(/^[\r\n]*|[\r\n]*$/g, &#39;&#39;).replace(/^\s*((&lt;!--)?(\s*\/\/)?\s*&lt;!\[CDATA\[|(&lt;!--\s*)?\/\*\s*&lt;!\[CDATA\[\s*\*\/|(\/\/)?\s*&lt;!--|\/\*\s*&lt;!--\s*\*\/)\s*[\r\n]*/gi, &#39;&#39;).replace(/\s*(\/\*\s*\]\]&gt;\s*\*\/(--&gt;)?|\s*\/\/\s*\]\]&gt;(--&gt;)?|\/\/\s*(--&gt;)?|\]\]&gt;|\/\*\s*--&gt;\s*\*\/|\s*--&gt;\s*)\s*$/g, &#39;&#39;);
    };
    while (i--) {
      node = nodes[i];
      value = node.firstChild ? node.firstChild.value : &#39;&#39;;
      if (name === &#39;script&#39;) {
        type = node.attr(&#39;type&#39;);
        if (type) {
          node.attr(&#39;type&#39;, type === &#39;mce-no/type&#39; ? null : type.replace(/^mce\-/, &#39;&#39;));
        }
        if (settings.element_format === &#39;xhtml&#39; &amp;&amp; value.length &gt; 0) {
          node.firstChild.value = &#39;// &lt;![CDATA[\n&#39; + trim(value) + &#39;\n// ]]&gt;&#39;;
        }
      } else {
        if (settings.element_format === &#39;xhtml&#39; &amp;&amp; value.length &gt; 0) {
          node.firstChild.value = &#39;&lt;!--\n&#39; + trim(value) + &#39;\n--&gt;&#39;;
        }
      }
    }
  });
  htmlParser.addNodeFilter(&#39;#comment&#39;, function (nodes) {
    var i = nodes.length, node;
    while (i--) {
      node = nodes[i];
      if (node.value.indexOf(&#39;[CDATA[&#39;) === 0) {
        node.name = &#39;#cdata&#39;;
        node.type = 4;
        node.value = node.value.replace(/^\[CDATA\[|\]\]$/g, &#39;&#39;);
      } else if (node.value.indexOf(&#39;mce:protected &#39;) === 0) {
        node.name = &#39;#text&#39;;
        node.type = 3;
        node.raw = true;
        node.value = unescape(node.value).substr(14);
      }
    }
  });
  htmlParser.addNodeFilter(&#39;xml:namespace,input&#39;, function (nodes, name) {
    var i = nodes.length, node;
    while (i--) {
      node = nodes[i];
      if (node.type === 7) {
        node.remove();
      } else if (node.type === 1) {
        if (name === &#39;input&#39; &amp;&amp; !(&#39;type&#39; in node.attributes.map)) {
          node.attr(&#39;type&#39;, &#39;text&#39;);
        }
      }
    }
  });
  htmlParser.addAttributeFilter(&#39;data-mce-type&#39;, function (nodes) {
    each(nodes, function (node) {
      if (node.attr(&#39;data-mce-type&#39;) === &#39;format-caret&#39;) {
        if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
          node.remove();
        } else {
          node.unwrap();
        }
      }
    });
  });
  htmlParser.addAttributeFilter(&#39;data-mce-src,data-mce-href,data-mce-style,&#39; + &#39;data-mce-selected,data-mce-expando,&#39; + &#39;data-mce-type,data-mce-resize&#39;, function (nodes, name) {
    var i = nodes.length;
    while (i--) {
      nodes[i].attr(name, null);
    }
  });
};
var trimTrailingBr = function (rootNode) {
  var brNode1, brNode2;
  var isBr = function (node) {
    return node &amp;&amp; node.name === &#39;br&#39;;
  };
  brNode1 = rootNode.lastChild;
  if (isBr(brNode1)) {
    brNode2 = brNode1.prev;
    if (isBr(brNode2)) {
      brNode1.remove();
      brNode2.remove();
    }
  }
};
var DomSerializerFilters = {
  register: register,
  trimTrailingBr: trimTrailingBr
};

var preProcess = function (editor, node, args) {
  var impl, doc, oldDoc;
  var dom = editor.dom;
  node = node.cloneNode(true);
  impl = document.implementation;
  if (impl.createHTMLDocument) {
    doc = impl.createHTMLDocument(&#39;&#39;);
    Tools.each(node.nodeName === &#39;BODY&#39; ? node.childNodes : [node], function (node) {
      doc.body.appendChild(doc.importNode(node, true));
    });
    if (node.nodeName !== &#39;BODY&#39;) {
      node = doc.body.firstChild;
    } else {
      node = doc.body;
    }
    oldDoc = dom.doc;
    dom.doc = doc;
  }
  Events.firePreProcess(editor, merge(args, { node: node }));
  if (oldDoc) {
    dom.doc = oldDoc;
  }
  return node;
};
var shouldFireEvent = function (editor, args) {
  return editor &amp;&amp; editor.hasEventListeners(&#39;PreProcess&#39;) &amp;&amp; !args.no_events;
};
var process = function (editor, node, args) {
  return shouldFireEvent(editor, args) ? preProcess(editor, node, args) : node;
};
var DomSerializerPreProcess = { process: process };

var removeAttrs = function (node, names) {
  each(names, function (name) {
    node.attr(name, null);
  });
};
var addFontToSpansFilter = function (domParser, styles, fontSizes) {
  domParser.addNodeFilter(&#39;font&#39;, function (nodes) {
    each(nodes, function (node) {
      var props = styles.parse(node.attr(&#39;style&#39;));
      var color = node.attr(&#39;color&#39;);
      var face = node.attr(&#39;face&#39;);
      var size = node.attr(&#39;size&#39;);
      if (color) {
        props.color = color;
      }
      if (face) {
        props[&#39;font-family&#39;] = face;
      }
      if (size) {
        props[&#39;font-size&#39;] = fontSizes[parseInt(node.attr(&#39;size&#39;), 10) - 1];
      }
      node.name = &#39;span&#39;;
      node.attr(&#39;style&#39;, styles.serialize(props));
      removeAttrs(node, [
        &#39;color&#39;,
        &#39;face&#39;,
        &#39;size&#39;
      ]);
    });
  });
};
var addStrikeToSpanFilter = function (domParser, styles) {
  domParser.addNodeFilter(&#39;strike&#39;, function (nodes) {
    each(nodes, function (node) {
      var props = styles.parse(node.attr(&#39;style&#39;));
      props[&#39;text-decoration&#39;] = &#39;line-through&#39;;
      node.name = &#39;span&#39;;
      node.attr(&#39;style&#39;, styles.serialize(props));
    });
  });
};
var addFilters = function (domParser, settings) {
  var styles = Styles();
  if (settings.convert_fonts_to_spans) {
    addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));
  }
  addStrikeToSpanFilter(domParser, styles);
};
var register$1 = function (domParser, settings) {
  if (settings.inline_styles) {
    addFilters(domParser, settings);
  }
};
var LegacyFilter = { register: register$1 };

var whiteSpaceRegExp$3 = /^[ \t\r\n]*$/;
var typeLookup = {
  &#39;#text&#39;: 3,
  &#39;#comment&#39;: 8,
  &#39;#cdata&#39;: 4,
  &#39;#pi&#39;: 7,
  &#39;#doctype&#39;: 10,
  &#39;#document-fragment&#39;: 11
};
var walk$2 = function (node, root, prev) {
  var sibling;
  var parent;
  var startName = prev ? &#39;lastChild&#39; : &#39;firstChild&#39;;
  var siblingName = prev ? &#39;prev&#39; : &#39;next&#39;;
  if (node[startName]) {
    return node[startName];
  }
  if (node !== root) {
    sibling = node[siblingName];
    if (sibling) {
      return sibling;
    }
    for (parent = node.parent; parent &amp;&amp; parent !== root; parent = parent.parent) {
      sibling = parent[siblingName];
      if (sibling) {
        return sibling;
      }
    }
  }
};
var Node$2 = function () {
  function Node(name, type) {
    this.name = name;
    this.type = type;
    if (type === 1) {
      this.attributes = [];
      this.attributes.map = {};
    }
  }
  Node.create = function (name, attrs) {
    var node, attrName;
    node = new Node(name, typeLookup[name] || 1);
    if (attrs) {
      for (attrName in attrs) {
        node.attr(attrName, attrs[attrName]);
      }
    }
    return node;
  };
  Node.prototype.replace = function (node) {
    var self = this;
    if (node.parent) {
      node.remove();
    }
    self.insert(node, self);
    self.remove();
    return self;
  };
  Node.prototype.attr = function (name, value) {
    var self = this;
    var attrs, i;
    if (typeof name !== &#39;string&#39;) {
      for (i in name) {
        self.attr(i, name[i]);
      }
      return self;
    }
    if (attrs = self.attributes) {
      if (value !== undefined) {
        if (value === null) {
          if (name in attrs.map) {
            delete attrs.map[name];
            i = attrs.length;
            while (i--) {
              if (attrs[i].name === name) {
                attrs = attrs.splice(i, 1);
                return self;
              }
            }
          }
          return self;
        }
        if (name in attrs.map) {
          i = attrs.length;
          while (i--) {
            if (attrs[i].name === name) {
              attrs[i].value = value;
              break;
            }
          }
        } else {
          attrs.push({
            name: name,
            value: value
          });
        }
        attrs.map[name] = value;
        return self;
      }
      return attrs.map[name];
    }
  };
  Node.prototype.clone = function () {
    var self = this;
    var clone = new Node(self.name, self.type);
    var i, l, selfAttrs, selfAttr, cloneAttrs;
    if (selfAttrs = self.attributes) {
      cloneAttrs = [];
      cloneAttrs.map = {};
      for (i = 0, l = selfAttrs.length; i &lt; l; i++) {
        selfAttr = selfAttrs[i];
        if (selfAttr.name !== &#39;id&#39;) {
          cloneAttrs[cloneAttrs.length] = {
            name: selfAttr.name,
            value: selfAttr.value
          };
          cloneAttrs.map[selfAttr.name] = selfAttr.value;
        }
      }
      clone.attributes = cloneAttrs;
    }
    clone.value = self.value;
    clone.shortEnded = self.shortEnded;
    return clone;
  };
  Node.prototype.wrap = function (wrapper) {
    var self = this;
    self.parent.insert(wrapper, self);
    wrapper.append(self);
    return self;
  };
  Node.prototype.unwrap = function () {
    var self = this;
    var node, next;
    for (node = self.firstChild; node;) {
      next = node.next;
      self.insert(node, self, true);
      node = next;
    }
    self.remove();
  };
  Node.prototype.remove = function () {
    var self = this, parent = self.parent, next = self.next, prev = self.prev;
    if (parent) {
      if (parent.firstChild === self) {
        parent.firstChild = next;
        if (next) {
          next.prev = null;
        }
      } else {
        prev.next = next;
      }
      if (parent.lastChild === self) {
        parent.lastChild = prev;
        if (prev) {
          prev.next = null;
        }
      } else {
        next.prev = prev;
      }
      self.parent = self.next = self.prev = null;
    }
    return self;
  };
  Node.prototype.append = function (node) {
    var self = this;
    var last;
    if (node.parent) {
      node.remove();
    }
    last = self.lastChild;
    if (last) {
      last.next = node;
      node.prev = last;
      self.lastChild = node;
    } else {
      self.lastChild = self.firstChild = node;
    }
    node.parent = self;
    return node;
  };
  Node.prototype.insert = function (node, refNode, before) {
    var parent;
    if (node.parent) {
      node.remove();
    }
    parent = refNode.parent || this;
    if (before) {
      if (refNode === parent.firstChild) {
        parent.firstChild = node;
      } else {
        refNode.prev.next = node;
      }
      node.prev = refNode.prev;
      node.next = refNode;
      refNode.prev = node;
    } else {
      if (refNode === parent.lastChild) {
        parent.lastChild = node;
      } else {
        refNode.next.prev = node;
      }
      node.next = refNode.next;
      node.prev = refNode;
      refNode.next = node;
    }
    node.parent = parent;
    return node;
  };
  Node.prototype.getAll = function (name) {
    var self = this;
    var node;
    var collection = [];
    for (node = self.firstChild; node; node = walk$2(node, self)) {
      if (node.name === name) {
        collection.push(node);
      }
    }
    return collection;
  };
  Node.prototype.empty = function () {
    var self = this;
    var nodes, i, node;
    if (self.firstChild) {
      nodes = [];
      for (node = self.firstChild; node; node = walk$2(node, self)) {
        nodes.push(node);
      }
      i = nodes.length;
      while (i--) {
        node = nodes[i];
        node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
      }
    }
    self.firstChild = self.lastChild = null;
    return self;
  };
  Node.prototype.isEmpty = function (elements, whitespace, predicate) {
    var self = this;
    var node = self.firstChild, i, name;
    whitespace = whitespace || {};
    if (node) {
      do {
        if (node.type === 1) {
          if (node.attributes.map[&#39;data-mce-bogus&#39;]) {
            continue;
          }
          if (elements[node.name]) {
            return false;
          }
          i = node.attributes.length;
          while (i--) {
            name = node.attributes[i].name;
            if (name === &#39;name&#39; || name.indexOf(&#39;data-mce-bookmark&#39;) === 0) {
              return false;
            }
          }
        }
        if (node.type === 8) {
          return false;
        }
        if (node.type === 3 &amp;&amp; !whiteSpaceRegExp$3.test(node.value)) {
          return false;
        }
        if (node.type === 3 &amp;&amp; node.parent &amp;&amp; whitespace[node.parent.name] &amp;&amp; whiteSpaceRegExp$3.test(node.value)) {
          return false;
        }
        if (predicate &amp;&amp; predicate(node)) {
          return false;
        }
      } while (node = walk$2(node, self));
    }
    return true;
  };
  Node.prototype.walk = function (prev) {
    return walk$2(this, null, prev);
  };
  return Node;
}();

var paddEmptyNode = function (settings, args, blockElements, node) {
  var brPreferred = settings.padd_empty_with_br || args.insert;
  if (brPreferred &amp;&amp; blockElements[node.name]) {
    node.empty().append(new Node$2(&#39;br&#39;, 1)).shortEnded = true;
  } else {
    node.empty().append(new Node$2(&#39;#text&#39;, 3)).value = &#39;\xA0&#39;;
  }
};
var isPaddedWithNbsp = function (node) {
  return hasOnlyChild(node, &#39;#text&#39;) &amp;&amp; node.firstChild.value === &#39;\xA0&#39;;
};
var hasOnlyChild = function (node, name) {
  return node &amp;&amp; node.firstChild &amp;&amp; node.firstChild === node.lastChild &amp;&amp; node.firstChild.name === name;
};
var isPadded = function (schema, node) {
  var rule = schema.getElementRule(node.name);
  return rule &amp;&amp; rule.paddEmpty;
};
var isEmpty$2 = function (schema, nonEmptyElements, whitespaceElements, node) {
  return node.isEmpty(nonEmptyElements, whitespaceElements, function (node) {
    return isPadded(schema, node);
  });
};
var isLineBreakNode = function (node, blockElements) {
  return node &amp;&amp; (blockElements[node.name] || node.name === &#39;br&#39;);
};

var register$2 = function (parser, settings) {
  var schema = parser.schema;
  if (settings.remove_trailing_brs) {
    parser.addNodeFilter(&#39;br&#39;, function (nodes, _, args) {
      var i;
      var l = nodes.length;
      var node;
      var blockElements = Tools.extend({}, schema.getBlockElements());
      var nonEmptyElements = schema.getNonEmptyElements();
      var parent, lastParent, prev, prevName;
      var whiteSpaceElements = schema.getNonEmptyElements();
      var elementRule, textNode;
      blockElements.body = 1;
      for (i = 0; i &lt; l; i++) {
        node = nodes[i];
        parent = node.parent;
        if (blockElements[node.parent.name] &amp;&amp; node === parent.lastChild) {
          prev = node.prev;
          while (prev) {
            prevName = prev.name;
            if (prevName !== &#39;span&#39; || prev.attr(&#39;data-mce-type&#39;) !== &#39;bookmark&#39;) {
              if (prevName !== &#39;br&#39;) {
                break;
              }
              if (prevName === &#39;br&#39;) {
                node = null;
                break;
              }
            }
            prev = prev.prev;
          }
          if (node) {
            node.remove();
            if (isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, parent)) {
              elementRule = schema.getElementRule(parent.name);
              if (elementRule) {
                if (elementRule.removeEmpty) {
                  parent.remove();
                } else if (elementRule.paddEmpty) {
                  paddEmptyNode(settings, args, blockElements, parent);
                }
              }
            }
          }
        } else {
          lastParent = node;
          while (parent &amp;&amp; parent.firstChild === lastParent &amp;&amp; parent.lastChild === lastParent) {
            lastParent = parent;
            if (blockElements[parent.name]) {
              break;
            }
            parent = parent.parent;
          }
          if (lastParent === parent &amp;&amp; settings.padd_empty_with_br !== true) {
            textNode = new Node$2(&#39;#text&#39;, 3);
            textNode.value = &#39;\xA0&#39;;
            node.replace(textNode);
          }
        }
      }
    });
  }
  parser.addAttributeFilter(&#39;href&#39;, function (nodes) {
    var i = nodes.length, node;
    var appendRel = function (rel) {
      var parts = rel.split(&#39; &#39;).filter(function (p) {
        return p.length &gt; 0;
      });
      return parts.concat([&#39;noopener&#39;]).sort().join(&#39; &#39;);
    };
    var addNoOpener = function (rel) {
      var newRel = rel ? Tools.trim(rel) : &#39;&#39;;
      if (!/\b(noopener)\b/g.test(newRel)) {
        return appendRel(newRel);
      } else {
        return newRel;
      }
    };
    if (!settings.allow_unsafe_link_target) {
      while (i--) {
        node = nodes[i];
        if (node.name === &#39;a&#39; &amp;&amp; node.attr(&#39;target&#39;) === &#39;_blank&#39;) {
          node.attr(&#39;rel&#39;, addNoOpener(node.attr(&#39;rel&#39;)));
        }
      }
    }
  });
  if (!settings.allow_html_in_named_anchor) {
    parser.addAttributeFilter(&#39;id,name&#39;, function (nodes) {
      var i = nodes.length, sibling, prevSibling, parent, node;
      while (i--) {
        node = nodes[i];
        if (node.name === &#39;a&#39; &amp;&amp; node.firstChild &amp;&amp; !node.attr(&#39;href&#39;)) {
          parent = node.parent;
          sibling = node.lastChild;
          do {
            prevSibling = sibling.prev;
            parent.insert(sibling, node);
            sibling = prevSibling;
          } while (sibling);
        }
      }
    });
  }
  if (settings.fix_list_elements) {
    parser.addNodeFilter(&#39;ul,ol&#39;, function (nodes) {
      var i = nodes.length, node, parentNode;
      while (i--) {
        node = nodes[i];
        parentNode = node.parent;
        if (parentNode.name === &#39;ul&#39; || parentNode.name === &#39;ol&#39;) {
          if (node.prev &amp;&amp; node.prev.name === &#39;li&#39;) {
            node.prev.append(node);
          } else {
            var li = new Node$2(&#39;li&#39;, 1);
            li.attr(&#39;style&#39;, &#39;list-style-type: none&#39;);
            node.wrap(li);
          }
        }
      }
    });
  }
  if (settings.validate &amp;&amp; schema.getValidClasses()) {
    parser.addAttributeFilter(&#39;class&#39;, function (nodes) {
      var i = nodes.length, node, classList, ci, className, classValue;
      var validClasses = schema.getValidClasses();
      var validClassesMap, valid;
      while (i--) {
        node = nodes[i];
        classList = node.attr(&#39;class&#39;).split(&#39; &#39;);
        classValue = &#39;&#39;;
        for (ci = 0; ci &lt; classList.length; ci++) {
          className = classList[ci];
          valid = false;
          validClassesMap = validClasses[&#39;*&#39;];
          if (validClassesMap &amp;&amp; validClassesMap[className]) {
            valid = true;
          }
          validClassesMap = validClasses[node.name];
          if (!valid &amp;&amp; validClassesMap &amp;&amp; validClassesMap[className]) {
            valid = true;
          }
          if (valid) {
            if (classValue) {
              classValue += &#39; &#39;;
            }
            classValue += className;
          }
        }
        if (!classValue.length) {
          classValue = null;
        }
        node.attr(&#39;class&#39;, classValue);
      }
    });
  }
};

var makeMap$4 = Tools.makeMap, each$i = Tools.each, explode$3 = Tools.explode, extend$3 = Tools.extend;
function DomParser (settings, schema) {
  if (schema === void 0) {
    schema = Schema();
  }
  var nodeFilters = {};
  var attributeFilters = [];
  var matchedNodes = {};
  var matchedAttributes = {};
  settings = settings || {};
  settings.validate = &#39;validate&#39; in settings ? settings.validate : true;
  settings.root_name = settings.root_name || &#39;body&#39;;
  var fixInvalidChildren = function (nodes) {
    var ni, node, parent, parents, newParent, currentNode, tempNode, childNode, i;
    var nonEmptyElements, whitespaceElements, nonSplitableElements, textBlockElements, specialElements, sibling, nextNode;
    nonSplitableElements = makeMap$4(&#39;tr,td,th,tbody,thead,tfoot,table&#39;);
    nonEmptyElements = schema.getNonEmptyElements();
    whitespaceElements = schema.getWhiteSpaceElements();
    textBlockElements = schema.getTextBlockElements();
    specialElements = schema.getSpecialElements();
    for (ni = 0; ni &lt; nodes.length; ni++) {
      node = nodes[ni];
      if (!node.parent || node.fixed) {
        continue;
      }
      if (textBlockElements[node.name] &amp;&amp; node.parent.name === &#39;li&#39;) {
        sibling = node.next;
        while (sibling) {
          if (textBlockElements[sibling.name]) {
            sibling.name = &#39;li&#39;;
            sibling.fixed = true;
            node.parent.insert(sibling, node.parent);
          } else {
            break;
          }
          sibling = sibling.next;
        }
        node.unwrap(node);
        continue;
      }
      parents = [node];
      for (parent = node.parent; parent &amp;&amp; !schema.isValidChild(parent.name, node.name) &amp;&amp; !nonSplitableElements[parent.name]; parent = parent.parent) {
        parents.push(parent);
      }
      if (parent &amp;&amp; parents.length &gt; 1) {
        parents.reverse();
        newParent = currentNode = filterNode(parents[0].clone());
        for (i = 0; i &lt; parents.length - 1; i++) {
          if (schema.isValidChild(currentNode.name, parents[i].name)) {
            tempNode = filterNode(parents[i].clone());
            currentNode.append(tempNode);
          } else {
            tempNode = currentNode;
          }
          for (childNode = parents[i].firstChild; childNode &amp;&amp; childNode !== parents[i + 1];) {
            nextNode = childNode.next;
            tempNode.append(childNode);
            childNode = nextNode;
          }
          currentNode = tempNode;
        }
        if (!isEmpty$2(schema, nonEmptyElements, whitespaceElements, newParent)) {
          parent.insert(newParent, parents[0], true);
          parent.insert(node, newParent);
        } else {
          parent.insert(node, parents[0], true);
        }
        parent = parents[0];
        if (isEmpty$2(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, &#39;br&#39;)) {
          parent.empty().remove();
        }
      } else if (node.parent) {
        if (node.name === &#39;li&#39;) {
          sibling = node.prev;
          if (sibling &amp;&amp; (sibling.name === &#39;ul&#39; || sibling.name === &#39;ul&#39;)) {
            sibling.append(node);
            continue;
          }
          sibling = node.next;
          if (sibling &amp;&amp; (sibling.name === &#39;ul&#39; || sibling.name === &#39;ul&#39;)) {
            sibling.insert(node, sibling.firstChild, true);
            continue;
          }
          node.wrap(filterNode(new Node$2(&#39;ul&#39;, 1)));
          continue;
        }
        if (schema.isValidChild(node.parent.name, &#39;div&#39;) &amp;&amp; schema.isValidChild(&#39;div&#39;, node.name)) {
          node.wrap(filterNode(new Node$2(&#39;div&#39;, 1)));
        } else {
          if (specialElements[node.name]) {
            node.empty().remove();
          } else {
            node.unwrap();
          }
        }
      }
    }
  };
  var filterNode = function (node) {
    var i, name, list;
    if (name in nodeFilters) {
      list = matchedNodes[name];
      if (list) {
        list.push(node);
      } else {
        matchedNodes[name] = [node];
      }
    }
    i = attributeFilters.length;
    while (i--) {
      name = attributeFilters[i].name;
      if (name in node.attributes.map) {
        list = matchedAttributes[name];
        if (list) {
          list.push(node);
        } else {
          matchedAttributes[name] = [node];
        }
      }
    }
    return node;
  };
  var addNodeFilter = function (name, callback) {
    each$i(explode$3(name), function (name) {
      var list = nodeFilters[name];
      if (!list) {
        nodeFilters[name] = list = [];
      }
      list.push(callback);
    });
  };
  var getNodeFilters = function () {
    var out = [];
    for (var name in nodeFilters) {
      if (nodeFilters.hasOwnProperty(name)) {
        out.push({
          name: name,
          callbacks: nodeFilters[name]
        });
      }
    }
    return out;
  };
  var addAttributeFilter = function (name, callback) {
    each$i(explode$3(name), function (name) {
      var i;
      for (i = 0; i &lt; attributeFilters.length; i++) {
        if (attributeFilters[i].name === name) {
          attributeFilters[i].callbacks.push(callback);
          return;
        }
      }
      attributeFilters.push({
        name: name,
        callbacks: [callback]
      });
    });
  };
  var getAttributeFilters = function () {
    return [].concat(attributeFilters);
  };
  var parse = function (html, args) {
    var parser, nodes, i, l, fi, fl, list, name;
    var blockElements;
    var invalidChildren = [];
    var isInWhiteSpacePreservedElement;
    var node;
    args = args || {};
    matchedNodes = {};
    matchedAttributes = {};
    blockElements = extend$3(makeMap$4(&#39;script,style,head,html,body,title,meta,param&#39;), schema.getBlockElements());
    var nonEmptyElements = schema.getNonEmptyElements();
    var children = schema.children;
    var validate = settings.validate;
    var rootBlockName = &#39;forced_root_block&#39; in args ? args.forced_root_block : settings.forced_root_block;
    var whiteSpaceElements = schema.getWhiteSpaceElements();
    var startWhiteSpaceRegExp = /^[ \t\r\n]+/;
    var endWhiteSpaceRegExp = /[ \t\r\n]+$/;
    var allWhiteSpaceRegExp = /[ \t\r\n]+/g;
    var isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
    isInWhiteSpacePreservedElement = whiteSpaceElements.hasOwnProperty(args.context) || whiteSpaceElements.hasOwnProperty(settings.root_name);
    var addRootBlocks = function () {
      var node = rootNode.firstChild, next, rootBlockNode;
      var trim = function (rootBlockNode) {
        if (rootBlockNode) {
          node = rootBlockNode.firstChild;
          if (node &amp;&amp; node.type === 3) {
            node.value = node.value.replace(startWhiteSpaceRegExp, &#39;&#39;);
          }
          node = rootBlockNode.lastChild;
          if (node &amp;&amp; node.type === 3) {
            node.value = node.value.replace(endWhiteSpaceRegExp, &#39;&#39;);
          }
        }
      };
      if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
        return;
      }
      while (node) {
        next = node.next;
        if (node.type === 3 || node.type === 1 &amp;&amp; node.name !== &#39;p&#39; &amp;&amp; !blockElements[node.name] &amp;&amp; !node.attr(&#39;data-mce-type&#39;)) {
          if (!rootBlockNode) {
            rootBlockNode = createNode(rootBlockName, 1);
            rootBlockNode.attr(settings.forced_root_block_attrs);
            rootNode.insert(rootBlockNode, node);
            rootBlockNode.append(node);
          } else {
            rootBlockNode.append(node);
          }
        } else {
          trim(rootBlockNode);
          rootBlockNode = null;
        }
        node = next;
      }
      trim(rootBlockNode);
    };
    var createNode = function (name, type) {
      var node = new Node$2(name, type);
      var list;
      if (name in nodeFilters) {
        list = matchedNodes[name];
        if (list) {
          list.push(node);
        } else {
          matchedNodes[name] = [node];
        }
      }
      return node;
    };
    var removeWhitespaceBefore = function (node) {
      var textNode, textNodeNext, textVal, sibling;
      var blockElements = schema.getBlockElements();
      for (textNode = node.prev; textNode &amp;&amp; textNode.type === 3;) {
        textVal = textNode.value.replace(endWhiteSpaceRegExp, &#39;&#39;);
        if (textVal.length &gt; 0) {
          textNode.value = textVal;
          return;
        }
        textNodeNext = textNode.next;
        if (textNodeNext) {
          if (textNodeNext.type === 3 &amp;&amp; textNodeNext.value.length) {
            textNode = textNode.prev;
            continue;
          }
          if (!blockElements[textNodeNext.name] &amp;&amp; textNodeNext.name !== &#39;script&#39; &amp;&amp; textNodeNext.name !== &#39;style&#39;) {
            textNode = textNode.prev;
            continue;
          }
        }
        sibling = textNode.prev;
        textNode.remove();
        textNode = sibling;
      }
    };
    var cloneAndExcludeBlocks = function (input) {
      var name;
      var output = {};
      for (name in input) {
        if (name !== &#39;li&#39; &amp;&amp; name !== &#39;p&#39;) {
          output[name] = input[name];
        }
      }
      return output;
    };
    parser = SaxParser$1({
      validate: validate,
      allow_script_urls: settings.allow_script_urls,
      allow_conditional_comments: settings.allow_conditional_comments,
      self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
      cdata: function (text) {
        node.append(createNode(&#39;#cdata&#39;, 4)).value = text;
      },
      text: function (text, raw) {
        var textNode;
        if (!isInWhiteSpacePreservedElement) {
          text = text.replace(allWhiteSpaceRegExp, &#39; &#39;);
          if (isLineBreakNode(node.lastChild, blockElements)) {
            text = text.replace(startWhiteSpaceRegExp, &#39;&#39;);
          }
        }
        if (text.length !== 0) {
          textNode = createNode(&#39;#text&#39;, 3);
          textNode.raw = !!raw;
          node.append(textNode).value = text;
        }
      },
      comment: function (text) {
        node.append(createNode(&#39;#comment&#39;, 8)).value = text;
      },
      pi: function (name, text) {
        node.append(createNode(name, 7)).value = text;
        removeWhitespaceBefore(node);
      },
      doctype: function (text) {
        var newNode;
        newNode = node.append(createNode(&#39;#doctype&#39;, 10));
        newNode.value = text;
        removeWhitespaceBefore(node);
      },
      start: function (name, attrs, empty) {
        var newNode, attrFiltersLen, elementRule, attrName, parent;
        elementRule = validate ? schema.getElementRule(name) : {};
        if (elementRule) {
          newNode = createNode(elementRule.outputName || name, 1);
          newNode.attributes = attrs;
          newNode.shortEnded = empty;
          node.append(newNode);
          parent = children[node.name];
          if (parent &amp;&amp; children[newNode.name] &amp;&amp; !parent[newNode.name]) {
            invalidChildren.push(newNode);
          }
          attrFiltersLen = attributeFilters.length;
          while (attrFiltersLen--) {
            attrName = attributeFilters[attrFiltersLen].name;
            if (attrName in attrs.map) {
              list = matchedAttributes[attrName];
              if (list) {
                list.push(newNode);
              } else {
                matchedAttributes[attrName] = [newNode];
              }
            }
          }
          if (blockElements[name]) {
            removeWhitespaceBefore(newNode);
          }
          if (!empty) {
            node = newNode;
          }
          if (!isInWhiteSpacePreservedElement &amp;&amp; whiteSpaceElements[name]) {
            isInWhiteSpacePreservedElement = true;
          }
        }
      },
      end: function (name) {
        var textNode, elementRule, text, sibling, tempNode;
        elementRule = validate ? schema.getElementRule(name) : {};
        if (elementRule) {
          if (blockElements[name]) {
            if (!isInWhiteSpacePreservedElement) {
              textNode = node.firstChild;
              if (textNode &amp;&amp; textNode.type === 3) {
                text = textNode.value.replace(startWhiteSpaceRegExp, &#39;&#39;);
                if (text.length &gt; 0) {
                  textNode.value = text;
                  textNode = textNode.next;
                } else {
                  sibling = textNode.next;
                  textNode.remove();
                  textNode = sibling;
                  while (textNode &amp;&amp; textNode.type === 3) {
                    text = textNode.value;
                    sibling = textNode.next;
                    if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                      textNode.remove();
                      textNode = sibling;
                    }
                    textNode = sibling;
                  }
                }
              }
              textNode = node.lastChild;
              if (textNode &amp;&amp; textNode.type === 3) {
                text = textNode.value.replace(endWhiteSpaceRegExp, &#39;&#39;);
                if (text.length &gt; 0) {
                  textNode.value = text;
                  textNode = textNode.prev;
                } else {
                  sibling = textNode.prev;
                  textNode.remove();
                  textNode = sibling;
                  while (textNode &amp;&amp; textNode.type === 3) {
                    text = textNode.value;
                    sibling = textNode.prev;
                    if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
                      textNode.remove();
                      textNode = sibling;
                    }
                    textNode = sibling;
                  }
                }
              }
            }
          }
          if (isInWhiteSpacePreservedElement &amp;&amp; whiteSpaceElements[name]) {
            isInWhiteSpacePreservedElement = false;
          }
          if (elementRule.removeEmpty &amp;&amp; isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node)) {
            if (!node.attributes.map.name &amp;&amp; !node.attr(&#39;id&#39;)) {
              tempNode = node.parent;
              if (blockElements[node.name]) {
                node.empty().remove();
              } else {
                node.unwrap();
              }
              node = tempNode;
              return;
            }
          }
          if (elementRule.paddEmpty &amp;&amp; (isPaddedWithNbsp(node) || isEmpty$2(schema, nonEmptyElements, whiteSpaceElements, node))) {
            paddEmptyNode(settings, args, blockElements, node);
          }
          node = node.parent;
        }
      }
    }, schema);
    var rootNode = node = new Node$2(args.context || settings.root_name, 11);
    parser.parse(html);
    if (validate &amp;&amp; invalidChildren.length) {
      if (!args.context) {
        fixInvalidChildren(invalidChildren);
      } else {
        args.invalid = true;
      }
    }
    if (rootBlockName &amp;&amp; (rootNode.name === &#39;body&#39; || args.isRootContent)) {
      addRootBlocks();
    }
    if (!args.invalid) {
      for (name in matchedNodes) {
        list = nodeFilters[name];
        nodes = matchedNodes[name];
        fi = nodes.length;
        while (fi--) {
          if (!nodes[fi].parent) {
            nodes.splice(fi, 1);
          }
        }
        for (i = 0, l = list.length; i &lt; l; i++) {
          list[i](nodes, name, args);
        }
      }
      for (i = 0, l = attributeFilters.length; i &lt; l; i++) {
        list = attributeFilters[i];
        if (list.name in matchedAttributes) {
          nodes = matchedAttributes[list.name];
          fi = nodes.length;
          while (fi--) {
            if (!nodes[fi].parent) {
              nodes.splice(fi, 1);
            }
          }
          for (fi = 0, fl = list.callbacks.length; fi &lt; fl; fi++) {
            list.callbacks[fi](nodes, list.name, args);
          }
        }
      }
    }
    return rootNode;
  };
  var exports = {
    schema: schema,
    addAttributeFilter: addAttributeFilter,
    getAttributeFilters: getAttributeFilters,
    addNodeFilter: addNodeFilter,
    getNodeFilters: getNodeFilters,
    filterNode: filterNode,
    parse: parse
  };
  register$2(exports, settings);
  LegacyFilter.register(exports, settings);
  return exports;
}

var addTempAttr = function (htmlParser, tempAttrs, name) {
  if (Tools.inArray(tempAttrs, name) === -1) {
    htmlParser.addAttributeFilter(name, function (nodes, name) {
      var i = nodes.length;
      while (i--) {
        nodes[i].attr(name, null);
      }
    });
    tempAttrs.push(name);
  }
};
var postProcess$1 = function (editor, args, content) {
  if (!args.no_events &amp;&amp; editor) {
    var outArgs = Events.firePostProcess(editor, merge(args, { content: content }));
    return outArgs.content;
  } else {
    return content;
  }
};
var getHtmlFromNode = function (dom, node, args) {
  var html = Zwsp.trim(args.getInner ? node.innerHTML : dom.getOuterHTML(node));
  return args.selection || isWsPreserveElement(Element$$1.fromDom(node)) ? html : Tools.trim(html);
};
var parseHtml = function (htmlParser, html, args) {
  var parserArgs = args.selection ? merge({ forced_root_block: false }, args) : args;
  var rootNode = htmlParser.parse(html, parserArgs);
  DomSerializerFilters.trimTrailingBr(rootNode);
  return rootNode;
};
var serializeNode = function (settings, schema, node) {
  var htmlSerializer = Serializer(settings, schema);
  return htmlSerializer.serialize(node);
};
var toHtml = function (editor, settings, schema, rootNode, args) {
  var content = serializeNode(settings, schema, rootNode);
  return postProcess$1(editor, args, content);
};
function DomSerializer (settings, editor) {
  var dom, schema, htmlParser;
  var tempAttrs = [&#39;data-mce-selected&#39;];
  dom = editor &amp;&amp; editor.dom ? editor.dom : DOMUtils$1.DOM;
  schema = editor &amp;&amp; editor.schema ? editor.schema : Schema(settings);
  settings.entity_encoding = settings.entity_encoding || &#39;named&#39;;
  settings.remove_trailing_brs = &#39;remove_trailing_brs&#39; in settings ? settings.remove_trailing_brs : true;
  htmlParser = DomParser(settings, schema);
  DomSerializerFilters.register(htmlParser, settings, dom);
  var serialize = function (node, parserArgs) {
    var args = merge({ format: &#39;html&#39; }, parserArgs ? parserArgs : {});
    var targetNode = DomSerializerPreProcess.process(editor, node, args);
    var html = getHtmlFromNode(dom, targetNode, args);
    var rootNode = parseHtml(htmlParser, html, args);
    return args.format === &#39;tree&#39; ? rootNode : toHtml(editor, settings, schema, rootNode, args);
  };
  return {
    schema: schema,
    addNodeFilter: htmlParser.addNodeFilter,
    addAttributeFilter: htmlParser.addAttributeFilter,
    serialize: serialize,
    addRules: function (rules) {
      schema.addValidElements(rules);
    },
    setRules: function (rules) {
      schema.setValidElements(rules);
    },
    addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
    getTempAttrs: function () {
      return tempAttrs;
    }
  };
}

function Serializer$1 (settings, editor) {
  var domSerializer = DomSerializer(settings, editor);
  return {
    schema: domSerializer.schema,
    addNodeFilter: domSerializer.addNodeFilter,
    addAttributeFilter: domSerializer.addAttributeFilter,
    serialize: domSerializer.serialize,
    addRules: domSerializer.addRules,
    setRules: domSerializer.setRules,
    addTempAttr: domSerializer.addTempAttr,
    getTempAttrs: domSerializer.getTempAttrs
  };
}

function BookmarkManager(selection) {
  return {
    getBookmark: curry(Bookmarks.getBookmark, selection),
    moveToBookmark: curry(Bookmarks.moveToBookmark, selection)
  };
}
(function (BookmarkManager) {
  BookmarkManager.isBookmarkNode = Bookmarks.isBookmarkNode;
}(BookmarkManager || (BookmarkManager = {})));
var BookmarkManager$1 = BookmarkManager;

var isContentEditableFalse$a = NodeType.isContentEditableFalse;
var isContentEditableTrue$6 = NodeType.isContentEditableTrue;
var getContentEditableRoot$2 = function (root, node) {
  while (node &amp;&amp; node !== root) {
    if (isContentEditableTrue$6(node) || isContentEditableFalse$a(node)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
};
var ControlSelection = function (selection, editor) {
  var dom = editor.dom, each = Tools.each;
  var selectedElm, selectedElmGhost, resizeHelper, resizeHandles, selectedHandle;
  var startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
  var width, height;
  var editableDoc = editor.getDoc(), rootDocument = document;
  var abs = Math.abs, round = Math.round, rootElement = editor.getBody();
  var startScrollWidth, startScrollHeight;
  resizeHandles = {
    nw: [
      0,
      0,
      -1,
      -1
    ],
    ne: [
      1,
      0,
      1,
      -1
    ],
    se: [
      1,
      1,
      1,
      1
    ],
    sw: [
      0,
      1,
      -1,
      1
    ]
  };
  var rootClass = &#39;.mce-content-body&#39;;
  editor.contentStyles.push(rootClass + &#39; div.mce-resizehandle {&#39; + &#39;position: absolute;&#39; + &#39;border: 1px solid black;&#39; + &#39;box-sizing: content-box;&#39; + &#39;background: #FFF;&#39; + &#39;width: 7px;&#39; + &#39;height: 7px;&#39; + &#39;z-index: 10000&#39; + &#39;}&#39; + rootClass + &#39; .mce-resizehandle:hover {&#39; + &#39;background: #000&#39; + &#39;}&#39; + rootClass + &#39; img[data-mce-selected],&#39; + rootClass + &#39; hr[data-mce-selected] {&#39; + &#39;outline: 1px solid black;&#39; + &#39;resize: none&#39; + &#39;}&#39; + rootClass + &#39; .mce-clonedresizable {&#39; + &#39;position: absolute;&#39; + (Env.gecko ? &#39;&#39; : &#39;outline: 1px dashed black;&#39;) + &#39;opacity: .5;&#39; + &#39;filter: alpha(opacity=50);&#39; + &#39;z-index: 10000&#39; + &#39;}&#39; + rootClass + &#39; .mce-resize-helper {&#39; + &#39;background: #555;&#39; + &#39;background: rgba(0,0,0,0.75);&#39; + &#39;border-radius: 3px;&#39; + &#39;border: 1px;&#39; + &#39;color: white;&#39; + &#39;display: none;&#39; + &#39;font-family: sans-serif;&#39; + &#39;font-size: 12px;&#39; + &#39;white-space: nowrap;&#39; + &#39;line-height: 14px;&#39; + &#39;margin: 5px 10px;&#39; + &#39;padding: 5px;&#39; + &#39;position: absolute;&#39; + &#39;z-index: 10001&#39; + &#39;}&#39;);
  var isImage = function (elm) {
    return elm &amp;&amp; (elm.nodeName === &#39;IMG&#39; || editor.dom.is(elm, &#39;figure.image&#39;));
  };
  var isEventOnImageOutsideRange = function (evt, range) {
    return isImage(evt.target) &amp;&amp; !RangePoint.isXYWithinRange(evt.clientX, evt.clientY, range);
  };
  var contextMenuSelectImage = function (evt) {
    var target = evt.target;
    if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) &amp;&amp; !evt.isDefaultPrevented()) {
      evt.preventDefault();
      editor.selection.select(target);
    }
  };
  var getResizeTarget = function (elm) {
    return editor.dom.is(elm, &#39;figure.image&#39;) ? elm.querySelector(&#39;img&#39;) : elm;
  };
  var isResizable = function (elm) {
    var selector = editor.settings.object_resizing;
    if (selector === false || Env.iOS) {
      return false;
    }
    if (typeof selector !== &#39;string&#39;) {
      selector = &#39;table,img,figure.image,div&#39;;
    }
    if (elm.getAttribute(&#39;data-mce-resize&#39;) === &#39;false&#39;) {
      return false;
    }
    if (elm === editor.getBody()) {
      return false;
    }
    return is$1(Element$$1.fromDom(elm), selector);
  };
  var resizeGhostElement = function (e) {
    var deltaX, deltaY, proportional;
    var resizeHelperX, resizeHelperY;
    deltaX = e.screenX - startX;
    deltaY = e.screenY - startY;
    width = deltaX * selectedHandle[2] + startW;
    height = deltaY * selectedHandle[3] + startH;
    width = width &lt; 5 ? 5 : width;
    height = height &lt; 5 ? 5 : height;
    if (isImage(selectedElm) &amp;&amp; editor.settings.resize_img_proportional !== false) {
      proportional = !VK.modifierPressed(e);
    } else {
      proportional = VK.modifierPressed(e) || isImage(selectedElm) &amp;&amp; selectedHandle[2] * selectedHandle[3] !== 0;
    }
    if (proportional) {
      if (abs(deltaX) &gt; abs(deltaY)) {
        height = round(width * ratio);
        width = round(height / ratio);
      } else {
        width = round(height / ratio);
        height = round(width * ratio);
      }
    }
    dom.setStyles(getResizeTarget(selectedElmGhost), {
      width: width,
      height: height
    });
    resizeHelperX = selectedHandle.startPos.x + deltaX;
    resizeHelperY = selectedHandle.startPos.y + deltaY;
    resizeHelperX = resizeHelperX &gt; 0 ? resizeHelperX : 0;
    resizeHelperY = resizeHelperY &gt; 0 ? resizeHelperY : 0;
    dom.setStyles(resizeHelper, {
      left: resizeHelperX,
      top: resizeHelperY,
      display: &#39;block&#39;
    });
    resizeHelper.innerHTML = width + &#39; &amp;times; &#39; + height;
    if (selectedHandle[2] &lt; 0 &amp;&amp; selectedElmGhost.clientWidth &lt;= width) {
      dom.setStyle(selectedElmGhost, &#39;left&#39;, selectedElmX + (startW - width));
    }
    if (selectedHandle[3] &lt; 0 &amp;&amp; selectedElmGhost.clientHeight &lt;= height) {
      dom.setStyle(selectedElmGhost, &#39;top&#39;, selectedElmY + (startH - height));
    }
    deltaX = rootElement.scrollWidth - startScrollWidth;
    deltaY = rootElement.scrollHeight - startScrollHeight;
    if (deltaX + deltaY !== 0) {
      dom.setStyles(resizeHelper, {
        left: resizeHelperX - deltaX,
        top: resizeHelperY - deltaY
      });
    }
    if (!resizeStarted) {
      Events.fireObjectResizeStart(editor, selectedElm, startW, startH);
      resizeStarted = true;
    }
  };
  var endGhostResize = function () {
    resizeStarted = false;
    var setSizeProp = function (name$$1, value) {
      if (value) {
        if (selectedElm.style[name$$1] || !editor.schema.isValid(selectedElm.nodeName.toLowerCase(), name$$1)) {
          dom.setStyle(getResizeTarget(selectedElm), name$$1, value);
        } else {
          dom.setAttrib(getResizeTarget(selectedElm), name$$1, value);
        }
      }
    };
    setSizeProp(&#39;width&#39;, width);
    setSizeProp(&#39;height&#39;, height);
    dom.unbind(editableDoc, &#39;mousemove&#39;, resizeGhostElement);
    dom.unbind(editableDoc, &#39;mouseup&#39;, endGhostResize);
    if (rootDocument !== editableDoc) {
      dom.unbind(rootDocument, &#39;mousemove&#39;, resizeGhostElement);
      dom.unbind(rootDocument, &#39;mouseup&#39;, endGhostResize);
    }
    dom.remove(selectedElmGhost);
    dom.remove(resizeHelper);
    showResizeRect(selectedElm);
    Events.fireObjectResized(editor, selectedElm, width, height);
    dom.setAttrib(selectedElm, &#39;style&#39;, dom.getAttrib(selectedElm, &#39;style&#39;));
    editor.nodeChanged();
  };
  var showResizeRect = function (targetElm) {
    var position, targetWidth, targetHeight, e, rect;
    hideResizeRect();
    unbindResizeHandleEvents();
    position = dom.getPos(targetElm, rootElement);
    selectedElmX = position.x;
    selectedElmY = position.y;
    rect = targetElm.getBoundingClientRect();
    targetWidth = rect.width || rect.right - rect.left;
    targetHeight = rect.height || rect.bottom - rect.top;
    if (selectedElm !== targetElm) {
      selectedElm = targetElm;
      width = height = 0;
    }
    e = editor.fire(&#39;ObjectSelected&#39;, { target: targetElm });
    if (isResizable(targetElm) &amp;&amp; !e.isDefaultPrevented()) {
      each(resizeHandles, function (handle, name$$1) {
        var handleElm;
        var startDrag = function (e) {
          startX = e.screenX;
          startY = e.screenY;
          startW = getResizeTarget(selectedElm).clientWidth;
          startH = getResizeTarget(selectedElm).clientHeight;
          ratio = startH / startW;
          selectedHandle = handle;
          handle.startPos = {
            x: targetWidth * handle[0] + selectedElmX,
            y: targetHeight * handle[1] + selectedElmY
          };
          startScrollWidth = rootElement.scrollWidth;
          startScrollHeight = rootElement.scrollHeight;
          selectedElmGhost = selectedElm.cloneNode(true);
          dom.addClass(selectedElmGhost, &#39;mce-clonedresizable&#39;);
          dom.setAttrib(selectedElmGhost, &#39;data-mce-bogus&#39;, &#39;all&#39;);
          selectedElmGhost.contentEditable = false;
          selectedElmGhost.unSelectabe = true;
          dom.setStyles(selectedElmGhost, {
            left: selectedElmX,
            top: selectedElmY,
            margin: 0
          });
          selectedElmGhost.removeAttribute(&#39;data-mce-selected&#39;);
          rootElement.appendChild(selectedElmGhost);
          dom.bind(editableDoc, &#39;mousemove&#39;, resizeGhostElement);
          dom.bind(editableDoc, &#39;mouseup&#39;, endGhostResize);
          if (rootDocument !== editableDoc) {
            dom.bind(rootDocument, &#39;mousemove&#39;, resizeGhostElement);
            dom.bind(rootDocument, &#39;mouseup&#39;, endGhostResize);
          }
          resizeHelper = dom.add(rootElement, &#39;div&#39;, {
            &#39;class&#39;: &#39;mce-resize-helper&#39;,
            &#39;data-mce-bogus&#39;: &#39;all&#39;
          }, startW + &#39; &amp;times; &#39; + startH);
        };
        handleElm = dom.get(&#39;mceResizeHandle&#39; + name$$1);
        if (handleElm) {
          dom.remove(handleElm);
        }
        handleElm = dom.add(rootElement, &#39;div&#39;, {
          &#39;id&#39;: &#39;mceResizeHandle&#39; + name$$1,
          &#39;data-mce-bogus&#39;: &#39;all&#39;,
          &#39;class&#39;: &#39;mce-resizehandle&#39;,
          &#39;unselectable&#39;: true,
          &#39;style&#39;: &#39;cursor:&#39; + name$$1 + &#39;-resize; margin:0; padding:0&#39;
        });
        if (Env.ie === 11) {
          handleElm.contentEditable = false;
        }
        dom.bind(handleElm, &#39;mousedown&#39;, function (e) {
          e.stopImmediatePropagation();
          e.preventDefault();
          startDrag(e);
        });
        handle.elm = handleElm;
        dom.setStyles(handleElm, {
          left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,
          top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2
        });
      });
    } else {
      hideResizeRect();
    }
    selectedElm.setAttribute(&#39;data-mce-selected&#39;, &#39;1&#39;);
  };
  var hideResizeRect = function () {
    var name$$1, handleElm;
    unbindResizeHandleEvents();
    if (selectedElm) {
      selectedElm.removeAttribute(&#39;data-mce-selected&#39;);
    }
    for (name$$1 in resizeHandles) {
      handleElm = dom.get(&#39;mceResizeHandle&#39; + name$$1);
      if (handleElm) {
        dom.unbind(handleElm);
        dom.remove(handleElm);
      }
    }
  };
  var updateResizeRect = function (e) {
    var startElm, controlElm;
    var isChildOrEqual = function (node, parent$$1) {
      if (node) {
        do {
          if (node === parent$$1) {
            return true;
          }
        } while (node = node.parentNode);
      }
    };
    if (resizeStarted || editor.removed) {
      return;
    }
    each(dom.select(&#39;img[data-mce-selected],hr[data-mce-selected]&#39;), function (img) {
      img.removeAttribute(&#39;data-mce-selected&#39;);
    });
    controlElm = e.type === &#39;mousedown&#39; ? e.target : selection.getNode();
    controlElm = dom.$(controlElm).closest(&#39;table,img,figure.image,hr&#39;)[0];
    if (isChildOrEqual(controlElm, rootElement)) {
      disableGeckoResize();
      startElm = selection.getStart(true);
      if (isChildOrEqual(startElm, controlElm) &amp;&amp; isChildOrEqual(selection.getEnd(true), controlElm)) {
        showResizeRect(controlElm);
        return;
      }
    }
    hideResizeRect();
  };
  var isWithinContentEditableFalse = function (elm) {
    return isContentEditableFalse$a(getContentEditableRoot$2(editor.getBody(), elm));
  };
  var unbindResizeHandleEvents = function () {
    for (var name$$1 in resizeHandles) {
      var handle = resizeHandles[name$$1];
      if (handle.elm) {
        dom.unbind(handle.elm);
        delete handle.elm;
      }
    }
  };
  var disableGeckoResize = function () {
    try {
      editor.getDoc().execCommand(&#39;enableObjectResizing&#39;, false, false);
    } catch (ex) {
    }
  };
  editor.on(&#39;init&#39;, function () {
    disableGeckoResize();
    if (Env.ie &amp;&amp; Env.ie &gt;= 11) {
      editor.on(&#39;mousedown click&#39;, function (e) {
        var target = e.target, nodeName = target.nodeName;
        if (!resizeStarted &amp;&amp; /^(TABLE|IMG|HR)$/.test(nodeName) &amp;&amp; !isWithinContentEditableFalse(target)) {
          if (e.button !== 2) {
            editor.selection.select(target, nodeName === &#39;TABLE&#39;);
          }
          if (e.type === &#39;mousedown&#39;) {
            editor.nodeChanged();
          }
        }
      });
      editor.dom.bind(rootElement, &#39;mscontrolselect&#39;, function (e) {
        var delayedSelect = function (node) {
          Delay.setEditorTimeout(editor, function () {
            editor.selection.select(node);
          });
        };
        if (isWithinContentEditableFalse(e.target)) {
          e.preventDefault();
          delayedSelect(e.target);
          return;
        }
        if (/^(TABLE|IMG|HR)$/.test(e.target.nodeName)) {
          e.preventDefault();
          if (e.target.tagName === &#39;IMG&#39;) {
            delayedSelect(e.target);
          }
        }
      });
    }
    var throttledUpdateResizeRect = Delay.throttle(function (e) {
      if (!editor.composing) {
        updateResizeRect(e);
      }
    });
    editor.on(&#39;nodechange ResizeEditor ResizeWindow drop FullscreenStateChanged&#39;, throttledUpdateResizeRect);
    editor.on(&#39;keyup compositionend&#39;, function (e) {
      if (selectedElm &amp;&amp; selectedElm.nodeName === &#39;TABLE&#39;) {
        throttledUpdateResizeRect(e);
      }
    });
    editor.on(&#39;hide blur&#39;, hideResizeRect);
    editor.on(&#39;contextmenu&#39;, contextMenuSelectImage);
  });
  editor.on(&#39;remove&#39;, unbindResizeHandleEvents);
  var destroy = function () {
    selectedElm = selectedElmGhost = null;
  };
  return {
    isResizable: isResizable,
    showResizeRect: showResizeRect,
    hideResizeRect: hideResizeRect,
    updateResizeRect: updateResizeRect,
    destroy: destroy
  };
};

var getPos$1 = function (elm) {
  var x = 0, y = 0;
  var offsetParent = elm;
  while (offsetParent &amp;&amp; offsetParent.nodeType) {
    x += offsetParent.offsetLeft || 0;
    y += offsetParent.offsetTop || 0;
    offsetParent = offsetParent.offsetParent;
  }
  return {
    x: x,
    y: y
  };
};
var fireScrollIntoViewEvent = function (editor, elm, alignToTop) {
  var scrollEvent = {
    elm: elm,
    alignToTop: alignToTop
  };
  editor.fire(&#39;scrollIntoView&#39;, scrollEvent);
  return scrollEvent.isDefaultPrevented();
};
var scrollElementIntoView = function (editor, elm, alignToTop) {
  var y, viewPort;
  var dom = editor.dom;
  var root = dom.getRoot();
  var viewPortY, viewPortH, offsetY = 0;
  if (fireScrollIntoViewEvent(editor, elm, alignToTop)) {
    return;
  }
  if (!NodeType.isElement(elm)) {
    return;
  }
  if (alignToTop === false) {
    offsetY = elm.offsetHeight;
  }
  if (root.nodeName !== &#39;BODY&#39;) {
    var scrollContainer = editor.selection.getScrollContainer();
    if (scrollContainer) {
      y = getPos$1(elm).y - getPos$1(scrollContainer).y + offsetY;
      viewPortH = scrollContainer.clientHeight;
      viewPortY = scrollContainer.scrollTop;
      if (y &lt; viewPortY || y + 25 &gt; viewPortY + viewPortH) {
        scrollContainer.scrollTop = y &lt; viewPortY ? y : y - viewPortH + 25;
      }
      return;
    }
  }
  viewPort = dom.getViewPort(editor.getWin());
  y = dom.getPos(elm).y + offsetY;
  viewPortY = viewPort.y;
  viewPortH = viewPort.h;
  if (y &lt; viewPort.y || y + 25 &gt; viewPortY + viewPortH) {
    editor.getWin().scrollTo(0, y &lt; viewPortY ? y : y - viewPortH + 25);
  }
};
var getViewPortRect = function (editor) {
  if (editor.inline) {
    return editor.getBody().getBoundingClientRect();
  } else {
    var win = editor.getWin();
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight,
      width: win.innerWidth,
      height: win.innerHeight
    };
  }
};
var scrollBy = function (editor, dx, dy) {
  if (editor.inline) {
    editor.getBody().scrollLeft += dx;
    editor.getBody().scrollTop += dy;
  } else {
    editor.getWin().scrollBy(dx, dy);
  }
};
var scrollRangeIntoView = function (editor, rng) {
  head(CaretPosition.fromRangeStart(rng).getClientRects()).each(function (rngRect) {
    var bodyRect = getViewPortRect(editor);
    var overflow = getOverflow(bodyRect, rngRect);
    var margin = 4;
    var dx = overflow.x &gt; 0 ? overflow.x + margin : overflow.x - margin;
    var dy = overflow.y &gt; 0 ? overflow.y + margin : overflow.y - margin;
    scrollBy(editor, overflow.x !== 0 ? dx : 0, overflow.y !== 0 ? dy : 0);
  });
};
var ScrollIntoView = {
  scrollElementIntoView: scrollElementIntoView,
  scrollRangeIntoView: scrollRangeIntoView
};

var hasCeProperty = function (node) {
  return NodeType.isContentEditableTrue(node) || NodeType.isContentEditableFalse(node);
};
var findParent$1 = function (node, rootNode, predicate) {
  while (node &amp;&amp; node !== rootNode) {
    if (predicate(node)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
};
var findClosestIeRange = function (clientX, clientY, doc) {
  var element, rng, rects;
  element = doc.elementFromPoint(clientX, clientY);
  rng = doc.body.createTextRange();
  if (!element || element.tagName === &#39;HTML&#39;) {
    element = doc.body;
  }
  rng.moveToElementText(element);
  rects = Tools.toArray(rng.getClientRects());
  rects = rects.sort(function (a, b) {
    a = Math.abs(Math.max(a.top - clientY, a.bottom - clientY));
    b = Math.abs(Math.max(b.top - clientY, b.bottom - clientY));
    return a - b;
  });
  if (rects.length &gt; 0) {
    clientY = (rects[0].bottom + rects[0].top) / 2;
    try {
      rng.moveToPoint(clientX, clientY);
      rng.collapse(true);
      return rng;
    } catch (ex) {
    }
  }
  return null;
};
var moveOutOfContentEditableFalse = function (rng, rootNode) {
  var parentElement = rng &amp;&amp; rng.parentElement ? rng.parentElement() : null;
  return NodeType.isContentEditableFalse(findParent$1(parentElement, rootNode, hasCeProperty)) ? null : rng;
};
var fromPoint$1 = function (clientX, clientY, doc) {
  var rng, point;
  var pointDoc = doc;
  if (pointDoc.caretPositionFromPoint) {
    point = pointDoc.caretPositionFromPoint(clientX, clientY);
    if (point) {
      rng = doc.createRange();
      rng.setStart(point.offsetNode, point.offset);
      rng.collapse(true);
    }
  } else if (doc.caretRangeFromPoint) {
    rng = doc.caretRangeFromPoint(clientX, clientY);
  } else if (pointDoc.body.createTextRange) {
    rng = pointDoc.body.createTextRange();
    try {
      rng.moveToPoint(clientX, clientY);
      rng.collapse(true);
    } catch (ex) {
      rng = findClosestIeRange(clientX, clientY, doc);
    }
    return moveOutOfContentEditableFalse(rng, doc.body);
  }
  return rng;
};
var CaretRangeFromPoint = { fromPoint: fromPoint$1 };

var processRanges = function (editor, ranges) {
  return map(ranges, function (range$$1) {
    var evt = editor.fire(&#39;GetSelectionRange&#39;, { range: range$$1 });
    return evt.range !== range$$1 ? evt.range : range$$1;
  });
};
var EventProcessRanges = { processRanges: processRanges };

var fromElements = function (elements, scope) {
  var doc = scope || document;
  var fragment = doc.createDocumentFragment();
  each(elements, function (element) {
    fragment.appendChild(element.dom());
  });
  return Element$$1.fromDom(fragment);
};

var tableModel = Immutable(&#39;element&#39;, &#39;width&#39;, &#39;rows&#39;);
var tableRow = Immutable(&#39;element&#39;, &#39;cells&#39;);
var cellPosition = Immutable(&#39;x&#39;, &#39;y&#39;);
var getSpan = function (td, key) {
  var value = parseInt(get$1(td, key), 10);
  return isNaN(value) ? 1 : value;
};
var fillout = function (table, x, y, tr, td) {
  var rowspan = getSpan(td, &#39;rowspan&#39;);
  var colspan = getSpan(td, &#39;colspan&#39;);
  var rows = table.rows();
  for (var y2 = y; y2 &lt; y + rowspan; y2++) {
    if (!rows[y2]) {
      rows[y2] = tableRow(deep(tr), []);
    }
    for (var x2 = x; x2 &lt; x + colspan; x2++) {
      var cells = rows[y2].cells();
      cells[x2] = y2 === y &amp;&amp; x2 === x ? td : shallow(td);
    }
  }
};
var cellExists = function (table, x, y) {
  var rows = table.rows();
  var cells = rows[y] ? rows[y].cells() : [];
  return !!cells[x];
};
var skipCellsX = function (table, x, y) {
  while (cellExists(table, x, y)) {
    x++;
  }
  return x;
};
var getWidth = function (rows) {
  return foldl(rows, function (acc, row) {
    return row.cells().length &gt; acc ? row.cells().length : acc;
  }, 0);
};
var findElementPos = function (table, element) {
  var rows = table.rows();
  for (var y = 0; y &lt; rows.length; y++) {
    var cells = rows[y].cells();
    for (var x = 0; x &lt; cells.length; x++) {
      if (eq(cells[x], element)) {
        return Option.some(cellPosition(x, y));
      }
    }
  }
  return Option.none();
};
var extractRows = function (table, sx, sy, ex, ey) {
  var newRows = [];
  var rows = table.rows();
  for (var y = sy; y &lt;= ey; y++) {
    var cells = rows[y].cells();
    var slice = sx &lt; ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);
    newRows.push(tableRow(rows[y].element(), slice));
  }
  return newRows;
};
var subTable = function (table, startPos, endPos) {
  var sx = startPos.x(), sy = startPos.y();
  var ex = endPos.x(), ey = endPos.y();
  var newRows = sy &lt; ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);
  return tableModel(table.element(), getWidth(newRows), newRows);
};
var createDomTable = function (table, rows) {
  var tableElement = shallow(table.element());
  var tableBody = Element$$1.fromTag(&#39;tbody&#39;);
  append$1(tableBody, rows);
  append(tableElement, tableBody);
  return tableElement;
};
var modelRowsToDomRows = function (table) {
  return map(table.rows(), function (row) {
    var cells = map(row.cells(), function (cell) {
      var td = deep(cell);
      remove(td, &#39;colspan&#39;);
      remove(td, &#39;rowspan&#39;);
      return td;
    });
    var tr = shallow(row.element());
    append$1(tr, cells);
    return tr;
  });
};
var fromDom$2 = function (tableElm) {
  var table = tableModel(shallow(tableElm), 0, []);
  each(descendants$1(tableElm, &#39;tr&#39;), function (tr, y) {
    each(descendants$1(tr, &#39;td,th&#39;), function (td, x) {
      fillout(table, skipCellsX(table, x, y), y, tr, td);
    });
  });
  return tableModel(table.element(), getWidth(table.rows()), table.rows());
};
var toDom = function (table) {
  return createDomTable(table, modelRowsToDomRows(table));
};
var subsection = function (table, startElement, endElement) {
  return findElementPos(table, startElement).bind(function (startPos) {
    return findElementPos(table, endElement).map(function (endPos) {
      return subTable(table, startPos, endPos);
    });
  });
};
var SimpleTableModel = {
  fromDom: fromDom$2,
  toDom: toDom,
  subsection: subsection
};

var findParentListContainer = function (parents$$1) {
  return find(parents$$1, function (elm) {
    return name(elm) === &#39;ul&#39; || name(elm) === &#39;ol&#39;;
  });
};
var getFullySelectedListWrappers = function (parents$$1, rng) {
  return find(parents$$1, function (elm) {
    return name(elm) === &#39;li&#39; &amp;&amp; hasAllContentsSelected(elm, rng);
  }).fold(constant([]), function (li) {
    return findParentListContainer(parents$$1).map(function (listCont) {
      return [
        Element$$1.fromTag(&#39;li&#39;),
        Element$$1.fromTag(name(listCont))
      ];
    }).getOr([]);
  });
};
var wrap$3 = function (innerElm, elms) {
  var wrapped = foldl(elms, function (acc, elm) {
    append(elm, acc);
    return elm;
  }, innerElm);
  return elms.length &gt; 0 ? fromElements([wrapped]) : wrapped;
};
var directListWrappers = function (commonAnchorContainer) {
  if (isListItem(commonAnchorContainer)) {
    return parent(commonAnchorContainer).filter(isList).fold(constant([]), function (listElm) {
      return [
        commonAnchorContainer,
        listElm
      ];
    });
  } else {
    return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
  }
};
var getWrapElements = function (rootNode, rng) {
  var commonAnchorContainer = Element$$1.fromDom(rng.commonAncestorContainer);
  var parents$$1 = Parents.parentsAndSelf(commonAnchorContainer, rootNode);
  var wrapElements = filter(parents$$1, function (elm) {
    return isInline(elm) || isHeading(elm);
  });
  var listWrappers = getFullySelectedListWrappers(parents$$1, rng);
  var allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
  return map(allWrappers, shallow);
};
var emptyFragment = function () {
  return fromElements([]);
};
var getFragmentFromRange = function (rootNode, rng) {
  return wrap$3(Element$$1.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
};
var getParentTable = function (rootElm, cell) {
  return ancestor$1(cell, &#39;table&#39;, curry(eq, rootElm));
};
var getTableFragment = function (rootNode, selectedTableCells) {
  return getParentTable(rootNode, selectedTableCells[0]).bind(function (tableElm) {
    var firstCell = selectedTableCells[0];
    var lastCell = selectedTableCells[selectedTableCells.length - 1];
    var fullTableModel = SimpleTableModel.fromDom(tableElm);
    return SimpleTableModel.subsection(fullTableModel, firstCell, lastCell).map(function (sectionedTableModel) {
      return fromElements([SimpleTableModel.toDom(sectionedTableModel)]);
    });
  }).getOrThunk(emptyFragment);
};
var getSelectionFragment = function (rootNode, ranges) {
  return ranges.length &gt; 0 &amp;&amp; ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
};
var read$4 = function (rootNode, ranges) {
  var selectedCells = TableCellSelection.getCellsFromElementOrRanges(ranges, rootNode);
  return selectedCells.length &gt; 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
};
var FragmentReader = { read: read$4 };

var getContent = function (editor, args) {
  var rng = editor.selection.getRng(), tmpElm = editor.dom.create(&#39;body&#39;);
  var sel = editor.selection.getSel();
  var fragment;
  var ranges = EventProcessRanges.processRanges(editor, MultiRange.getRanges(sel));
  args = args || {};
  args.get = true;
  args.format = args.format || &#39;html&#39;;
  args.selection = true;
  args = editor.fire(&#39;BeforeGetContent&#39;, args);
  if (args.isDefaultPrevented()) {
    editor.fire(&#39;GetContent&#39;, args);
    return args.content;
  }
  if (args.format === &#39;text&#39;) {
    return editor.selection.isCollapsed() ? &#39;&#39; : Zwsp.trim(rng.text || (sel.toString ? sel.toString() : &#39;&#39;));
  }
  if (rng.cloneContents) {
    fragment = args.contextual ? FragmentReader.read(Element$$1.fromDom(editor.getBody()), ranges).dom() : rng.cloneContents();
    if (fragment) {
      tmpElm.appendChild(fragment);
    }
  } else if (rng.item !== undefined || rng.htmlText !== undefined) {
    tmpElm.innerHTML = &#39;&lt;br&gt;&#39; + (rng.item ? rng.item(0).outerHTML : rng.htmlText);
    tmpElm.removeChild(tmpElm.firstChild);
  } else {
    tmpElm.innerHTML = rng.toString();
  }
  args.getInner = true;
  var content = editor.selection.serializer.serialize(tmpElm, args);
  if (args.format === &#39;tree&#39;) {
    return content;
  }
  args.content = editor.selection.isCollapsed() ? &#39;&#39; : content;
  editor.fire(&#39;GetContent&#39;, args);
  return args.content;
};
var GetSelectionContent = { getContent: getContent };

var setContent = function (editor, content, args) {
  var rng = editor.selection.getRng(), caretNode;
  var doc = editor.getDoc();
  var frag, temp;
  args = args || { format: &#39;html&#39; };
  args.set = true;
  args.selection = true;
  args.content = content;
  if (!args.no_events) {
    args = editor.fire(&#39;BeforeSetContent&#39;, args);
    if (args.isDefaultPrevented()) {
      editor.fire(&#39;SetContent&#39;, args);
      return;
    }
  }
  content = args.content;
  if (rng.insertNode) {
    content += &#39;&lt;span id=&quot;__caret&quot;&gt;_&lt;/span&gt;&#39;;
    if (rng.startContainer === doc &amp;&amp; rng.endContainer === doc) {
      doc.body.innerHTML = content;
    } else {
      rng.deleteContents();
      if (doc.body.childNodes.length === 0) {
        doc.body.innerHTML = content;
      } else {
        if (rng.createContextualFragment) {
          rng.insertNode(rng.createContextualFragment(content));
        } else {
          frag = doc.createDocumentFragment();
          temp = doc.createElement(&#39;div&#39;);
          frag.appendChild(temp);
          temp.outerHTML = content;
          rng.insertNode(frag);
        }
      }
    }
    caretNode = editor.dom.get(&#39;__caret&#39;);
    rng = doc.createRange();
    rng.setStartBefore(caretNode);
    rng.setEndBefore(caretNode);
    editor.selection.setRng(rng);
    editor.dom.remove(&#39;__caret&#39;);
    try {
      editor.selection.setRng(rng);
    } catch (ex) {
    }
  } else {
    if (rng.item) {
      doc.execCommand(&#39;Delete&#39;, false, null);
      rng = editor.getRng();
    }
    if (/^\s+/.test(content)) {
      rng.pasteHTML(&#39;&lt;span id=&quot;__mce_tmp&quot;&gt;_&lt;/span&gt;&#39; + content);
      editor.dom.remove(&#39;__mce_tmp&#39;);
    } else {
      rng.pasteHTML(content);
    }
  }
  if (!args.no_events) {
    editor.fire(&#39;SetContent&#39;, args);
  }
};
var SetSelectionContent = { setContent: setContent };

var getEndpointElement = function (root, rng, start, real, resolve) {
  var container = start ? rng.startContainer : rng.endContainer;
  var offset = start ? rng.startOffset : rng.endOffset;
  return Option.from(container).map(Element$$1.fromDom).map(function (elm) {
    return !real || !rng.collapsed ? child(elm, resolve(elm, offset)).getOr(elm) : elm;
  }).bind(function (elm) {
    return isElement(elm) ? Option.some(elm) : parent(elm);
  }).map(function (elm) {
    return elm.dom();
  }).getOr(root);
};
var getStart$2 = function (root, rng, real) {
  return getEndpointElement(root, rng, true, real, function (elm, offset) {
    return Math.min(childNodesCount(elm), offset);
  });
};
var getEnd = function (root, rng, real) {
  return getEndpointElement(root, rng, false, real, function (elm, offset) {
    return offset &gt; 0 ? offset - 1 : offset;
  });
};
var skipEmptyTextNodes = function (node, forwards) {
  var orig = node;
  while (node &amp;&amp; NodeType.isText(node) &amp;&amp; node.length === 0) {
    node = forwards ? node.nextSibling : node.previousSibling;
  }
  return node || orig;
};
var getNode$1 = function (root, rng) {
  var elm, startContainer, endContainer, startOffset, endOffset;
  if (!rng) {
    return root;
  }
  startContainer = rng.startContainer;
  endContainer = rng.endContainer;
  startOffset = rng.startOffset;
  endOffset = rng.endOffset;
  elm = rng.commonAncestorContainer;
  if (!rng.collapsed) {
    if (startContainer === endContainer) {
      if (endOffset - startOffset &lt; 2) {
        if (startContainer.hasChildNodes()) {
          elm = startContainer.childNodes[startOffset];
        }
      }
    }
    if (startContainer.nodeType === 3 &amp;&amp; endContainer.nodeType === 3) {
      if (startContainer.length === startOffset) {
        startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
      } else {
        startContainer = startContainer.parentNode;
      }
      if (endOffset === 0) {
        endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
      } else {
        endContainer = endContainer.parentNode;
      }
      if (startContainer &amp;&amp; startContainer === endContainer) {
        return startContainer;
      }
    }
  }
  if (elm &amp;&amp; elm.nodeType === 3) {
    return elm.parentNode;
  }
  return elm;
};
var getSelectedBlocks = function (dom, rng, startElm, endElm) {
  var node, root;
  var selectedBlocks = [];
  root = dom.getRoot();
  startElm = dom.getParent(startElm || getStart$2(root, rng, rng.collapsed), dom.isBlock);
  endElm = dom.getParent(endElm || getEnd(root, rng, rng.collapsed), dom.isBlock);
  if (startElm &amp;&amp; startElm !== root) {
    selectedBlocks.push(startElm);
  }
  if (startElm &amp;&amp; endElm &amp;&amp; startElm !== endElm) {
    node = startElm;
    var walker = new TreeWalker(startElm, root);
    while ((node = walker.next()) &amp;&amp; node !== endElm) {
      if (dom.isBlock(node)) {
        selectedBlocks.push(node);
      }
    }
  }
  if (endElm &amp;&amp; startElm !== endElm &amp;&amp; endElm !== root) {
    selectedBlocks.push(endElm);
  }
  return selectedBlocks;
};
var select$1 = function (dom, node, content) {
  return Option.from(node).map(function (node) {
    var idx = dom.nodeIndex(node);
    var rng = dom.createRng();
    rng.setStart(node.parentNode, idx);
    rng.setEnd(node.parentNode, idx + 1);
    if (content) {
      moveEndPoint$1(dom, rng, node, true);
      moveEndPoint$1(dom, rng, node, false);
    }
    return rng;
  });
};

var each$j = Tools.each;
var isNativeIeSelection = function (rng) {
  return !!rng.select;
};
var isAttachedToDom = function (node) {
  return !!(node &amp;&amp; node.ownerDocument) &amp;&amp; contains$3(Element$$1.fromDom(node.ownerDocument), Element$$1.fromDom(node));
};
var isValidRange = function (rng) {
  if (!rng) {
    return false;
  } else if (isNativeIeSelection(rng)) {
    return true;
  } else {
    return isAttachedToDom(rng.startContainer) &amp;&amp; isAttachedToDom(rng.endContainer);
  }
};
var Selection = function (dom, win, serializer, editor) {
  var bookmarkManager, controlSelection;
  var selectedRange, explicitRange, selectorChangedData;
  var setCursorLocation = function (node, offset) {
    var rng = dom.createRng();
    if (!node) {
      moveEndPoint$1(dom, rng, editor.getBody(), true);
      setRng(rng);
    } else {
      rng.setStart(node, offset);
      rng.setEnd(node, offset);
      setRng(rng);
      collapse(false);
    }
  };
  var getContent = function (args) {
    return GetSelectionContent.getContent(editor, args);
  };
  var setContent = function (content, args) {
    return SetSelectionContent.setContent(editor, content, args);
  };
  var getStart = function (real) {
    return getStart$2(editor.getBody(), getRng(), real);
  };
  var getEnd$$1 = function (real) {
    return getEnd(editor.getBody(), getRng(), real);
  };
  var getBookmark = function (type, normalized) {
    return bookmarkManager.getBookmark(type, normalized);
  };
  var moveToBookmark = function (bookmark) {
    return bookmarkManager.moveToBookmark(bookmark);
  };
  var select = function (node, content) {
    select$1(dom, node, content).each(setRng);
    return node;
  };
  var isCollapsed = function () {
    var rng = getRng(), sel = getSel();
    if (!rng || rng.item) {
      return false;
    }
    if (rng.compareEndPoints) {
      return rng.compareEndPoints(&#39;StartToEnd&#39;, rng) === 0;
    }
    return !sel || rng.collapsed;
  };
  var collapse = function (toStart) {
    var rng = getRng();
    rng.collapse(!!toStart);
    setRng(rng);
  };
  var getSel = function () {
    return win.getSelection ? win.getSelection() : win.document.selection;
  };
  var getRng = function () {
    var selection, rng, elm, doc;
    var tryCompareBoundaryPoints = function (how, sourceRange, destinationRange) {
      try {
        return sourceRange.compareBoundaryPoints(how, destinationRange);
      } catch (ex) {
        return -1;
      }
    };
    if (!win) {
      return null;
    }
    doc = win.document;
    if (typeof doc === &#39;undefined&#39; || doc === null) {
      return null;
    }
    if (editor.bookmark !== undefined &amp;&amp; EditorFocus.hasFocus(editor) === false) {
      var bookmark = SelectionBookmark.getRng(editor);
      if (bookmark.isSome()) {
        return bookmark.map(function (r) {
          return EventProcessRanges.processRanges(editor, [r])[0];
        }).getOr(doc.createRange());
      }
    }
    try {
      if (selection = getSel()) {
        if (selection.rangeCount &gt; 0) {
          rng = selection.getRangeAt(0);
        } else {
          rng = selection.createRange ? selection.createRange() : doc.createRange();
        }
      }
    } catch (ex) {
    }
    rng = EventProcessRanges.processRanges(editor, [rng])[0];
    if (!rng) {
      rng = doc.createRange ? doc.createRange() : doc.body.createTextRange();
    }
    if (rng.setStart &amp;&amp; rng.startContainer.nodeType === 9 &amp;&amp; rng.collapsed) {
      elm = dom.getRoot();
      rng.setStart(elm, 0);
      rng.setEnd(elm, 0);
    }
    if (selectedRange &amp;&amp; explicitRange) {
      if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 &amp;&amp; tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
        rng = explicitRange;
      } else {
        selectedRange = null;
        explicitRange = null;
      }
    }
    return rng;
  };
  var setRng = function (rng, forward) {
    var sel, node, evt;
    if (!isValidRange(rng)) {
      return;
    }
    var ieRange = isNativeIeSelection(rng) ? rng : null;
    if (ieRange) {
      explicitRange = null;
      try {
        ieRange.select();
      } catch (ex) {
      }
      return;
    }
    sel = getSel();
    evt = editor.fire(&#39;SetSelectionRange&#39;, {
      range: rng,
      forward: forward
    });
    rng = evt.range;
    if (sel) {
      explicitRange = rng;
      try {
        sel.removeAllRanges();
        sel.addRange(rng);
      } catch (ex) {
      }
      if (forward === false &amp;&amp; sel.extend) {
        sel.collapse(rng.endContainer, rng.endOffset);
        sel.extend(rng.startContainer, rng.startOffset);
      }
      selectedRange = sel.rangeCount &gt; 0 ? sel.getRangeAt(0) : null;
    }
    if (!rng.collapsed &amp;&amp; rng.startContainer === rng.endContainer &amp;&amp; sel.setBaseAndExtent &amp;&amp; !Env.ie) {
      if (rng.endOffset - rng.startOffset &lt; 2) {
        if (rng.startContainer.hasChildNodes()) {
          node = rng.startContainer.childNodes[rng.startOffset];
          if (node &amp;&amp; node.tagName === &#39;IMG&#39;) {
            sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
            if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
              sel.setBaseAndExtent(node, 0, node, 1);
            }
          }
        }
      }
    }
    editor.fire(&#39;AfterSetSelectionRange&#39;, {
      range: rng,
      forward: forward
    });
  };
  var setNode = function (elm) {
    setContent(dom.getOuterHTML(elm));
    return elm;
  };
  var getNode = function () {
    return getNode$1(editor.getBody(), getRng());
  };
  var getSelectedBlocks$$1 = function (startElm, endElm) {
    return getSelectedBlocks(dom, getRng(), startElm, endElm);
  };
  var isForward = function () {
    var sel = getSel();
    var anchorRange, focusRange;
    if (!sel || !sel.anchorNode || !sel.focusNode) {
      return true;
    }
    anchorRange = dom.createRng();
    anchorRange.setStart(sel.anchorNode, sel.anchorOffset);
    anchorRange.collapse(true);
    focusRange = dom.createRng();
    focusRange.setStart(sel.focusNode, sel.focusOffset);
    focusRange.collapse(true);
    return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) &lt;= 0;
  };
  var normalize = function () {
    var rng = getRng();
    var sel = getSel();
    if (!MultiRange.hasMultipleRanges(sel) &amp;&amp; hasAnyRanges(editor)) {
      var normRng = NormalizeRange.normalize(dom, rng);
      normRng.each(function (normRng) {
        setRng(normRng, isForward());
      });
      return normRng.getOr(rng);
    }
    return rng;
  };
  var selectorChanged = function (selector, callback) {
    var currentSelectors;
    if (!selectorChangedData) {
      selectorChangedData = {};
      currentSelectors = {};
      editor.on(&#39;NodeChange&#39;, function (e) {
        var node = e.element, parents = dom.getParents(node, null, dom.getRoot()), matchedSelectors = {};
        each$j(selectorChangedData, function (callbacks, selector) {
          each$j(parents, function (node) {
            if (dom.is(node, selector)) {
              if (!currentSelectors[selector]) {
                each$j(callbacks, function (callback) {
                  callback(true, {
                    node: node,
                    selector: selector,
                    parents: parents
                  });
                });
                currentSelectors[selector] = callbacks;
              }
              matchedSelectors[selector] = callbacks;
              return false;
            }
          });
        });
        each$j(currentSelectors, function (callbacks, selector) {
          if (!matchedSelectors[selector]) {
            delete currentSelectors[selector];
            each$j(callbacks, function (callback) {
              callback(false, {
                node: node,
                selector: selector,
                parents: parents
              });
            });
          }
        });
      });
    }
    if (!selectorChangedData[selector]) {
      selectorChangedData[selector] = [];
    }
    selectorChangedData[selector].push(callback);
    return exports;
  };
  var getScrollContainer = function () {
    var scrollContainer;
    var node = dom.getRoot();
    while (node &amp;&amp; node.nodeName !== &#39;BODY&#39;) {
      if (node.scrollHeight &gt; node.clientHeight) {
        scrollContainer = node;
        break;
      }
      node = node.parentNode;
    }
    return scrollContainer;
  };
  var scrollIntoView = function (elm, alignToTop) {
    return ScrollIntoView.scrollElementIntoView(editor, elm, alignToTop);
  };
  var placeCaretAt = function (clientX, clientY) {
    return setRng(CaretRangeFromPoint.fromPoint(clientX, clientY, editor.getDoc()));
  };
  var getBoundingClientRect = function () {
    var rng = getRng();
    return rng.collapsed ? CaretPosition$1.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
  };
  var destroy = function () {
    win = selectedRange = explicitRange = null;
    controlSelection.destroy();
  };
  var exports = {
    bookmarkManager: null,
    controlSelection: null,
    dom: dom,
    win: win,
    serializer: serializer,
    editor: editor,
    collapse: collapse,
    setCursorLocation: setCursorLocation,
    getContent: getContent,
    setContent: setContent,
    getBookmark: getBookmark,
    moveToBookmark: moveToBookmark,
    select: select,
    isCollapsed: isCollapsed,
    isForward: isForward,
    setNode: setNode,
    getNode: getNode,
    getSel: getSel,
    setRng: setRng,
    getRng: getRng,
    getStart: getStart,
    getEnd: getEnd$$1,
    getSelectedBlocks: getSelectedBlocks$$1,
    normalize: normalize,
    selectorChanged: selectorChanged,
    getScrollContainer: getScrollContainer,
    scrollIntoView: scrollIntoView,
    placeCaretAt: placeCaretAt,
    getBoundingClientRect: getBoundingClientRect,
    destroy: destroy
  };
  bookmarkManager = BookmarkManager$1(exports);
  controlSelection = ControlSelection(exports, editor);
  exports.bookmarkManager = bookmarkManager;
  exports.controlSelection = controlSelection;
  return exports;
};

var isContentEditableFalse$b = NodeType.isContentEditableFalse;
var getSelectedNode$1 = getSelectedNode;
var isAfterContentEditableFalse$2 = isAfterContentEditableFalse;
var isBeforeContentEditableFalse$2 = isBeforeContentEditableFalse;
var getVisualCaretPosition = function (walkFn, caretPosition) {
  while (caretPosition = walkFn(caretPosition)) {
    if (caretPosition.isVisible()) {
      return caretPosition;
    }
  }
  return caretPosition;
};
var isMoveInsideSameBlock = function (from, to) {
  var inSameBlock = isInSameBlock(from, to);
  if (!inSameBlock &amp;&amp; NodeType.isBr(from.getNode())) {
    return true;
  }
  return inSameBlock;
};
var moveToCeFalseHorizontally = function (direction, editor, getNextPosFn, range$$1) {
  var node, caretPosition, peekCaretPosition, rangeIsInContainerBlock;
  var forwards = direction === HDirection.Forwards;
  var isBeforeContentEditableFalseFn = forwards ? isBeforeContentEditableFalse$2 : isAfterContentEditableFalse$2;
  if (!range$$1.collapsed) {
    node = getSelectedNode$1(range$$1);
    if (isContentEditableFalse$b(node)) {
      return showCaret(direction, editor, node, direction === HDirection.Backwards, true);
    }
  }
  rangeIsInContainerBlock = isRangeInCaretContainerBlock(range$$1);
  caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range$$1);
  if (isBeforeContentEditableFalseFn(caretPosition)) {
    return selectNode(editor, caretPosition.getNode(!forwards));
  }
  caretPosition = getNextPosFn(caretPosition);
  if (!caretPosition) {
    if (rangeIsInContainerBlock) {
      return range$$1;
    }
    return null;
  }
  if (isBeforeContentEditableFalseFn(caretPosition)) {
    return showCaret(direction, editor, caretPosition.getNode(!forwards), forwards, true);
  }
  peekCaretPosition = getNextPosFn(caretPosition);
  if (isBeforeContentEditableFalseFn(peekCaretPosition)) {
    if (isMoveInsideSameBlock(caretPosition, peekCaretPosition)) {
      return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, true);
    }
  }
  if (rangeIsInContainerBlock) {
    return renderRangeCaret(editor, caretPosition.toRange(), true);
  }
  return null;
};
var moveToCeFalseVertically = function (direction, editor, walkerFn, range$$1) {
  var caretPosition, linePositions, nextLinePositions;
  var closestNextLineRect, caretClientRect, clientX;
  var dist1, dist2, contentEditableFalseNode;
  contentEditableFalseNode = getSelectedNode$1(range$$1);
  caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range$$1);
  linePositions = walkerFn(editor.getBody(), isAboveLine(1), caretPosition);
  nextLinePositions = filter(linePositions, isLine(1));
  caretClientRect = ArrUtils.last(caretPosition.getClientRects());
  if (isBeforeContentEditableFalse$2(caretPosition) || isBeforeTable(caretPosition)) {
    contentEditableFalseNode = caretPosition.getNode();
  }
  if (isAfterContentEditableFalse$2(caretPosition) || isAfterTable(caretPosition)) {
    contentEditableFalseNode = caretPosition.getNode(true);
  }
  if (!caretClientRect) {
    return null;
  }
  clientX = caretClientRect.left;
  closestNextLineRect = findClosestClientRect(nextLinePositions, clientX);
  if (closestNextLineRect) {
    if (isContentEditableFalse$b(closestNextLineRect.node)) {
      dist1 = Math.abs(clientX - closestNextLineRect.left);
      dist2 = Math.abs(clientX - closestNextLineRect.right);
      return showCaret(direction, editor, closestNextLineRect.node, dist1 &lt; dist2, true);
    }
  }
  if (contentEditableFalseNode) {
    var caretPositions = positionsUntil(direction, editor.getBody(), isAboveLine(1), contentEditableFalseNode);
    closestNextLineRect = findClosestClientRect(filter(caretPositions, isLine(1)), clientX);
    if (closestNextLineRect) {
      return renderRangeCaret(editor, closestNextLineRect.position.toRange(), true);
    }
    closestNextLineRect = ArrUtils.last(filter(caretPositions, isLine(0)));
    if (closestNextLineRect) {
      return renderRangeCaret(editor, closestNextLineRect.position.toRange(), true);
    }
  }
};
var createTextBlock = function (editor) {
  var textBlock = editor.dom.create(editor.settings.forced_root_block);
  if (!Env.ie || Env.ie &gt;= 11) {
    textBlock.innerHTML = &#39;&lt;br data-mce-bogus=&quot;1&quot;&gt;&#39;;
  }
  return textBlock;
};
var exitPreBlock = function (editor, direction, range$$1) {
  var pre, caretPos, newBlock;
  var caretWalker = CaretWalker(editor.getBody());
  var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
  var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
  if (range$$1.collapsed &amp;&amp; editor.settings.forced_root_block) {
    pre = editor.dom.getParent(range$$1.startContainer, &#39;PRE&#39;);
    if (!pre) {
      return;
    }
    if (direction === 1) {
      caretPos = getNextVisualCaretPosition(CaretPosition$1.fromRangeStart(range$$1));
    } else {
      caretPos = getPrevVisualCaretPosition(CaretPosition$1.fromRangeStart(range$$1));
    }
    if (!caretPos) {
      newBlock = createTextBlock(editor);
      if (direction === 1) {
        editor.$(pre).after(newBlock);
      } else {
        editor.$(pre).before(newBlock);
      }
      editor.selection.select(newBlock, true);
      editor.selection.collapse();
    }
  }
};
var getHorizontalRange = function (editor, forward) {
  var caretWalker = CaretWalker(editor.getBody());
  var getNextVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.next);
  var getPrevVisualCaretPosition = curry(getVisualCaretPosition, caretWalker.prev);
  var newRange;
  var direction = forward ? HDirection.Forwards : HDirection.Backwards;
  var getNextPosFn = forward ? getNextVisualCaretPosition : getPrevVisualCaretPosition;
  var range$$1 = editor.selection.getRng();
  newRange = moveToCeFalseHorizontally(direction, editor, getNextPosFn, range$$1);
  if (newRange) {
    return newRange;
  }
  newRange = exitPreBlock(editor, direction, range$$1);
  if (newRange) {
    return newRange;
  }
  return null;
};
var getVerticalRange = function (editor, down) {
  var newRange;
  var direction = down ? 1 : -1;
  var walkerFn = down ? downUntil : upUntil;
  var range$$1 = editor.selection.getRng();
  newRange = moveToCeFalseVertically(direction, editor, walkerFn, range$$1);
  if (newRange) {
    return newRange;
  }
  newRange = exitPreBlock(editor, direction, range$$1);
  if (newRange) {
    return newRange;
  }
  return null;
};
var moveH = function (editor, forward) {
  return function () {
    var newRng = getHorizontalRange(editor, forward);
    if (newRng) {
      editor.selection.setRng(newRng);
      return true;
    } else {
      return false;
    }
  };
};
var moveV = function (editor, down) {
  return function () {
    var newRng = getVerticalRange(editor, down);
    if (newRng) {
      editor.selection.setRng(newRng);
      return true;
    } else {
      return false;
    }
  };
};

var BreakType;
(function (BreakType) {
  BreakType[BreakType[&#39;Br&#39;] = 0] = &#39;Br&#39;;
  BreakType[BreakType[&#39;Block&#39;] = 1] = &#39;Block&#39;;
  BreakType[BreakType[&#39;Wrap&#39;] = 2] = &#39;Wrap&#39;;
  BreakType[BreakType[&#39;Eol&#39;] = 3] = &#39;Eol&#39;;
}(BreakType || (BreakType = {})));
var flip = function (direction, positions) {
  return direction === HDirection.Backwards ? positions.reverse() : positions;
};
var walk$3 = function (direction, caretWalker, pos) {
  return direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
};
var getBreakType = function (scope, direction, currentPos, nextPos) {
  if (NodeType.isBr(nextPos.getNode(direction === HDirection.Forwards))) {
    return BreakType.Br;
  } else if (isInSameBlock(currentPos, nextPos) === false) {
    return BreakType.Block;
  } else {
    return BreakType.Wrap;
  }
};
var getPositionsUntil = function (predicate, direction, scope, start) {
  var caretWalker = CaretWalker(scope);
  var currentPos = start, nextPos;
  var positions = [];
  while (currentPos) {
    nextPos = walk$3(direction, caretWalker, currentPos);
    if (!nextPos) {
      break;
    }
    if (NodeType.isBr(nextPos.getNode(false))) {
      if (direction === HDirection.Forwards) {
        return {
          positions: flip(direction, positions).concat([nextPos]),
          breakType: BreakType.Br,
          breakAt: Option.some(nextPos)
        };
      } else {
        return {
          positions: flip(direction, positions),
          breakType: BreakType.Br,
          breakAt: Option.some(nextPos)
        };
      }
    }
    if (!nextPos.isVisible()) {
      currentPos = nextPos;
      continue;
    }
    if (predicate(currentPos, nextPos)) {
      var breakType = getBreakType(scope, direction, currentPos, nextPos);
      return {
        positions: flip(direction, positions),
        breakType: breakType,
        breakAt: Option.some(nextPos)
      };
    }
    positions.push(nextPos);
    currentPos = nextPos;
  }
  return {
    positions: flip(direction, positions),
    breakType: BreakType.Eol,
    breakAt: Option.none()
  };
};
var getAdjacentLinePositions = function (direction, getPositionsUntilBreak, scope, start) {
  return getPositionsUntilBreak(scope, start).breakAt.map(function (pos) {
    var positions = getPositionsUntilBreak(scope, pos).positions;
    return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
  }).getOr([]);
};
var findClosestHorizontalPositionFromPoint = function (positions, x) {
  return foldl(positions, function (acc, newPos) {
    return acc.fold(function () {
      return Option.some(newPos);
    }, function (lastPos) {
      return liftN([
        head(lastPos.getClientRects()),
        head(newPos.getClientRects())
      ], function (lastRect, newRect) {
        var lastDist = Math.abs(x - lastRect.left);
        var newDist = Math.abs(x - newRect.left);
        return newDist &lt;= lastDist ? newPos : lastPos;
      }).or(acc);
    });
  }, Option.none());
};
var findClosestHorizontalPosition = function (positions, pos) {
  return head(pos.getClientRects()).bind(function (targetRect) {
    return findClosestHorizontalPositionFromPoint(positions, targetRect.left);
  });
};
var getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
var getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
var getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
var getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
var getFirstLinePositions = function (scope) {
  return CaretFinder.firstPositionIn(scope).map(function (pos) {
    return [pos].concat(getPositionsUntilNextLine(scope, pos).positions);
  }).getOr([]);
};
var getLastLinePositions = function (scope) {
  return CaretFinder.lastPositionIn(scope).map(function (pos) {
    return getPositionsUntilPreviousLine(scope, pos).positions.concat(pos);
  }).getOr([]);
};

var deflate = function (rect, delta) {
  return {
    left: rect.left - delta,
    top: rect.top - delta,
    right: rect.right + delta * 2,
    bottom: rect.bottom + delta * 2,
    width: rect.width + delta,
    height: rect.height + delta
  };
};
var getCorners = function (getYAxisValue, tds) {
  return bind(tds, function (td) {
    var rect = deflate(clone$2(td.getBoundingClientRect()), -1);
    return [
      {
        x: rect.left,
        y: getYAxisValue(rect),
        cell: td
      },
      {
        x: rect.right,
        y: getYAxisValue(rect),
        cell: td
      }
    ];
  });
};
var findClosestCorner = function (corners, x, y) {
  return foldl(corners, function (acc, newCorner) {
    return acc.fold(function () {
      return Option.some(newCorner);
    }, function (oldCorner) {
      var oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
      var newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
      return Option.some(newDist &lt; oldDist ? newCorner : oldCorner);
    });
  }, Option.none());
};
var getClosestCell$1 = function (getYAxisValue, isTargetCorner, table, x, y) {
  var cells = descendants$1(Element$$1.fromDom(table), &#39;td,th,caption&#39;).map(function (e) {
    return e.dom();
  });
  var corners = filter(getCorners(getYAxisValue, cells), function (corner) {
    return isTargetCorner(corner, y);
  });
  return findClosestCorner(corners, x, y).map(function (corner) {
    return corner.cell;
  });
};
var getBottomValue = function (rect) {
  return rect.bottom;
};
var getTopValue = function (rect) {
  return rect.top;
};
var isAbove$1 = function (corner, y) {
  return corner.y &lt; y;
};
var isBelow$1 = function (corner, y) {
  return corner.y &gt; y;
};
var getClosestCellAbove = curry(getClosestCell$1, getBottomValue, isAbove$1);
var getClosestCellBelow = curry(getClosestCell$1, getTopValue, isBelow$1);
var findClosestPositionInAboveCell = function (table, pos) {
  return head(pos.getClientRects()).bind(function (rect) {
    return getClosestCellAbove(table, rect.left, rect.top);
  }).bind(function (cell) {
    return findClosestHorizontalPosition(getLastLinePositions(cell), pos);
  });
};
var findClosestPositionInBelowCell = function (table, pos) {
  return last(pos.getClientRects()).bind(function (rect) {
    return getClosestCellBelow(table, rect.left, rect.top);
  }).bind(function (cell) {
    return findClosestHorizontalPosition(getFirstLinePositions(cell), pos);
  });
};

var moveToRange = function (editor, rng) {
  editor.selection.setRng(rng);
  ScrollIntoView.scrollRangeIntoView(editor, rng);
};
var hasNextBreak = function (getPositionsUntil, scope, lineInfo) {
  return lineInfo.breakAt.map(function (breakPos) {
    return getPositionsUntil(scope, breakPos).breakAt.isSome();
  }).getOr(false);
};
var startsWithWrapBreak = function (lineInfo) {
  return lineInfo.breakType === BreakType.Wrap &amp;&amp; lineInfo.positions.length === 0;
};
var startsWithBrBreak = function (lineInfo) {
  return lineInfo.breakType === BreakType.Br &amp;&amp; lineInfo.positions.length === 1;
};
var isAtTableCellLine = function (getPositionsUntil, scope, pos) {
  var lineInfo = getPositionsUntil(scope, pos);
  if (startsWithWrapBreak(lineInfo) || !NodeType.isBr(pos.getNode()) &amp;&amp; startsWithBrBreak(lineInfo)) {
    return !hasNextBreak(getPositionsUntil, scope, lineInfo);
  } else {
    return lineInfo.breakAt.isNone();
  }
};
var isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
var isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
var isCaretAtStartOrEndOfTable = function (forward, rng, table) {
  var caretPos = CaretPosition$1.fromRangeStart(rng);
  return CaretFinder.positionIn(!forward, table).map(function (pos) {
    return pos.isEqual(caretPos);
  }).getOr(false);
};
var navigateHorizontally = function (editor, forward, table, td) {
  var rng = editor.selection.getRng();
  var direction = forward ? 1 : -1;
  if (isFakeCaretTableBrowser() &amp;&amp; isCaretAtStartOrEndOfTable(forward, rng, table)) {
    var newRng = showCaret(direction, editor, table, !forward, true);
    moveToRange(editor, newRng);
    return true;
  }
  return false;
};
var getClosestAbovePosition = function (root, table, start) {
  return findClosestPositionInAboveCell(table, start).orThunk(function () {
    return head(start.getClientRects()).bind(function (rect) {
      return findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition$1.before(table)), rect.left);
    });
  }).getOr(CaretPosition$1.before(table));
};
var getClosestBelowPosition = function (root, table, start) {
  return findClosestPositionInBelowCell(table, start).orThunk(function () {
    return head(start.getClientRects()).bind(function (rect) {
      return findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition$1.after(table)), rect.left);
    });
  }).getOr(CaretPosition$1.after(table));
};
var getTable = function (previous, pos) {
  var node = pos.getNode(previous);
  return NodeType.isElement(node) &amp;&amp; node.nodeName === &#39;TABLE&#39; ? Option.some(node) : Option.none();
};
var renderBlock = function (down, editor, table, pos) {
  var forcedRootBlock = Settings.getForcedRootBlock(editor);
  if (forcedRootBlock) {
    editor.undoManager.transact(function () {
      var element = Element$$1.fromTag(forcedRootBlock);
      setAll(element, Settings.getForcedRootBlockAttrs(editor));
      append(element, Element$$1.fromTag(&#39;br&#39;));
      if (down) {
        after(Element$$1.fromDom(table), element);
      } else {
        before(Element$$1.fromDom(table), element);
      }
      var rng = editor.dom.createRng();
      rng.setStart(element.dom(), 0);
      rng.setEnd(element.dom(), 0);
      moveToRange(editor, rng);
    });
  } else {
    moveToRange(editor, pos.toRange());
  }
};
var moveCaret = function (editor, down, pos) {
  var table = down ? getTable(true, pos) : getTable(false, pos);
  var last$$1 = down === false;
  table.fold(function () {
    return moveToRange(editor, pos.toRange());
  }, function (table) {
    return CaretFinder.positionIn(last$$1, editor.getBody()).filter(function (lastPos) {
      return lastPos.isEqual(pos);
    }).fold(function () {
      return moveToRange(editor, pos.toRange());
    }, function (_) {
      return renderBlock(down, editor, table, pos);
    });
  });
};
var navigateVertically = function (editor, down, table, td) {
  var rng = editor.selection.getRng();
  var pos = CaretPosition$1.fromRangeStart(rng);
  var root = editor.getBody();
  if (!down &amp;&amp; isAtFirstTableCellLine(td, pos)) {
    var newPos = getClosestAbovePosition(root, table, pos);
    moveCaret(editor, down, newPos);
    return true;
  } else if (down &amp;&amp; isAtLastTableCellLine(td, pos)) {
    var newPos = getClosestBelowPosition(root, table, pos);
    moveCaret(editor, down, newPos);
    return true;
  } else {
    return false;
  }
};
var moveH$1 = function (editor, forward) {
  return function () {
    return Option.from(editor.dom.getParent(editor.selection.getNode(), &#39;td,th&#39;)).bind(function (td) {
      return Option.from(editor.dom.getParent(td, &#39;table&#39;)).map(function (table) {
        return navigateHorizontally(editor, forward, table, td);
      });
    }).getOr(false);
  };
};
var moveV$1 = function (editor, forward) {
  return function () {
    return Option.from(editor.dom.getParent(editor.selection.getNode(), &#39;td,th&#39;)).bind(function (td) {
      return Option.from(editor.dom.getParent(td, &#39;table&#39;)).map(function (table) {
        return navigateVertically(editor, forward, table, td);
      });
    }).getOr(false);
  };
};

var defaultPatterns = function (patterns) {
  return map(patterns, function (pattern) {
    return merge({
      shiftKey: false,
      altKey: false,
      ctrlKey: false,
      metaKey: false,
      keyCode: 0,
      action: noop
    }, pattern);
  });
};
var matchesEvent = function (pattern, evt) {
  return evt.keyCode === pattern.keyCode &amp;&amp; evt.shiftKey === pattern.shiftKey &amp;&amp; evt.altKey === pattern.altKey &amp;&amp; evt.ctrlKey === pattern.ctrlKey &amp;&amp; evt.metaKey === pattern.metaKey;
};
var match$1 = function (patterns, evt) {
  return bind(defaultPatterns(patterns), function (pattern) {
    return matchesEvent(pattern, evt) ? [pattern] : [];
  });
};
var action = function (f) {
  var x = [];
  for (var _i = 1; _i &lt; arguments.length; _i++) {
    x[_i - 1] = arguments[_i];
  }
  var args = Array.prototype.slice.call(arguments, 1);
  return function () {
    return f.apply(null, args);
  };
};
var execute = function (patterns, evt) {
  return find(match$1(patterns, evt), function (pattern) {
    return pattern.action();
  });
};
var MatchKeys = {
  match: match$1,
  action: action,
  execute: execute
};

var executeKeydownOverride = function (editor, caret, evt) {
  var os = PlatformDetection$1.detect().os;
  MatchKeys.execute([
    {
      keyCode: VK.RIGHT,
      action: moveH(editor, true)
    },
    {
      keyCode: VK.LEFT,
      action: moveH(editor, false)
    },
    {
      keyCode: VK.UP,
      action: moveV(editor, false)
    },
    {
      keyCode: VK.DOWN,
      action: moveV(editor, true)
    },
    {
      keyCode: VK.RIGHT,
      action: moveH$1(editor, true)
    },
    {
      keyCode: VK.LEFT,
      action: moveH$1(editor, false)
    },
    {
      keyCode: VK.UP,
      action: moveV$1(editor, false)
    },
    {
      keyCode: VK.DOWN,
      action: moveV$1(editor, true)
    },
    {
      keyCode: VK.RIGHT,
      action: BoundarySelection.move(editor, caret, true)
    },
    {
      keyCode: VK.LEFT,
      action: BoundarySelection.move(editor, caret, false)
    },
    {
      keyCode: VK.RIGHT,
      ctrlKey: !os.isOSX(),
      altKey: os.isOSX(),
      action: BoundarySelection.moveNextWord(editor, caret)
    },
    {
      keyCode: VK.LEFT,
      ctrlKey: !os.isOSX(),
      altKey: os.isOSX(),
      action: BoundarySelection.movePrevWord(editor, caret)
    }
  ], evt).each(function (_) {
    evt.preventDefault();
  });
};
var setup$7 = function (editor, caret) {
  editor.on(&#39;keydown&#39;, function (evt) {
    if (evt.isDefaultPrevented() === false) {
      executeKeydownOverride(editor, caret, evt);
    }
  });
};
var ArrowKeys = { setup: setup$7 };

var getParentInlines = function (rootElm, startElm) {
  var parents$$1 = Parents.parentsAndSelf(startElm, rootElm);
  return findIndex(parents$$1, isBlock).fold(constant(parents$$1), function (index) {
    return parents$$1.slice(0, index);
  });
};
var hasOnlyOneChild$1 = function (elm) {
  return children(elm).length === 1;
};
var deleteLastPosition = function (forward, editor, target, parentInlines) {
  var isFormatElement$$1 = curry(isFormatElement, editor);
  var formatNodes = map(filter(parentInlines, isFormatElement$$1), function (elm) {
    return elm.dom();
  });
  if (formatNodes.length === 0) {
    DeleteElement.deleteElement(editor, forward, target);
  } else {
    var pos = replaceWithCaretFormat(target.dom(), formatNodes);
    editor.selection.setRng(pos.toRange());
  }
};
var deleteCaret$1 = function (editor, forward) {
  var rootElm = Element$$1.fromDom(editor.getBody());
  var startElm = Element$$1.fromDom(editor.selection.getStart());
  var parentInlines = filter(getParentInlines(rootElm, startElm), hasOnlyOneChild$1);
  return last(parentInlines).map(function (target) {
    var fromPos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
    if (DeleteUtils.willDeleteLastPositionInElement(forward, fromPos, target.dom()) &amp;&amp; !isEmptyCaretFormatElement(target)) {
      deleteLastPosition(forward, editor, target, parentInlines);
      return true;
    } else {
      return false;
    }
  }).getOr(false);
};
var backspaceDelete$5 = function (editor, forward) {
  return editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : false;
};
var InlineFormatDelete = { backspaceDelete: backspaceDelete$5 };

var executeKeydownOverride$1 = function (editor, caret, evt) {
  MatchKeys.execute([
    {
      keyCode: VK.BACKSPACE,
      action: MatchKeys.action(CefDelete.backspaceDelete, editor, false)
    },
    {
      keyCode: VK.DELETE,
      action: MatchKeys.action(CefDelete.backspaceDelete, editor, true)
    },
    {
      keyCode: VK.BACKSPACE,
      action: MatchKeys.action(InlineBoundaryDelete.backspaceDelete, editor, caret, false)
    },
    {
      keyCode: VK.DELETE,
      action: MatchKeys.action(InlineBoundaryDelete.backspaceDelete, editor, caret, true)
    },
    {
      keyCode: VK.BACKSPACE,
      action: MatchKeys.action(TableDelete.backspaceDelete, editor, false)
    },
    {
      keyCode: VK.DELETE,
      action: MatchKeys.action(TableDelete.backspaceDelete, editor, true)
    },
    {
      keyCode: VK.BACKSPACE,
      action: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, false)
    },
    {
      keyCode: VK.DELETE,
      action: MatchKeys.action(BlockRangeDelete.backspaceDelete, editor, true)
    },
    {
      keyCode: VK.BACKSPACE,
      action: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, false)
    },
    {
      keyCode: VK.DELETE,
      action: MatchKeys.action(BlockBoundaryDelete.backspaceDelete, editor, true)
    },
    {
      keyCode: VK.BACKSPACE,
      action: MatchKeys.action(InlineFormatDelete.backspaceDelete, editor, false)
    },
    {
      keyCode: VK.DELETE,
      action: MatchKeys.action(InlineFormatDelete.backspaceDelete, editor, true)
    }
  ], evt).each(function (_) {
    evt.preventDefault();
  });
};
var executeKeyupOverride = function (editor, evt) {
  MatchKeys.execute([
    {
      keyCode: VK.BACKSPACE,
      action: MatchKeys.action(CefDelete.paddEmptyElement, editor)
    },
    {
      keyCode: VK.DELETE,
      action: MatchKeys.action(CefDelete.paddEmptyElement, editor)
    }
  ], evt);
};
var setup$8 = function (editor, caret) {
  editor.on(&#39;keydown&#39;, function (evt) {
    if (evt.isDefaultPrevented() === false) {
      executeKeydownOverride$1(editor, caret, evt);
    }
  });
  editor.on(&#39;keyup&#39;, function (evt) {
    if (evt.isDefaultPrevented() === false) {
      executeKeyupOverride(editor, evt);
    }
  });
};
var DeleteBackspaceKeys = { setup: setup$8 };

var firstNonWhiteSpaceNodeSibling = function (node) {
  while (node) {
    if (node.nodeType === 1 || node.nodeType === 3 &amp;&amp; node.data &amp;&amp; /[\r\n\s]/.test(node.data)) {
      return node;
    }
    node = node.nextSibling;
  }
};
var moveToCaretPosition = function (editor, root) {
  var walker, node, rng, lastNode = root, tempElm;
  var dom = editor.dom;
  var moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
  if (!root) {
    return;
  }
  if (/^(LI|DT|DD)$/.test(root.nodeName)) {
    var firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);
    if (firstChild &amp;&amp; /^(UL|OL|DL)$/.test(firstChild.nodeName)) {
      root.insertBefore(dom.doc.createTextNode(&#39;\xA0&#39;), root.firstChild);
    }
  }
  rng = dom.createRng();
  root.normalize();
  if (root.hasChildNodes()) {
    walker = new TreeWalker(root, root);
    while (node = walker.current()) {
      if (NodeType.isText(node)) {
        rng.setStart(node, 0);
        rng.setEnd(node, 0);
        break;
      }
      if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
        rng.setStartBefore(node);
        rng.setEndBefore(node);
        break;
      }
      lastNode = node;
      node = walker.next();
    }
    if (!node) {
      rng.setStart(lastNode, 0);
      rng.setEnd(lastNode, 0);
    }
  } else {
    if (NodeType.isBr(root)) {
      if (root.nextSibling &amp;&amp; dom.isBlock(root.nextSibling)) {
        rng.setStartBefore(root);
        rng.setEndBefore(root);
      } else {
        rng.setStartAfter(root);
        rng.setEndAfter(root);
      }
    } else {
      rng.setStart(root, 0);
      rng.setEnd(root, 0);
    }
  }
  editor.selection.setRng(rng);
  dom.remove(tempElm);
  editor.selection.scrollIntoView(root);
};
var getEditableRoot = function (dom, node) {
  var root = dom.getRoot();
  var parent, editableRoot;
  parent = node;
  while (parent !== root &amp;&amp; dom.getContentEditable(parent) !== &#39;false&#39;) {
    if (dom.getContentEditable(parent) === &#39;true&#39;) {
      editableRoot = parent;
    }
    parent = parent.parentNode;
  }
  return parent !== root ? editableRoot : root;
};
var getParentBlock$2 = function (editor) {
  return Option.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
};
var getParentBlockName = function (editor) {
  return getParentBlock$2(editor).fold(constant(&#39;&#39;), function (parentBlock) {
    return parentBlock.nodeName.toUpperCase();
  });
};
var isListItemParentBlock = function (editor) {
  return getParentBlock$2(editor).filter(function (elm) {
    return isListItem(Element$$1.fromDom(elm));
  }).isSome();
};
var NewLineUtils = {
  moveToCaretPosition: moveToCaretPosition,
  getEditableRoot: getEditableRoot,
  getParentBlock: getParentBlock$2,
  getParentBlockName: getParentBlockName,
  isListItemParentBlock: isListItemParentBlock
};

var hasFirstChild = function (elm, name) {
  return elm.firstChild &amp;&amp; elm.firstChild.nodeName === name;
};
var hasParent$1 = function (elm, parentName) {
  return elm &amp;&amp; elm.parentNode &amp;&amp; elm.parentNode.nodeName === parentName;
};
var isListBlock = function (elm) {
  return elm &amp;&amp; /^(OL|UL|LI)$/.test(elm.nodeName);
};
var isNestedList = function (elm) {
  return isListBlock(elm) &amp;&amp; isListBlock(elm.parentNode);
};
var getContainerBlock = function (containerBlock) {
  var containerBlockParent = containerBlock.parentNode;
  if (/^(LI|DT|DD)$/.test(containerBlockParent.nodeName)) {
    return containerBlockParent;
  }
  return containerBlock;
};
var isFirstOrLastLi = function (containerBlock, parentBlock, first) {
  var node = containerBlock[first ? &#39;firstChild&#39; : &#39;lastChild&#39;];
  while (node) {
    if (NodeType.isElement(node)) {
      break;
    }
    node = node[first ? &#39;nextSibling&#39; : &#39;previousSibling&#39;];
  }
  return node === parentBlock;
};
var insert$1 = function (editor, createNewBlock, containerBlock, parentBlock, newBlockName) {
  var dom = editor.dom;
  var rng = editor.selection.getRng();
  if (containerBlock === editor.getBody()) {
    return;
  }
  if (isNestedList(containerBlock)) {
    newBlockName = &#39;LI&#39;;
  }
  var newBlock = newBlockName ? createNewBlock(newBlockName) : dom.create(&#39;BR&#39;);
  if (isFirstOrLastLi(containerBlock, parentBlock, true) &amp;&amp; isFirstOrLastLi(containerBlock, parentBlock, false)) {
    if (hasParent$1(containerBlock, &#39;LI&#39;)) {
      dom.insertAfter(newBlock, getContainerBlock(containerBlock));
    } else {
      dom.replace(newBlock, containerBlock);
    }
  } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
    if (hasParent$1(containerBlock, &#39;LI&#39;)) {
      dom.insertAfter(newBlock, getContainerBlock(containerBlock));
      newBlock.appendChild(dom.doc.createTextNode(&#39; &#39;));
      newBlock.appendChild(containerBlock);
    } else {
      containerBlock.parentNode.insertBefore(newBlock, containerBlock);
    }
  } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
    dom.insertAfter(newBlock, getContainerBlock(containerBlock));
  } else {
    containerBlock = getContainerBlock(containerBlock);
    var tmpRng = rng.cloneRange();
    tmpRng.setStartAfter(parentBlock);
    tmpRng.setEndAfter(containerBlock);
    var fragment = tmpRng.extractContents();
    if (newBlockName === &#39;LI&#39; &amp;&amp; hasFirstChild(fragment, &#39;LI&#39;)) {
      newBlock = fragment.firstChild;
      dom.insertAfter(fragment, containerBlock);
    } else {
      dom.insertAfter(fragment, containerBlock);
      dom.insertAfter(newBlock, containerBlock);
    }
  }
  dom.remove(parentBlock);
  NewLineUtils.moveToCaretPosition(editor, newBlock);
};
var InsertLi = { insert: insert$1 };

var isEmptyAnchor = function (elm) {
  return elm &amp;&amp; elm.nodeName === &#39;A&#39; &amp;&amp; Tools.trim(Zwsp.trim(elm.innerText || elm.textContent)).length === 0;
};
var isTableCell$5 = function (node) {
  return node &amp;&amp; /^(TD|TH|CAPTION)$/.test(node.nodeName);
};
var emptyBlock = function (elm) {
  elm.innerHTML = &#39;&lt;br data-mce-bogus=&quot;1&quot;&gt;&#39;;
};
var containerAndSiblingName = function (container, nodeName) {
  return container.nodeName === nodeName || container.previousSibling &amp;&amp; container.previousSibling.nodeName === nodeName;
};
var canSplitBlock = function (dom, node) {
  return node &amp;&amp; dom.isBlock(node) &amp;&amp; !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) &amp;&amp; !/^(fixed|absolute)/i.test(node.style.position) &amp;&amp; dom.getContentEditable(node) !== &#39;true&#39;;
};
var trimInlineElementsOnLeftSideOfBlock = function (dom, nonEmptyElementsMap, block) {
  var node = block;
  var firstChilds = [];
  var i;
  if (!node) {
    return;
  }
  while (node = node.firstChild) {
    if (dom.isBlock(node)) {
      return;
    }
    if (NodeType.isElement(node) &amp;&amp; !nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
      firstChilds.push(node);
    }
  }
  i = firstChilds.length;
  while (i--) {
    node = firstChilds[i];
    if (!node.hasChildNodes() || node.firstChild === node.lastChild &amp;&amp; node.firstChild.nodeValue === &#39;&#39;) {
      dom.remove(node);
    } else {
      if (isEmptyAnchor(node)) {
        dom.remove(node);
      }
    }
  }
};
var normalizeZwspOffset = function (start, container, offset) {
  if (NodeType.isText(container) === false) {
    return offset;
  } else if (start) {
    return offset === 1 &amp;&amp; container.data.charAt(offset - 1) === Zwsp.ZWSP ? 0 : offset;
  } else {
    return offset === container.data.length - 1 &amp;&amp; container.data.charAt(offset) === Zwsp.ZWSP ? container.data.length : offset;
  }
};
var includeZwspInRange = function (rng) {
  var newRng = rng.cloneRange();
  newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
  newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
  return newRng;
};
var trimLeadingLineBreaks = function (node) {
  do {
    if (NodeType.isText(node)) {
      node.nodeValue = node.nodeValue.replace(/^[\r\n]+/, &#39;&#39;);
    }
    node = node.firstChild;
  } while (node);
};
var getEditableRoot$1 = function (dom, node) {
  var root = dom.getRoot();
  var parent, editableRoot;
  parent = node;
  while (parent !== root &amp;&amp; dom.getContentEditable(parent) !== &#39;false&#39;) {
    if (dom.getContentEditable(parent) === &#39;true&#39;) {
      editableRoot = parent;
    }
    parent = parent.parentNode;
  }
  return parent !== root ? editableRoot : root;
};
var setForcedBlockAttrs = function (editor, node) {
  var forcedRootBlockName = Settings.getForcedRootBlock(editor);
  if (forcedRootBlockName &amp;&amp; forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
    editor.dom.setAttribs(node, Settings.getForcedRootBlockAttrs(editor));
  }
};
var wrapSelfAndSiblingsInDefaultBlock = function (editor, newBlockName, rng, container, offset) {
  var newBlock, parentBlock, startNode, node, next, rootBlockName;
  var blockName = newBlockName || &#39;P&#39;;
  var dom = editor.dom, editableRoot = getEditableRoot$1(dom, container);
  parentBlock = dom.getParent(container, dom.isBlock);
  if (!parentBlock || !canSplitBlock(dom, parentBlock)) {
    parentBlock = parentBlock || editableRoot;
    if (parentBlock === editor.getBody() || isTableCell$5(parentBlock)) {
      rootBlockName = parentBlock.nodeName.toLowerCase();
    } else {
      rootBlockName = parentBlock.parentNode.nodeName.toLowerCase();
    }
    if (!parentBlock.hasChildNodes()) {
      newBlock = dom.create(blockName);
      setForcedBlockAttrs(editor, newBlock);
      parentBlock.appendChild(newBlock);
      rng.setStart(newBlock, 0);
      rng.setEnd(newBlock, 0);
      return newBlock;
    }
    node = container;
    while (node.parentNode !== parentBlock) {
      node = node.parentNode;
    }
    while (node &amp;&amp; !dom.isBlock(node)) {
      startNode = node;
      node = node.previousSibling;
    }
    if (startNode &amp;&amp; editor.schema.isValidChild(rootBlockName, blockName.toLowerCase())) {
      newBlock = dom.create(blockName);
      setForcedBlockAttrs(editor, newBlock);
      startNode.parentNode.insertBefore(newBlock, startNode);
      node = startNode;
      while (node &amp;&amp; !dom.isBlock(node)) {
        next = node.nextSibling;
        newBlock.appendChild(node);
        node = next;
      }
      rng.setStart(container, offset);
      rng.setEnd(container, offset);
    }
  }
  return container;
};
var addBrToBlockIfNeeded = function (dom, block) {
  var lastChild;
  block.normalize();
  lastChild = block.lastChild;
  if (!lastChild || /^(left|right)$/gi.test(dom.getStyle(lastChild, &#39;float&#39;, true))) {
    dom.add(block, &#39;br&#39;);
  }
};
var insert$2 = function (editor, evt) {
  var tmpRng, editableRoot, container, offset, parentBlock, shiftKey;
  var newBlock, fragment, containerBlock, parentBlockName, containerBlockName, newBlockName, isAfterLastNodeInContainer;
  var dom = editor.dom;
  var schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
  var rng = editor.selection.getRng();
  var createNewBlock = function (name) {
    var node = container, block, clonedNode, caretNode;
    var textInlineElements = schema.getTextInlineElements();
    if (name || parentBlockName === &#39;TABLE&#39; || parentBlockName === &#39;HR&#39;) {
      block = dom.create(name || newBlockName);
      setForcedBlockAttrs(editor, block);
    } else {
      block = parentBlock.cloneNode(false);
    }
    caretNode = block;
    if (Settings.shouldKeepStyles(editor) === false) {
      dom.setAttrib(block, &#39;style&#39;, null);
      dom.setAttrib(block, &#39;class&#39;, null);
    } else {
      do {
        if (textInlineElements[node.nodeName]) {
          if (isCaretNode(node)) {
            continue;
          }
          clonedNode = node.cloneNode(false);
          dom.setAttrib(clonedNode, &#39;id&#39;, &#39;&#39;);
          if (block.hasChildNodes()) {
            clonedNode.appendChild(block.firstChild);
            block.appendChild(clonedNode);
          } else {
            caretNode = clonedNode;
            block.appendChild(clonedNode);
          }
        }
      } while ((node = node.parentNode) &amp;&amp; node !== editableRoot);
    }
    emptyBlock(caretNode);
    return block;
  };
  var isCaretAtStartOrEndOfBlock = function (start) {
    var walker, node, name, normalizedOffset;
    normalizedOffset = normalizeZwspOffset(start, container, offset);
    if (NodeType.isText(container) &amp;&amp; (start ? normalizedOffset &gt; 0 : normalizedOffset &lt; container.nodeValue.length)) {
      return false;
    }
    if (container.parentNode === parentBlock &amp;&amp; isAfterLastNodeInContainer &amp;&amp; !start) {
      return true;
    }
    if (start &amp;&amp; NodeType.isElement(container) &amp;&amp; container === parentBlock.firstChild) {
      return true;
    }
    if (containerAndSiblingName(container, &#39;TABLE&#39;) || containerAndSiblingName(container, &#39;HR&#39;)) {
      return isAfterLastNodeInContainer &amp;&amp; !start || !isAfterLastNodeInContainer &amp;&amp; start;
    }
    walker = new TreeWalker(container, parentBlock);
    if (NodeType.isText(container)) {
      if (start &amp;&amp; normalizedOffset === 0) {
        walker.prev();
      } else if (!start &amp;&amp; normalizedOffset === container.nodeValue.length) {
        walker.next();
      }
    }
    while (node = walker.current()) {
      if (NodeType.isElement(node)) {
        if (!node.getAttribute(&#39;data-mce-bogus&#39;)) {
          name = node.nodeName.toLowerCase();
          if (nonEmptyElementsMap[name] &amp;&amp; name !== &#39;br&#39;) {
            return false;
          }
        }
      } else if (NodeType.isText(node) &amp;&amp; !/^[ \t\r\n]*$/.test(node.nodeValue)) {
        return false;
      }
      if (start) {
        walker.prev();
      } else {
        walker.next();
      }
    }
    return true;
  };
  var insertNewBlockAfter = function () {
    if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) &amp;&amp; containerBlockName !== &#39;HGROUP&#39;) {
      newBlock = createNewBlock(newBlockName);
    } else {
      newBlock = createNewBlock();
    }
    if (Settings.shouldEndContainerOnEmptyBlock(editor) &amp;&amp; canSplitBlock(dom, containerBlock) &amp;&amp; dom.isEmpty(parentBlock)) {
      newBlock = dom.split(containerBlock, parentBlock);
    } else {
      dom.insertAfter(newBlock, parentBlock);
    }
    NewLineUtils.moveToCaretPosition(editor, newBlock);
  };
  NormalizeRange.normalize(dom, rng).each(function (normRng) {
    rng.setStart(normRng.startContainer, normRng.startOffset);
    rng.setEnd(normRng.endContainer, normRng.endOffset);
  });
  container = rng.startContainer;
  offset = rng.startOffset;
  newBlockName = Settings.getForcedRootBlock(editor);
  shiftKey = evt.shiftKey;
  if (NodeType.isElement(container) &amp;&amp; container.hasChildNodes()) {
    isAfterLastNodeInContainer = offset &gt; container.childNodes.length - 1;
    container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;
    if (isAfterLastNodeInContainer &amp;&amp; NodeType.isText(container)) {
      offset = container.nodeValue.length;
    } else {
      offset = 0;
    }
  }
  editableRoot = getEditableRoot$1(dom, container);
  if (!editableRoot) {
    return;
  }
  if (newBlockName &amp;&amp; !shiftKey || !newBlockName &amp;&amp; shiftKey) {
    container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);
  }
  parentBlock = dom.getParent(container, dom.isBlock);
  containerBlock = parentBlock ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;
  parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : &#39;&#39;;
  containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : &#39;&#39;;
  if (containerBlockName === &#39;LI&#39; &amp;&amp; !evt.ctrlKey) {
    parentBlock = containerBlock;
    containerBlock = containerBlock.parentNode;
    parentBlockName = containerBlockName;
  }
  if (/^(LI|DT|DD)$/.test(parentBlockName)) {
    if (dom.isEmpty(parentBlock)) {
      InsertLi.insert(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
      return;
    }
  }
  if (newBlockName &amp;&amp; parentBlock === editor.getBody()) {
    return;
  }
  newBlockName = newBlockName || &#39;P&#39;;
  if (isCaretContainerBlock(parentBlock)) {
    newBlock = showCaretContainerBlock(parentBlock);
    if (dom.isEmpty(parentBlock)) {
      emptyBlock(parentBlock);
    }
    NewLineUtils.moveToCaretPosition(editor, newBlock);
  } else if (isCaretAtStartOrEndOfBlock()) {
    insertNewBlockAfter();
  } else if (isCaretAtStartOrEndOfBlock(true)) {
    newBlock = parentBlock.parentNode.insertBefore(createNewBlock(), parentBlock);
    NewLineUtils.moveToCaretPosition(editor, containerAndSiblingName(parentBlock, &#39;HR&#39;) ? newBlock : parentBlock);
  } else {
    tmpRng = includeZwspInRange(rng).cloneRange();
    tmpRng.setEndAfter(parentBlock);
    fragment = tmpRng.extractContents();
    trimLeadingLineBreaks(fragment);
    newBlock = fragment.firstChild;
    dom.insertAfter(fragment, parentBlock);
    trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);
    addBrToBlockIfNeeded(dom, parentBlock);
    if (dom.isEmpty(parentBlock)) {
      emptyBlock(parentBlock);
    }
    newBlock.normalize();
    if (dom.isEmpty(newBlock)) {
      dom.remove(newBlock);
      insertNewBlockAfter();
    } else {
      NewLineUtils.moveToCaretPosition(editor, newBlock);
    }
  }
  dom.setAttrib(newBlock, &#39;id&#39;, &#39;&#39;);
  editor.fire(&#39;NewBlock&#39;, { newBlock: newBlock });
};
var InsertBlock = { insert: insert$2 };

var matchesSelector = function (editor, selector) {
  return NewLineUtils.getParentBlock(editor).filter(function (parentBlock) {
    return selector.length &gt; 0 &amp;&amp; is$1(Element$$1.fromDom(parentBlock), selector);
  }).isSome();
};
var shouldInsertBr = function (editor) {
  return matchesSelector(editor, Settings.getBrNewLineSelector(editor));
};
var shouldBlockNewLine = function (editor) {
  return matchesSelector(editor, Settings.getNoNewLineSelector(editor));
};
var ContextSelectors = {
  shouldInsertBr: shouldInsertBr,
  shouldBlockNewLine: shouldBlockNewLine
};

var newLineAction = Adt.generate([
  { br: [] },
  { block: [] },
  { none: [] }
]);
var shouldBlockNewLine$1 = function (editor, shiftKey) {
  return ContextSelectors.shouldBlockNewLine(editor);
};
var isBrMode = function (requiredState) {
  return function (editor, shiftKey) {
    var brMode = Settings.getForcedRootBlock(editor) === &#39;&#39;;
    return brMode === requiredState;
  };
};
var inListBlock = function (requiredState) {
  return function (editor, shiftKey) {
    return NewLineUtils.isListItemParentBlock(editor) === requiredState;
  };
};
var inBlock = function (blockName, requiredState) {
  return function (editor, shiftKey) {
    var state = NewLineUtils.getParentBlockName(editor) === blockName.toUpperCase();
    return state === requiredState;
  };
};
var inPreBlock = function (requiredState) {
  return inBlock(&#39;pre&#39;, requiredState);
};
var inSummaryBlock = function () {
  return inBlock(&#39;summary&#39;, true);
};
var shouldPutBrInPre$1 = function (requiredState) {
  return function (editor, shiftKey) {
    return Settings.shouldPutBrInPre(editor) === requiredState;
  };
};
var inBrContext = function (editor, shiftKey) {
  return ContextSelectors.shouldInsertBr(editor);
};
var hasShiftKey = function (editor, shiftKey) {
  return shiftKey;
};
var canInsertIntoEditableRoot = function (editor) {
  var forcedRootBlock = Settings.getForcedRootBlock(editor);
  var rootEditable = NewLineUtils.getEditableRoot(editor.dom, editor.selection.getStart());
  return rootEditable &amp;&amp; editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock ? forcedRootBlock : &#39;P&#39;);
};
var match$2 = function (predicates, action) {
  return function (editor, shiftKey) {
    var isMatch = foldl(predicates, function (res, p) {
      return res &amp;&amp; p(editor, shiftKey);
    }, true);
    return isMatch ? Option.some(action) : Option.none();
  };
};
var getAction$1 = function (editor, evt) {
  return LazyEvaluator.evaluateUntil([
    match$2([shouldBlockNewLine$1], newLineAction.none()),
    match$2([inSummaryBlock()], newLineAction.br()),
    match$2([
      inPreBlock(true),
      shouldPutBrInPre$1(false),
      hasShiftKey
    ], newLineAction.br()),
    match$2([
      inPreBlock(true),
      shouldPutBrInPre$1(false)
    ], newLineAction.block()),
    match$2([
      inPreBlock(true),
      shouldPutBrInPre$1(true),
      hasShiftKey
    ], newLineAction.block()),
    match$2([
      inPreBlock(true),
      shouldPutBrInPre$1(true)
    ], newLineAction.br()),
    match$2([
      inListBlock(true),
      hasShiftKey
    ], newLineAction.br()),
    match$2([inListBlock(true)], newLineAction.block()),
    match$2([
      isBrMode(true),
      hasShiftKey,
      canInsertIntoEditableRoot
    ], newLineAction.block()),
    match$2([isBrMode(true)], newLineAction.br()),
    match$2([inBrContext], newLineAction.br()),
    match$2([
      isBrMode(false),
      hasShiftKey
    ], newLineAction.br()),
    match$2([canInsertIntoEditableRoot], newLineAction.block())
  ], [
    editor,
    evt.shiftKey
  ]).getOr(newLineAction.none());
};
var NewLineAction = { getAction: getAction$1 };

var insert$3 = function (editor, evt) {
  NewLineAction.getAction(editor, evt).fold(function () {
    InsertBr.insert(editor, evt);
  }, function () {
    InsertBlock.insert(editor, evt);
  }, noop);
};
var InsertNewLine = { insert: insert$3 };

var endTypingLevel = function (undoManager) {
  if (undoManager.typing) {
    undoManager.typing = false;
    undoManager.add();
  }
};
var handleEnterKeyEvent = function (editor, event) {
  if (event.isDefaultPrevented()) {
    return;
  }
  event.preventDefault();
  endTypingLevel(editor.undoManager);
  editor.undoManager.transact(function () {
    if (editor.selection.isCollapsed() === false) {
      editor.execCommand(&#39;Delete&#39;);
    }
    InsertNewLine.insert(editor, event);
  });
};
var setup$9 = function (editor) {
  editor.on(&#39;keydown&#39;, function (event) {
    if (event.keyCode === VK.ENTER) {
      handleEnterKeyEvent(editor, event);
    }
  });
};
var EnterKey = { setup: setup$9 };

var insertTextAtPosition = function (text, pos) {
  var container = pos.container();
  var offset = pos.offset();
  if (NodeType.isText(container)) {
    container.insertData(offset, text);
    return Option.some(CaretPosition(container, offset + text.length));
  } else {
    return getElementFromPosition(pos).map(function (elm) {
      var textNode = Element$$1.fromText(text);
      if (pos.isAtEnd()) {
        after(elm, textNode);
      } else {
        before(elm, textNode);
      }
      return CaretPosition(textNode.dom(), text.length);
    });
  }
};
var insertNbspAtPosition = curry(insertTextAtPosition, &#39;\xA0&#39;);
var insertSpaceAtPosition = curry(insertTextAtPosition, &#39; &#39;);

var isAtBlockBoundary = function (forward, root, pos) {
  var parentBlocks = filter(Parents.parentsAndSelf(Element$$1.fromDom(pos.container()), root), isBlock);
  return head(parentBlocks).exists(function (parent) {
    return CaretFinder.navigate(forward, parent.dom(), pos).isNone();
  });
};
var isAtStartOfBlock = curry(isAtBlockBoundary, false);
var isAtEndOfBlock = curry(isAtBlockBoundary, true);

var nbsp = &#39;\xA0&#39;;
var isInMiddleOfText = function (pos) {
  return CaretPosition.isTextPosition(pos) &amp;&amp; !pos.isAtStart() &amp;&amp; !pos.isAtEnd();
};
var getClosestBlock = function (root, pos) {
  var parentBlocks = filter(Parents.parentsAndSelf(Element$$1.fromDom(pos.container()), root), isBlock);
  return head(parentBlocks).getOr(root);
};
var hasSpaceBefore = function (root, pos) {
  if (isInMiddleOfText(pos)) {
    return isAfterSpace(pos);
  } else {
    return isAfterSpace(pos) || CaretFinder.prevPosition(getClosestBlock(root, pos).dom(), pos).exists(isAfterSpace);
  }
};
var hasSpaceAfter = function (root, pos) {
  if (isInMiddleOfText(pos)) {
    return isBeforeSpace(pos);
  } else {
    return isBeforeSpace(pos) || CaretFinder.nextPosition(getClosestBlock(root, pos).dom(), pos).exists(isBeforeSpace);
  }
};
var isPreValue = function (value$$1) {
  return contains([
    &#39;pre&#39;,
    &#39;pre-line&#39;,
    &#39;pre-wrap&#39;
  ], value$$1);
};
var isInPre = function (pos) {
  return getElementFromPosition(pos).bind(function (elm) {
    return closest(elm, isElement);
  }).exists(function (elm) {
    return isPreValue(get$2(elm, &#39;white-space&#39;));
  });
};
var isAtLineBoundary = function (root, pos) {
  return isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr(root, pos);
};
var needsToHaveNbsp = function (root, pos) {
  if (isInPre(pos)) {
    return false;
  } else {
    return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
  }
};
var needsToBeNbspLeft = function (root, pos) {
  if (isInPre(pos)) {
    return false;
  } else {
    return isAtStartOfBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos);
  }
};
var needsToBeNbspRight = function (root, pos) {
  if (isInPre(pos)) {
    return false;
  } else {
    return isAtEndOfBlock(root, pos) || isBeforeBr(root, pos) || hasSpaceAfter(root, pos);
  }
};
var isNbspAt = function (text, offset) {
  return isNbsp(text.charAt(offset));
};
var hasNbsp = function (pos) {
  var container = pos.container();
  return NodeType.isText(container) &amp;&amp; contains$2(container.data, nbsp);
};
var normalizeNbspAtStart = function (root, node, text) {
  var firstPos = CaretPosition(node, 0);
  if (isNbspAt(text, 0) &amp;&amp; !needsToBeNbspLeft(root, firstPos)) {
    return &#39; &#39; + text.slice(1);
  } else {
    return text;
  }
};
var normalizeNbspMiddle = function (text) {
  return map(text.split(&#39;&#39;), function (chr, i, chars) {
    if (isNbsp(chr) &amp;&amp; i &gt; 0 &amp;&amp; i &lt; chars.length - 1 &amp;&amp; isContent(chars[i - 1]) &amp;&amp; isContent(chars[i + 1])) {
      return &#39; &#39;;
    } else {
      return chr;
    }
  }).join(&#39;&#39;);
};
var normalizeNbspAtEnd = function (root, node, text) {
  var lastPos = CaretPosition(node, text.length);
  if (isNbspAt(text, text.length - 1) &amp;&amp; !needsToBeNbspRight(root, lastPos)) {
    return text.slice(0, -1) + &#39; &#39;;
  } else {
    return text;
  }
};
var normalizeNbsps = function (root, pos) {
  return Option.some(pos).filter(hasNbsp).bind(function (pos) {
    var container = pos.container();
    var text = container.nodeValue;
    var newText = normalizeNbspAtStart(root, container, normalizeNbspMiddle(normalizeNbspAtEnd(root, container, text)));
    if (text !== newText) {
      pos.container().nodeValue = newText;
      return Option.some(pos);
    } else {
      return Option.none();
    }
  });
};
var normalizeNbspsInEditor = function (editor) {
  var root = Element$$1.fromDom(editor.getBody());
  if (editor.selection.isCollapsed()) {
    normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each(function (pos) {
      editor.selection.setRng(pos.toRange());
    });
  }
};

var insertSpaceOrNbspAtPosition = function (root, pos) {
  return needsToHaveNbsp(root, pos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
};
var locationToCaretPosition = function (root) {
  return function (location) {
    return location.fold(function (element) {
      return CaretFinder.prevPosition(root.dom(), CaretPosition$1.before(element));
    }, function (element) {
      return CaretFinder.firstPositionIn(element);
    }, function (element) {
      return CaretFinder.lastPositionIn(element);
    }, function (element) {
      return CaretFinder.nextPosition(root.dom(), CaretPosition$1.after(element));
    });
  };
};
var insertInlineBoundarySpaceOrNbsp = function (root, pos) {
  return function (checkPos) {
    return needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
  };
};
var setSelection$1 = function (editor) {
  return function (pos) {
    editor.selection.setRng(pos.toRange());
    editor.nodeChanged();
    return true;
  };
};
var insertSpaceOrNbspAtSelection = function (editor) {
  var pos = CaretPosition$1.fromRangeStart(editor.selection.getRng());
  var root = Element$$1.fromDom(editor.getBody());
  if (editor.selection.isCollapsed()) {
    var isInlineTarget = curry(InlineUtils.isInlineTarget, editor);
    var caretPosition = CaretPosition$1.fromRangeStart(editor.selection.getRng());
    return BoundaryLocation.readLocation(isInlineTarget, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).bind(insertInlineBoundarySpaceOrNbsp(root, pos)).fold(function () {
      return insertSpaceOrNbspAtPosition(root, pos).map(setSelection$1(editor)).getOr(false);
    }, setSelection$1(editor));
  } else {
    return false;
  }
};

var executeKeydownOverride$2 = function (editor, evt) {
  MatchKeys.execute([{
      keyCode: VK.SPACEBAR,
      action: MatchKeys.action(insertSpaceOrNbspAtSelection, editor)
    }], evt).each(function (_) {
    evt.preventDefault();
  });
};
var setup$a = function (editor) {
  editor.on(&#39;keydown&#39;, function (evt) {
    if (evt.isDefaultPrevented() === false) {
      executeKeydownOverride$2(editor, evt);
    }
  });
};
var SpaceKey = { setup: setup$a };

var findBlockCaretContainer = function (editor) {
  return descendant$1(Element$$1.fromDom(editor.getBody()), &#39;*[data-mce-caret]&#39;).fold(constant(null), function (elm) {
    return elm.dom();
  });
};
var removeIeControlRect = function (editor) {
  editor.selection.setRng(editor.selection.getRng());
};
var showBlockCaretContainer = function (editor, blockCaretContainer) {
  if (blockCaretContainer.hasAttribute(&#39;data-mce-caret&#39;)) {
    showCaretContainerBlock(blockCaretContainer);
    removeIeControlRect(editor);
    editor.selection.scrollIntoView(blockCaretContainer);
  }
};
var handleBlockContainer = function (editor, e) {
  var blockCaretContainer = findBlockCaretContainer(editor);
  if (!blockCaretContainer) {
    return;
  }
  if (e.type === &#39;compositionstart&#39;) {
    e.preventDefault();
    e.stopPropagation();
    showBlockCaretContainer(editor, blockCaretContainer);
    return;
  }
  if (hasContent(blockCaretContainer)) {
    showBlockCaretContainer(editor, blockCaretContainer);
    editor.undoManager.add();
  }
};
var setup$b = function (editor) {
  editor.on(&#39;keyup compositionstart&#39;, curry(handleBlockContainer, editor));
};
var CaretContainerInput = { setup: setup$b };

var setup$c = function (editor) {
  editor.on(&#39;input&#39;, function (e) {
    if (e.isComposing === false) {
      normalizeNbspsInEditor(editor);
    }
  });
};

var setup$d = function (editor) {
  var caret = BoundarySelection.setupSelectedState(editor);
  CaretContainerInput.setup(editor);
  ArrowKeys.setup(editor, caret);
  DeleteBackspaceKeys.setup(editor, caret);
  EnterKey.setup(editor);
  SpaceKey.setup(editor);
  setup$c(editor);
};
var KeyboardOverrides = { setup: setup$d };

function Quirks (editor) {
  var each = Tools.each;
  var BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, settings = editor.settings, parser = editor.parser;
  var isGecko = Env.gecko, isIE = Env.ie, isWebKit = Env.webkit;
  var mceInternalUrlPrefix = &#39;data:text/mce-internal,&#39;;
  var mceInternalDataType = isIE ? &#39;Text&#39; : &#39;URL&#39;;
  var setEditorCommandState = function (cmd, state) {
    try {
      editor.getDoc().execCommand(cmd, false, state);
    } catch (ex) {
    }
  };
  var isDefaultPrevented = function (e) {
    return e.isDefaultPrevented();
  };
  var setMceInternalContent = function (e) {
    var selectionHtml, internalContent;
    if (e.dataTransfer) {
      if (editor.selection.isCollapsed() &amp;&amp; e.target.tagName === &#39;IMG&#39;) {
        selection.select(e.target);
      }
      selectionHtml = editor.selection.getContent();
      if (selectionHtml.length &gt; 0) {
        internalContent = mceInternalUrlPrefix + escape(editor.id) + &#39;,&#39; + escape(selectionHtml);
        e.dataTransfer.setData(mceInternalDataType, internalContent);
      }
    }
  };
  var getMceInternalContent = function (e) {
    var internalContent;
    if (e.dataTransfer) {
      internalContent = e.dataTransfer.getData(mceInternalDataType);
      if (internalContent &amp;&amp; internalContent.indexOf(mceInternalUrlPrefix) &gt;= 0) {
        internalContent = internalContent.substr(mceInternalUrlPrefix.length).split(&#39;,&#39;);
        return {
          id: unescape(internalContent[0]),
          html: unescape(internalContent[1])
        };
      }
    }
    return null;
  };
  var insertClipboardContents = function (content, internal) {
    if (editor.queryCommandSupported(&#39;mceInsertClipboardContent&#39;)) {
      editor.execCommand(&#39;mceInsertClipboardContent&#39;, false, {
        content: content,
        internal: internal
      });
    } else {
      editor.execCommand(&#39;mceInsertContent&#39;, false, content);
    }
  };
  var emptyEditorWhenDeleting = function () {
    var serializeRng = function (rng) {
      var body = dom.create(&#39;body&#39;);
      var contents = rng.cloneContents();
      body.appendChild(contents);
      return selection.serializer.serialize(body, { format: &#39;html&#39; });
    };
    var allContentsSelected = function (rng) {
      var selection = serializeRng(rng);
      var allRng = dom.createRng();
      allRng.selectNode(editor.getBody());
      var allSelection = serializeRng(allRng);
      return selection === allSelection;
    };
    editor.on(&#39;keydown&#39;, function (e) {
      var keyCode = e.keyCode;
      var isCollapsed, body;
      if (!isDefaultPrevented(e) &amp;&amp; (keyCode === DELETE || keyCode === BACKSPACE)) {
        isCollapsed = editor.selection.isCollapsed();
        body = editor.getBody();
        if (isCollapsed &amp;&amp; !dom.isEmpty(body)) {
          return;
        }
        if (!isCollapsed &amp;&amp; !allContentsSelected(editor.selection.getRng())) {
          return;
        }
        e.preventDefault();
        editor.setContent(&#39;&#39;);
        if (body.firstChild &amp;&amp; dom.isBlock(body.firstChild)) {
          editor.selection.setCursorLocation(body.firstChild, 0);
        } else {
          editor.selection.setCursorLocation(body, 0);
        }
        editor.nodeChanged();
      }
    });
  };
  var selectAll = function () {
    editor.shortcuts.add(&#39;meta+a&#39;, null, &#39;SelectAll&#39;);
  };
  var inputMethodFocus = function () {
    if (!editor.settings.content_editable) {
      dom.bind(editor.getDoc(), &#39;mousedown mouseup&#39;, function (e) {
        var rng;
        if (e.target === editor.getDoc().documentElement) {
          rng = selection.getRng();
          editor.getBody().focus();
          if (e.type === &#39;mousedown&#39;) {
            if (isCaretContainer(rng.startContainer)) {
              return;
            }
            selection.placeCaretAt(e.clientX, e.clientY);
          } else {
            selection.setRng(rng);
          }
        }
      });
    }
  };
  var removeHrOnBackspace = function () {
    editor.on(&#39;keydown&#39;, function (e) {
      if (!isDefaultPrevented(e) &amp;&amp; e.keyCode === BACKSPACE) {
        if (!editor.getBody().getElementsByTagName(&#39;hr&#39;).length) {
          return;
        }
        if (selection.isCollapsed() &amp;&amp; selection.getRng().startOffset === 0) {
          var node = selection.getNode();
          var previousSibling = node.previousSibling;
          if (node.nodeName === &#39;HR&#39;) {
            dom.remove(node);
            e.preventDefault();
            return;
          }
          if (previousSibling &amp;&amp; previousSibling.nodeName &amp;&amp; previousSibling.nodeName.toLowerCase() === &#39;hr&#39;) {
            dom.remove(previousSibling);
            e.preventDefault();
          }
        }
      }
    });
  };
  var focusBody = function () {
    if (!Range.prototype.getClientRects) {
      editor.on(&#39;mousedown&#39;, function (e) {
        if (!isDefaultPrevented(e) &amp;&amp; e.target.nodeName === &#39;HTML&#39;) {
          var body_1 = editor.getBody();
          body_1.blur();
          Delay.setEditorTimeout(editor, function () {
            body_1.focus();
          });
        }
      });
    }
  };
  var selectControlElements = function () {
    editor.on(&#39;click&#39;, function (e) {
      var target = e.target;
      if (/^(IMG|HR)$/.test(target.nodeName) &amp;&amp; dom.getContentEditableParent(target) !== &#39;false&#39;) {
        e.preventDefault();
        editor.selection.select(target);
        editor.nodeChanged();
      }
      if (target.nodeName === &#39;A&#39; &amp;&amp; dom.hasClass(target, &#39;mce-item-anchor&#39;)) {
        e.preventDefault();
        selection.select(target);
      }
    });
  };
  var removeStylesWhenDeletingAcrossBlockElements = function () {
    var getAttributeApplyFunction = function () {
      var template = dom.getAttribs(selection.getStart().cloneNode(false));
      return function () {
        var target = selection.getStart();
        if (target !== editor.getBody()) {
          dom.setAttrib(target, &#39;style&#39;, null);
          each(template, function (attr) {
            target.setAttributeNode(attr.cloneNode(true));
          });
        }
      };
    };
    var isSelectionAcrossElements = function () {
      return !selection.isCollapsed() &amp;&amp; dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);
    };
    editor.on(&#39;keypress&#39;, function (e) {
      var applyAttributes;
      if (!isDefaultPrevented(e) &amp;&amp; (e.keyCode === 8 || e.keyCode === 46) &amp;&amp; isSelectionAcrossElements()) {
        applyAttributes = getAttributeApplyFunction();
        editor.getDoc().execCommand(&#39;delete&#39;, false, null);
        applyAttributes();
        e.preventDefault();
        return false;
      }
    });
    dom.bind(editor.getDoc(), &#39;cut&#39;, function (e) {
      var applyAttributes;
      if (!isDefaultPrevented(e) &amp;&amp; isSelectionAcrossElements()) {
        applyAttributes = getAttributeApplyFunction();
        Delay.setEditorTimeout(editor, function () {
          applyAttributes();
        });
      }
    });
  };
  var disableBackspaceIntoATable = function () {
    editor.on(&#39;keydown&#39;, function (e) {
      if (!isDefaultPrevented(e) &amp;&amp; e.keyCode === BACKSPACE) {
        if (selection.isCollapsed() &amp;&amp; selection.getRng().startOffset === 0) {
          var previousSibling = selection.getNode().previousSibling;
          if (previousSibling &amp;&amp; previousSibling.nodeName &amp;&amp; previousSibling.nodeName.toLowerCase() === &#39;table&#39;) {
            e.preventDefault();
            return false;
          }
        }
      }
    });
  };
  var removeBlockQuoteOnBackSpace = function () {
    editor.on(&#39;keydown&#39;, function (e) {
      var rng, container, offset, root, parent$$1;
      if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
        return;
      }
      rng = selection.getRng();
      container = rng.startContainer;
      offset = rng.startOffset;
      root = dom.getRoot();
      parent$$1 = container;
      if (!rng.collapsed || offset !== 0) {
        return;
      }
      while (parent$$1 &amp;&amp; parent$$1.parentNode &amp;&amp; parent$$1.parentNode.firstChild === parent$$1 &amp;&amp; parent$$1.parentNode !== root) {
        parent$$1 = parent$$1.parentNode;
      }
      if (parent$$1.tagName === &#39;BLOCKQUOTE&#39;) {
        editor.formatter.toggle(&#39;blockquote&#39;, null, parent$$1);
        rng = dom.createRng();
        rng.setStart(container, 0);
        rng.setEnd(container, 0);
        selection.setRng(rng);
      }
    });
  };
  var setGeckoEditingOptions = function () {
    var setOpts = function () {
      setEditorCommandState(&#39;StyleWithCSS&#39;, false);
      setEditorCommandState(&#39;enableInlineTableEditing&#39;, false);
      if (!settings.object_resizing) {
        setEditorCommandState(&#39;enableObjectResizing&#39;, false);
      }
    };
    if (!settings.readonly) {
      editor.on(&#39;BeforeExecCommand MouseDown&#39;, setOpts);
    }
  };
  var addBrAfterLastLinks = function () {
    var fixLinks = function () {
      each(dom.select(&#39;a&#39;), function (node) {
        var parentNode = node.parentNode;
        var root = dom.getRoot();
        if (parentNode.lastChild === node) {
          while (parentNode &amp;&amp; !dom.isBlock(parentNode)) {
            if (parentNode.parentNode.lastChild !== parentNode || parentNode === root) {
              return;
            }
            parentNode = parentNode.parentNode;
          }
          dom.add(parentNode, &#39;br&#39;, { &#39;data-mce-bogus&#39;: 1 });
        }
      });
    };
    editor.on(&#39;SetContent ExecCommand&#39;, function (e) {
      if (e.type === &#39;setcontent&#39; || e.command === &#39;mceInsertLink&#39;) {
        fixLinks();
      }
    });
  };
  var setDefaultBlockType = function () {
    if (settings.forced_root_block) {
      editor.on(&#39;init&#39;, function () {
        setEditorCommandState(&#39;DefaultParagraphSeparator&#39;, settings.forced_root_block);
      });
    }
  };
  var normalizeSelection = function () {
    editor.on(&#39;keyup focusin mouseup&#39;, function (e) {
      if (!VK.modifierPressed(e)) {
        selection.normalize();
      }
    }, true);
  };
  var showBrokenImageIcon = function () {
    editor.contentStyles.push(&#39;img:-moz-broken {&#39; + &#39;-moz-force-broken-image-icon:1;&#39; + &#39;min-width:24px;&#39; + &#39;min-height:24px&#39; + &#39;}&#39;);
  };
  var restoreFocusOnKeyDown = function () {
    if (!editor.inline) {
      editor.on(&#39;keydown&#39;, function () {
        if (document.activeElement === document.body) {
          editor.getWin().focus();
        }
      });
    }
  };
  var bodyHeight = function () {
    if (!editor.inline) {
      editor.contentStyles.push(&#39;body {min-height: 150px}&#39;);
      editor.on(&#39;click&#39;, function (e) {
        var rng;
        if (e.target.nodeName === &#39;HTML&#39;) {
          if (Env.ie &gt; 11) {
            editor.getBody().focus();
            return;
          }
          rng = editor.selection.getRng();
          editor.getBody().focus();
          editor.selection.setRng(rng);
          editor.selection.normalize();
          editor.nodeChanged();
        }
      });
    }
  };
  var blockCmdArrowNavigation = function () {
    if (Env.mac) {
      editor.on(&#39;keydown&#39;, function (e) {
        if (VK.metaKeyPressed(e) &amp;&amp; !e.shiftKey &amp;&amp; (e.keyCode === 37 || e.keyCode === 39)) {
          e.preventDefault();
          editor.selection.getSel().modify(&#39;move&#39;, e.keyCode === 37 ? &#39;backward&#39; : &#39;forward&#39;, &#39;lineboundary&#39;);
        }
      });
    }
  };
  var disableAutoUrlDetect = function () {
    setEditorCommandState(&#39;AutoUrlDetect&#39;, false);
  };
  var tapLinksAndImages = function () {
    editor.on(&#39;click&#39;, function (e) {
      var elm = e.target;
      do {
        if (elm.tagName === &#39;A&#39;) {
          e.preventDefault();
          return;
        }
      } while (elm = elm.parentNode);
    });
    editor.contentStyles.push(&#39;.mce-content-body {-webkit-touch-callout: none}&#39;);
  };
  var blockFormSubmitInsideEditor = function () {
    editor.on(&#39;init&#39;, function () {
      editor.dom.bind(editor.getBody(), &#39;submit&#39;, function (e) {
        e.preventDefault();
      });
    });
  };
  var removeAppleInterchangeBrs = function () {
    parser.addNodeFilter(&#39;br&#39;, function (nodes) {
      var i = nodes.length;
      while (i--) {
        if (nodes[i].attr(&#39;class&#39;) === &#39;Apple-interchange-newline&#39;) {
          nodes[i].remove();
        }
      }
    });
  };
  var ieInternalDragAndDrop = function () {
    editor.on(&#39;dragstart&#39;, function (e) {
      setMceInternalContent(e);
    });
    editor.on(&#39;drop&#39;, function (e) {
      if (!isDefaultPrevented(e)) {
        var internalContent = getMceInternalContent(e);
        if (internalContent &amp;&amp; internalContent.id !== editor.id) {
          e.preventDefault();
          var rng = CaretRangeFromPoint.fromPoint(e.x, e.y, editor.getDoc());
          selection.setRng(rng);
          insertClipboardContents(internalContent.html, true);
        }
      }
    });
  };
  var refreshContentEditable = function () {
  };
  var isHidden = function () {
    var sel;
    if (!isGecko || editor.removed) {
      return 0;
    }
    sel = editor.selection.getSel();
    return !sel || !sel.rangeCount || sel.rangeCount === 0;
  };
  removeBlockQuoteOnBackSpace();
  emptyEditorWhenDeleting();
  if (!Env.windowsPhone) {
    normalizeSelection();
  }
  if (isWebKit) {
    inputMethodFocus();
    selectControlElements();
    setDefaultBlockType();
    blockFormSubmitInsideEditor();
    disableBackspaceIntoATable();
    removeAppleInterchangeBrs();
    if (Env.iOS) {
      restoreFocusOnKeyDown();
      bodyHeight();
      tapLinksAndImages();
    } else {
      selectAll();
    }
  }
  if (Env.ie &gt;= 11) {
    bodyHeight();
    disableBackspaceIntoATable();
  }
  if (Env.ie) {
    selectAll();
    disableAutoUrlDetect();
    ieInternalDragAndDrop();
  }
  if (isGecko) {
    removeHrOnBackspace();
    focusBody();
    removeStylesWhenDeletingAcrossBlockElements();
    setGeckoEditingOptions();
    addBrAfterLastLinks();
    showBrokenImageIcon();
    blockCmdArrowNavigation();
    disableBackspaceIntoATable();
  }
  return {
    refreshContentEditable: refreshContentEditable,
    isHidden: isHidden
  };
}

var isTextBlockNode = function (node) {
  return NodeType.isElement(node) &amp;&amp; isTextBlock(Element$$1.fromDom(node));
};
var normalizeSelection$1 = function (editor) {
  var rng = editor.selection.getRng();
  var startPos = CaretPosition.fromRangeStart(rng);
  var endPos = CaretPosition.fromRangeEnd(rng);
  if (CaretPosition.isElementPosition(startPos)) {
    var container = startPos.container();
    if (isTextBlockNode(container)) {
      CaretFinder.firstPositionIn(container).each(function (pos) {
        return rng.setStart(pos.container(), pos.offset());
      });
    }
  }
  if (CaretPosition.isElementPosition(endPos)) {
    var container = startPos.container();
    if (isTextBlockNode(container)) {
      CaretFinder.lastPositionIn(container).each(function (pos) {
        return rng.setEnd(pos.container(), pos.offset());
      });
    }
  }
  editor.selection.setRng(RangeNormalizer.normalize(rng));
};
var setup$e = function (editor) {
  editor.on(&#39;click&#39;, function (e) {
    if (e.detail &gt;= 3) {
      normalizeSelection$1(editor);
    }
  });
};

var preventSummaryToggle = function (editor) {
  editor.on(&#39;click&#39;, function (e) {
    if (editor.dom.getParent(e.target, &#39;details&#39;)) {
      e.preventDefault();
    }
  });
};
var filterDetails = function (editor) {
  editor.parser.addNodeFilter(&#39;details&#39;, function (elms) {
    each(elms, function (details) {
      details.attr(&#39;data-mce-open&#39;, details.attr(&#39;open&#39;));
      details.attr(&#39;open&#39;, &#39;open&#39;);
    });
  });
  editor.serializer.addNodeFilter(&#39;details&#39;, function (elms) {
    each(elms, function (details) {
      var open = details.attr(&#39;data-mce-open&#39;);
      details.attr(&#39;open&#39;, isString(open) ? open : null);
      details.attr(&#39;data-mce-open&#39;, null);
    });
  });
};
var setup$f = function (editor) {
  preventSummaryToggle(editor);
  filterDetails(editor);
};

var DOM$2 = DOMUtils$1.DOM;
var appendStyle = function (editor, text) {
  var head = Element$$1.fromDom(editor.getDoc().head);
  var tag = Element$$1.fromTag(&#39;style&#39;);
  set(tag, &#39;type&#39;, &#39;text/css&#39;);
  append(tag, Element$$1.fromText(text));
  append(head, tag);
};
var createParser = function (editor) {
  var parser = DomParser(editor.settings, editor.schema);
  parser.addAttributeFilter(&#39;src,href,style,tabindex&#39;, function (nodes, name$$1) {
    var i = nodes.length, node;
    var dom = editor.dom;
    var value, internalName;
    while (i--) {
      node = nodes[i];
      value = node.attr(name$$1);
      internalName = &#39;data-mce-&#39; + name$$1;
      if (!node.attributes.map[internalName]) {
        if (value.indexOf(&#39;data:&#39;) === 0 || value.indexOf(&#39;blob:&#39;) === 0) {
          continue;
        }
        if (name$$1 === &#39;style&#39;) {
          value = dom.serializeStyle(dom.parseStyle(value), node.name);
          if (!value.length) {
            value = null;
          }
          node.attr(internalName, value);
          node.attr(name$$1, value);
        } else if (name$$1 === &#39;tabindex&#39;) {
          node.attr(internalName, value);
          node.attr(name$$1, null);
        } else {
          node.attr(internalName, editor.convertURL(value, name$$1, node.name));
        }
      }
    }
  });
  parser.addNodeFilter(&#39;script&#39;, function (nodes) {
    var i = nodes.length, node, type;
    while (i--) {
      node = nodes[i];
      type = node.attr(&#39;type&#39;) || &#39;no/type&#39;;
      if (type.indexOf(&#39;mce-&#39;) !== 0) {
        node.attr(&#39;type&#39;, &#39;mce-&#39; + type);
      }
    }
  });
  parser.addNodeFilter(&#39;#cdata&#39;, function (nodes) {
    var i = nodes.length, node;
    while (i--) {
      node = nodes[i];
      node.type = 8;
      node.name = &#39;#comment&#39;;
      node.value = &#39;[CDATA[&#39; + node.value + &#39;]]&#39;;
    }
  });
  parser.addNodeFilter(&#39;p,h1,h2,h3,h4,h5,h6,div&#39;, function (nodes) {
    var i = nodes.length, node;
    var nonEmptyElements = editor.schema.getNonEmptyElements();
    while (i--) {
      node = nodes[i];
      if (node.isEmpty(nonEmptyElements) &amp;&amp; node.getAll(&#39;br&#39;).length === 0) {
        node.append(new Node$2(&#39;br&#39;, 1)).shortEnded = true;
      }
    }
  });
  return parser;
};
var autoFocus = function (editor) {
  if (editor.settings.auto_focus) {
    Delay.setEditorTimeout(editor, function () {
      var focusEditor;
      if (editor.settings.auto_focus === true) {
        focusEditor = editor;
      } else {
        focusEditor = editor.editorManager.get(editor.settings.auto_focus);
      }
      if (!focusEditor.destroyed) {
        focusEditor.focus();
      }
    }, 100);
  }
};
var initEditor = function (editor) {
  editor.bindPendingEventDelegates();
  editor.initialized = true;
  editor.fire(&#39;init&#39;);
  editor.focus(true);
  editor.nodeChanged({ initial: true });
  editor.execCallback(&#39;init_instance_callback&#39;, editor);
  autoFocus(editor);
};
var getStyleSheetLoader = function (editor) {
  return editor.inline ? DOM$2.styleSheetLoader : editor.dom.styleSheetLoader;
};
var initContentBody = function (editor, skipWrite) {
  var settings = editor.settings;
  var targetElm = editor.getElement();
  var doc = editor.getDoc(), body, contentCssText;
  if (!settings.inline) {
    editor.getElement().style.visibility = editor.orgVisibility;
  }
  if (!skipWrite &amp;&amp; !settings.content_editable) {
    doc.open();
    doc.write(editor.iframeHTML);
    doc.close();
  }
  if (settings.content_editable) {
    editor.on(&#39;remove&#39;, function () {
      var bodyEl = this.getBody();
      DOM$2.removeClass(bodyEl, &#39;mce-content-body&#39;);
      DOM$2.removeClass(bodyEl, &#39;mce-edit-focus&#39;);
      DOM$2.setAttrib(bodyEl, &#39;contentEditable&#39;, null);
    });
    DOM$2.addClass(targetElm, &#39;mce-content-body&#39;);
    editor.contentDocument = doc = settings.content_document || document;
    editor.contentWindow = settings.content_window || window;
    editor.bodyElement = targetElm;
    settings.content_document = settings.content_window = null;
    settings.root_name = targetElm.nodeName.toLowerCase();
  }
  body = editor.getBody();
  body.disabled = true;
  editor.readonly = settings.readonly;
  if (!editor.readonly) {
    if (editor.inline &amp;&amp; DOM$2.getStyle(body, &#39;position&#39;, true) === &#39;static&#39;) {
      body.style.position = &#39;relative&#39;;
    }
    body.contentEditable = editor.getParam(&#39;content_editable_state&#39;, true);
  }
  body.disabled = false;
  editor.editorUpload = EditorUpload(editor);
  editor.schema = Schema(settings);
  editor.dom = DOMUtils$1(doc, {
    keep_values: true,
    url_converter: editor.convertURL,
    url_converter_scope: editor,
    hex_colors: settings.force_hex_style_colors,
    class_filter: settings.class_filter,
    update_styles: true,
    root_element: editor.inline ? editor.getBody() : null,
    collect: settings.content_editable,
    schema: editor.schema,
    contentCssCors: Settings.shouldUseContentCssCors(editor),
    onSetAttrib: function (e) {
      editor.fire(&#39;SetAttrib&#39;, e);
    }
  });
  editor.parser = createParser(editor);
  editor.serializer = Serializer$1(settings, editor);
  editor.selection = Selection(editor.dom, editor.getWin(), editor.serializer, editor);
  editor.annotator = Annotator(editor);
  editor.formatter = Formatter(editor);
  editor.undoManager = UndoManager(editor);
  editor._nodeChangeDispatcher = new NodeChange(editor);
  editor._selectionOverrides = SelectionOverrides(editor);
  setup$f(editor);
  setup$e(editor);
  KeyboardOverrides.setup(editor);
  ForceBlocks.setup(editor);
  editor.fire(&#39;PreInit&#39;);
  if (!settings.browser_spellcheck &amp;&amp; !settings.gecko_spellcheck) {
    doc.body.spellcheck = false;
    DOM$2.setAttrib(body, &#39;spellcheck&#39;, &#39;false&#39;);
  }
  editor.quirks = Quirks(editor);
  editor.fire(&#39;PostRender&#39;);
  if (settings.directionality) {
    body.dir = settings.directionality;
  }
  if (settings.nowrap) {
    body.style.whiteSpace = &#39;nowrap&#39;;
  }
  if (settings.protect) {
    editor.on(&#39;BeforeSetContent&#39;, function (e) {
      Tools.each(settings.protect, function (pattern) {
        e.content = e.content.replace(pattern, function (str) {
          return &#39;&lt;!--mce:protected &#39; + escape(str) + &#39;--&gt;&#39;;
        });
      });
    });
  }
  editor.on(&#39;SetContent&#39;, function () {
    editor.addVisual(editor.getBody());
  });
  editor.load({
    initial: true,
    format: &#39;html&#39;
  });
  editor.startContent = editor.getContent({ format: &#39;raw&#39; });
  editor.on(&#39;compositionstart compositionend&#39;, function (e) {
    editor.composing = e.type === &#39;compositionstart&#39;;
  });
  if (editor.contentStyles.length &gt; 0) {
    contentCssText = &#39;&#39;;
    Tools.each(editor.contentStyles, function (style) {
      contentCssText += style + &#39;\r\n&#39;;
    });
    editor.dom.addStyle(contentCssText);
  }
  getStyleSheetLoader(editor).loadAll(editor.contentCSS, function (_) {
    initEditor(editor);
  }, function (urls) {
    initEditor(editor);
  });
  if (settings.content_style) {
    appendStyle(editor, settings.content_style);
  }
};
var InitContentBody = { initContentBody: initContentBody };

var DOM$3 = DOMUtils$1.DOM;
var relaxDomain = function (editor, ifr) {
  if (document.domain !== window.location.hostname &amp;&amp; Env.ie &amp;&amp; Env.ie &lt; 12) {
    var bodyUuid = Uuid.uuid(&#39;mce&#39;);
    editor[bodyUuid] = function () {
      InitContentBody.initContentBody(editor);
    };
    var domainRelaxUrl = &#39;javascript:(function(){&#39; + &#39;document.open();document.domain=&quot;&#39; + document.domain + &#39;&quot;;&#39; + &#39;var ed = window.parent.tinymce.get(&quot;&#39; + editor.id + &#39;&quot;);document.write(ed.iframeHTML);&#39; + &#39;document.close();ed.&#39; + bodyUuid + &#39;(true);})()&#39;;
    DOM$3.setAttrib(ifr, &#39;src&#39;, domainRelaxUrl);
    return true;
  }
  return false;
};
var normalizeHeight = function (height) {
  var normalizedHeight = typeof height === &#39;number&#39; ? height + &#39;px&#39; : height;
  return normalizedHeight ? normalizedHeight : &#39;&#39;;
};
var createIframeElement = function (id, title, height, customAttrs) {
  var iframe = Element$$1.fromTag(&#39;iframe&#39;);
  setAll(iframe, customAttrs);
  setAll(iframe, {
    id: id + &#39;_ifr&#39;,
    frameBorder: &#39;0&#39;,
    allowTransparency: &#39;true&#39;,
    title: title
  });
  setAll$1(iframe, {
    width: &#39;100%&#39;,
    height: normalizeHeight(height),
    display: &#39;block&#39;
  });
  return iframe;
};
var getIframeHtml = function (editor) {
  var bodyId, bodyClass, iframeHTML;
  iframeHTML = Settings.getDocType(editor) + &#39;&lt;html&gt;&lt;head&gt;&#39;;
  if (Settings.getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
    iframeHTML += &#39;&lt;bitters href=&quot;&#39; + editor.documentBaseURI.getURI() + &#39;&quot; /&gt;&#39;;
  }
  iframeHTML += &#39;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&#39;;
  bodyId = Settings.getBodyId(editor);
  bodyClass = Settings.getBodyClass(editor);
  if (Settings.getContentSecurityPolicy(editor)) {
    iframeHTML += &#39;&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;&#39; + Settings.getContentSecurityPolicy(editor) + &#39;&quot; /&gt;&#39;;
  }
  iframeHTML += &#39;&lt;/head&gt;&lt;body id=&quot;&#39; + bodyId + &#39;&quot; class=&quot;mce-content-body &#39; + bodyClass + &#39;&quot; data-id=&quot;&#39; + editor.id + &#39;&quot;&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;&#39;;
  return iframeHTML;
};
var createIframe = function (editor, o) {
  var title = editor.editorManager.translate(&#39;Rich Text Area. Press ALT-F9 for menu. &#39; + &#39;Press ALT-F10 for toolbar. Press ALT-0 for help&#39;);
  var ifr = createIframeElement(editor.id, title, o.height, Settings.getIframeAttrs(editor)).dom();
  ifr.onload = function () {
    ifr.onload = null;
    editor.fire(&#39;load&#39;);
  };
  var isDomainRelaxed = relaxDomain(editor, ifr);
  editor.contentAreaContainer = o.iframeContainer;
  editor.iframeElement = ifr;
  editor.iframeHTML = getIframeHtml(editor);
  DOM$3.add(o.iframeContainer, ifr);
  return isDomainRelaxed;
};
var init$1 = function (editor, boxInfo) {
  var isDomainRelaxed = createIframe(editor, boxInfo);
  if (boxInfo.editorContainer) {
    DOM$3.get(boxInfo.editorContainer).style.display = editor.orgDisplay;
    editor.hidden = DOM$3.isHidden(boxInfo.editorContainer);
  }
  editor.getElement().style.display = &#39;none&#39;;
  DOM$3.setAttrib(editor.id, &#39;aria-hidden&#39;, &#39;true&#39;);
  if (!isDomainRelaxed) {
    InitContentBody.initContentBody(editor);
  }
};
var InitIframe = { init: init$1 };

var DOM$4 = DOMUtils$1.DOM;
var initPlugin = function (editor, initializedPlugins, plugin) {
  var Plugin = PluginManager$1.get(plugin);
  var pluginUrl, pluginInstance;
  pluginUrl = PluginManager$1.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, &#39;&#39;);
  plugin = Tools.trim(plugin);
  if (Plugin &amp;&amp; Tools.inArray(initializedPlugins, plugin) === -1) {
    Tools.each(PluginManager$1.dependencies(plugin), function (dep) {
      initPlugin(editor, initializedPlugins, dep);
    });
    if (editor.plugins[plugin]) {
      return;
    }
    pluginInstance = new Plugin(editor, pluginUrl, editor.$);
    editor.plugins[plugin] = pluginInstance;
    if (pluginInstance.init) {
      pluginInstance.init(editor, pluginUrl);
      initializedPlugins.push(plugin);
    }
  }
};
var trimLegacyPrefix = function (name) {
  return name.replace(/^\-/, &#39;&#39;);
};
var initPlugins = function (editor) {
  var initializedPlugins = [];
  Tools.each(editor.settings.plugins.split(/[ ,]/), function (name) {
    initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));
  });
};
var initTheme = function (editor) {
  var Theme;
  var theme = editor.settings.theme;
  if (isString(theme)) {
    editor.settings.theme = trimLegacyPrefix(theme);
    Theme = ThemeManager.get(theme);
    editor.theme = new Theme(editor, ThemeManager.urls[theme]);
    if (editor.theme.init) {
      editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, &#39;&#39;), editor.$);
    }
  } else {
    editor.theme = {};
  }
};
var renderFromLoadedTheme = function (editor) {
  var w, h, minHeight, re, info;
  var settings = editor.settings;
  var elm = editor.getElement();
  w = settings.width || DOM$4.getStyle(elm, &#39;width&#39;) || &#39;100%&#39;;
  h = settings.height || DOM$4.getStyle(elm, &#39;height&#39;) || elm.offsetHeight;
  minHeight = settings.min_height || 100;
  re = /^[0-9\.]+(|px)$/i;
  if (re.test(&#39;&#39; + w)) {
    w = Math.max(parseInt(w, 10), 100);
  }
  if (re.test(&#39;&#39; + h)) {
    h = Math.max(parseInt(h, 10), minHeight);
  }
  info = editor.theme.renderUI({
    targetNode: elm,
    width: w,
    height: h,
    deltaWidth: settings.delta_width,
    deltaHeight: settings.delta_height
  });
  if (!settings.content_editable) {
    h = (info.iframeHeight || h) + (typeof h === &#39;number&#39; ? info.deltaHeight || 0 : &#39;&#39;);
    if (h &lt; minHeight) {
      h = minHeight;
    }
  }
  info.height = h;
  return info;
};
var renderFromThemeFunc = function (editor) {
  var info;
  var elm = editor.getElement();
  info = editor.settings.theme(editor, elm);
  if (info.editorContainer.nodeType) {
    info.editorContainer.id = info.editorContainer.id || editor.id + &#39;_parent&#39;;
  }
  if (info.iframeContainer &amp;&amp; info.iframeContainer.nodeType) {
    info.iframeContainer.id = info.iframeContainer.id || editor.id + &#39;_iframecontainer&#39;;
  }
  info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
  return info;
};
var createThemeFalseResult = function (element) {
  return {
    editorContainer: element,
    iframeContainer: element
  };
};
var renderThemeFalseIframe = function (targetElement) {
  var iframeContainer = DOM$4.create(&#39;div&#39;);
  DOM$4.insertAfter(iframeContainer, targetElement);
  return createThemeFalseResult(iframeContainer);
};
var renderThemeFalse = function (editor) {
  var targetElement = editor.getElement();
  return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
};
var renderThemeUi = function (editor) {
  var settings = editor.settings, elm = editor.getElement();
  editor.orgDisplay = elm.style.display;
  if (isString(settings.theme)) {
    return renderFromLoadedTheme(editor);
  } else if (isFunction(settings.theme)) {
    return renderFromThemeFunc(editor);
  } else {
    return renderThemeFalse(editor);
  }
};
var init$2 = function (editor) {
  var settings = editor.settings;
  var elm = editor.getElement();
  var boxInfo;
  editor.rtl = settings.rtl_ui || editor.editorManager.i18n.rtl;
  editor.editorManager.i18n.setCode(settings.language);
  settings.aria_label = settings.aria_label || DOM$4.getAttrib(elm, &#39;aria-label&#39;, editor.getLang(&#39;aria.rich_text_area&#39;));
  editor.fire(&#39;ScriptsLoaded&#39;);
  initTheme(editor);
  initPlugins(editor);
  boxInfo = renderThemeUi(editor);
  editor.editorContainer = boxInfo.editorContainer ? boxInfo.editorContainer : null;
  if (settings.content_css) {
    Tools.each(Tools.explode(settings.content_css), function (u) {
      editor.contentCSS.push(editor.documentBaseURI.toAbsolute(u));
    });
  }
  if (settings.content_editable) {
    return InitContentBody.initContentBody(editor);
  } else {
    return InitIframe.init(editor, boxInfo);
  }
};
var Init = { init: init$2 };

var DOM$5 = DOMUtils$1.DOM;
var hasSkipLoadPrefix = function (name$$1) {
  return name$$1.charAt(0) === &#39;-&#39;;
};
var loadLanguage = function (scriptLoader, editor) {
  var settings = editor.settings;
  if (settings.language &amp;&amp; settings.language !== &#39;en&#39; &amp;&amp; !settings.language_url) {
    settings.language_url = editor.editorManager.baseURL + &#39;/langs/&#39; + settings.language + &#39;.js&#39;;
  }
  if (settings.language_url &amp;&amp; !editor.editorManager.i18n.data[settings.language]) {
    scriptLoader.add(settings.language_url);
  }
};
var loadTheme = function (scriptLoader, editor, suffix, callback) {
  var settings = editor.settings, theme = settings.theme;
  if (isString(theme)) {
    if (!hasSkipLoadPrefix(theme) &amp;&amp; !ThemeManager.urls.hasOwnProperty(theme)) {
      var themeUrl = settings.theme_url;
      if (themeUrl) {
        ThemeManager.load(theme, editor.documentBaseURI.toAbsolute(themeUrl));
      } else {
        ThemeManager.load(theme, &#39;themes/&#39; + theme + &#39;/theme&#39; + suffix + &#39;.js&#39;);
      }
    }
    scriptLoader.loadQueue(function () {
      ThemeManager.waitFor(theme, callback);
    });
  } else {
    callback();
  }
};
var loadPlugins = function (settings, suffix) {
  if (Tools.isArray(settings.plugins)) {
    settings.plugins = settings.plugins.join(&#39; &#39;);
  }
  Tools.each(settings.external_plugins, function (url, name$$1) {
    PluginManager$1.load(name$$1, url);
    settings.plugins += &#39; &#39; + name$$1;
  });
  Tools.each(settings.plugins.split(/[ ,]/), function (plugin) {
    plugin = Tools.trim(plugin);
    if (plugin &amp;&amp; !PluginManager$1.urls[plugin]) {
      if (hasSkipLoadPrefix(plugin)) {
        plugin = plugin.substr(1, plugin.length);
        var dependencies = PluginManager$1.dependencies(plugin);
        Tools.each(dependencies, function (dep) {
          var defaultSettings = {
            prefix: &#39;plugins/&#39;,
            resource: dep,
            suffix: &#39;/plugin&#39; + suffix + &#39;.js&#39;
          };
          dep = PluginManager$1.createUrl(defaultSettings, dep);
          PluginManager$1.load(dep.resource, dep);
        });
      } else {
        PluginManager$1.load(plugin, {
          prefix: &#39;plugins/&#39;,
          resource: plugin,
          suffix: &#39;/plugin&#39; + suffix + &#39;.js&#39;
        });
      }
    }
  });
};
var loadScripts = function (editor, suffix) {
  var scriptLoader = ScriptLoader.ScriptLoader;
  loadTheme(scriptLoader, editor, suffix, function () {
    loadLanguage(scriptLoader, editor);
    loadPlugins(editor.settings, suffix);
    scriptLoader.loadQueue(function () {
      if (!editor.removed) {
        Init.init(editor);
      }
    }, editor, function (urls) {
      ErrorReporter.pluginLoadError(editor, urls[0]);
      if (!editor.removed) {
        Init.init(editor);
      }
    });
  });
};
var render = function (editor) {
  var settings = editor.settings, id = editor.id;
  var readyHandler = function () {
    DOM$5.unbind(window, &#39;ready&#39;, readyHandler);
    editor.render();
  };
  if (!EventUtils.Event.domLoaded) {
    DOM$5.bind(window, &#39;ready&#39;, readyHandler);
    return;
  }
  if (!editor.getElement()) {
    return;
  }
  if (!Env.contentEditable) {
    return;
  }
  if (!settings.inline) {
    editor.orgVisibility = editor.getElement().style.visibility;
    editor.getElement().style.visibility = &#39;hidden&#39;;
  } else {
    editor.inline = true;
  }
  var form = editor.getElement().form || DOM$5.getParent(id, &#39;form&#39;);
  if (form) {
    editor.formElement = form;
    if (settings.hidden_input &amp;&amp; !/TEXTAREA|INPUT/i.test(editor.getElement().nodeName)) {
      DOM$5.insertAfter(DOM$5.create(&#39;input&#39;, {
        type: &#39;hidden&#39;,
        name: id
      }), id);
      editor.hasHiddenInput = true;
    }
    editor.formEventDelegate = function (e) {
      editor.fire(e.type, e);
    };
    DOM$5.bind(form, &#39;submit reset&#39;, editor.formEventDelegate);
    editor.on(&#39;reset&#39;, function () {
      editor.setContent(editor.startContent, { format: &#39;raw&#39; });
    });
    if (settings.submit_patch &amp;&amp; !form.submit.nodeType &amp;&amp; !form.submit.length &amp;&amp; !form._mceOldSubmit) {
      form._mceOldSubmit = form.submit;
      form.submit = function () {
        editor.editorManager.triggerSave();
        editor.setDirty(false);
        return form._mceOldSubmit(form);
      };
    }
  }
  editor.windowManager = WindowManager(editor);
  editor.notificationManager = NotificationManager(editor);
  if (settings.encoding === &#39;xml&#39;) {
    editor.on(&#39;GetContent&#39;, function (e) {
      if (e.save) {
        e.content = DOM$5.encode(e.content);
      }
    });
  }
  if (settings.add_form_submit_trigger) {
    editor.on(&#39;submit&#39;, function () {
      if (editor.initialized) {
        editor.save();
      }
    });
  }
  if (settings.add_unload_trigger) {
    editor._beforeUnload = function () {
      if (editor.initialized &amp;&amp; !editor.destroyed &amp;&amp; !editor.isHidden()) {
        editor.save({
          format: &#39;raw&#39;,
          no_events: true,
          set_dirty: false
        });
      }
    };
    editor.editorManager.on(&#39;BeforeUnload&#39;, editor._beforeUnload);
  }
  editor.editorManager.add(editor);
  loadScripts(editor, editor.suffix);
};
var Render = { render: render };

var add$4 = function (editor, name, settings) {
  var sidebars = editor.sidebars ? editor.sidebars : [];
  sidebars.push({
    name: name,
    settings: settings
  });
  editor.sidebars = sidebars;
};
var Sidebar = { add: add$4 };

var each$k = Tools.each, trim$4 = Tools.trim;
var queryParts = &#39;source protocol authority userInfo user password host port relative path directory file query anchor&#39;.split(&#39; &#39;);
var DEFAULT_PORTS = {
  ftp: 21,
  http: 80,
  https: 443,
  mailto: 25
};
var URI = function (url, settings) {
  var self$$1 = this;
  var baseUri, baseUrl;
  url = trim$4(url);
  settings = self$$1.settings = settings || {};
  baseUri = settings.base_uri;
  if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
    self$$1.source = url;
    return;
  }
  var isProtocolRelative = url.indexOf(&#39;//&#39;) === 0;
  if (url.indexOf(&#39;/&#39;) === 0 &amp;&amp; !isProtocolRelative) {
    url = (baseUri ? baseUri.protocol || &#39;http&#39; : &#39;http&#39;) + &#39;://mce_host&#39; + url;
  }
  if (!/^[\w\-]*:?\/\//.test(url)) {
    baseUrl = settings.base_uri ? settings.base_uri.path : new URI(document.location.href).directory;
    if (settings.base_uri.protocol == &#39;&#39;) {
      url = &#39;//mce_host&#39; + self$$1.toAbsPath(baseUrl, url);
    } else {
      url = /([^#?]*)([#?]?.*)/.exec(url);
      url = (baseUri &amp;&amp; baseUri.protocol || &#39;http&#39;) + &#39;://mce_host&#39; + self$$1.toAbsPath(baseUrl, url[1]) + url[2];
    }
  }
  url = url.replace(/@@/g, &#39;(mce_at)&#39;);
  url = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
  each$k(queryParts, function (v, i) {
    var part = url[i];
    if (part) {
      part = part.replace(/\(mce_at\)/g, &#39;@@&#39;);
    }
    self$$1[v] = part;
  });
  if (baseUri) {
    if (!self$$1.protocol) {
      self$$1.protocol = baseUri.protocol;
    }
    if (!self$$1.userInfo) {
      self$$1.userInfo = baseUri.userInfo;
    }
    if (!self$$1.port &amp;&amp; self$$1.host === &#39;mce_host&#39;) {
      self$$1.port = baseUri.port;
    }
    if (!self$$1.host || self$$1.host === &#39;mce_host&#39;) {
      self$$1.host = baseUri.host;
    }
    self$$1.source = &#39;&#39;;
  }
  if (isProtocolRelative) {
    self$$1.protocol = &#39;&#39;;
  }
};
URI.prototype = {
  setPath: function (path) {
    var self$$1 = this;
    path = /^(.*?)\/?(\w+)?$/.exec(path);
    self$$1.path = path[0];
    self$$1.directory = path[1];
    self$$1.file = path[2];
    self$$1.source = &#39;&#39;;
    self$$1.getURI();
  },
  toRelative: function (uri) {
    var self$$1 = this;
    var output;
    if (uri === &#39;./&#39;) {
      return uri;
    }
    uri = new URI(uri, { base_uri: self$$1 });
    if (uri.host !== &#39;mce_host&#39; &amp;&amp; self$$1.host !== uri.host &amp;&amp; uri.host || self$$1.port !== uri.port || self$$1.protocol !== uri.protocol &amp;&amp; uri.protocol !== &#39;&#39;) {
      return uri.getURI();
    }
    var tu = self$$1.getURI(), uu = uri.getURI();
    if (tu === uu || tu.charAt(tu.length - 1) === &#39;/&#39; &amp;&amp; tu.substr(0, tu.length - 1) === uu) {
      return tu;
    }
    output = self$$1.toRelPath(self$$1.path, uri.path);
    if (uri.query) {
      output += &#39;?&#39; + uri.query;
    }
    if (uri.anchor) {
      output += &#39;#&#39; + uri.anchor;
    }
    return output;
  },
  toAbsolute: function (uri, noHost) {
    uri = new URI(uri, { base_uri: this });
    return uri.getURI(noHost &amp;&amp; this.isSameOrigin(uri));
  },
  isSameOrigin: function (uri) {
    if (this.host == uri.host &amp;&amp; this.protocol == uri.protocol) {
      if (this.port == uri.port) {
        return true;
      }
      var defaultPort = DEFAULT_PORTS[this.protocol];
      if (defaultPort &amp;&amp; (this.port || defaultPort) == (uri.port || defaultPort)) {
        return true;
      }
    }
    return false;
  },
  toRelPath: function (base, path) {
    var items, breakPoint = 0, out = &#39;&#39;, i, l;
    base = base.substring(0, base.lastIndexOf(&#39;/&#39;));
    base = base.split(&#39;/&#39;);
    items = path.split(&#39;/&#39;);
    if (base.length &gt;= items.length) {
      for (i = 0, l = base.length; i &lt; l; i++) {
        if (i &gt;= items.length || base[i] !== items[i]) {
          breakPoint = i + 1;
          break;
        }
      }
    }
    if (base.length &lt; items.length) {
      for (i = 0, l = items.length; i &lt; l; i++) {
        if (i &gt;= base.length || base[i] !== items[i]) {
          breakPoint = i + 1;
          break;
        }
      }
    }
    if (breakPoint === 1) {
      return path;
    }
    for (i = 0, l = base.length - (breakPoint - 1); i &lt; l; i++) {
      out += &#39;../&#39;;
    }
    for (i = breakPoint - 1, l = items.length; i &lt; l; i++) {
      if (i !== breakPoint - 1) {
        out += &#39;/&#39; + items[i];
      } else {
        out += items[i];
      }
    }
    return out;
  },
  toAbsPath: function (base, path) {
    var i, nb = 0, o = [], tr, outPath;
    tr = /\/$/.test(path) ? &#39;/&#39; : &#39;&#39;;
    base = base.split(&#39;/&#39;);
    path = path.split(&#39;/&#39;);
    each$k(base, function (k) {
      if (k) {
        o.push(k);
      }
    });
    base = o;
    for (i = path.length - 1, o = []; i &gt;= 0; i--) {
      if (path[i].length === 0 || path[i] === &#39;.&#39;) {
        continue;
      }
      if (path[i] === &#39;..&#39;) {
        nb++;
        continue;
      }
      if (nb &gt; 0) {
        nb--;
        continue;
      }
      o.push(path[i]);
    }
    i = base.length - nb;
    if (i &lt;= 0) {
      outPath = o.reverse().join(&#39;/&#39;);
    } else {
      outPath = base.slice(0, i).join(&#39;/&#39;) + &#39;/&#39; + o.reverse().join(&#39;/&#39;);
    }
    if (outPath.indexOf(&#39;/&#39;) !== 0) {
      outPath = &#39;/&#39; + outPath;
    }
    if (tr &amp;&amp; outPath.lastIndexOf(&#39;/&#39;) !== outPath.length - 1) {
      outPath += tr;
    }
    return outPath;
  },
  getURI: function (noProtoHost) {
    var s;
    var self$$1 = this;
    if (!self$$1.source || noProtoHost) {
      s = &#39;&#39;;
      if (!noProtoHost) {
        if (self$$1.protocol) {
          s += self$$1.protocol + &#39;://&#39;;
        } else {
          s += &#39;//&#39;;
        }
        if (self$$1.userInfo) {
          s += self$$1.userInfo + &#39;@&#39;;
        }
        if (self$$1.host) {
          s += self$$1.host;
        }
        if (self$$1.port) {
          s += &#39;:&#39; + self$$1.port;
        }
      }
      if (self$$1.path) {
        s += self$$1.path;
      }
      if (self$$1.query) {
        s += &#39;?&#39; + self$$1.query;
      }
      if (self$$1.anchor) {
        s += &#39;#&#39; + self$$1.anchor;
      }
      self$$1.source = s;
    }
    return self$$1.source;
  }
};
URI.parseDataUri = function (uri) {
  var type, matches;
  uri = decodeURIComponent(uri).split(&#39;,&#39;);
  matches = /data:([^;]+)/.exec(uri[0]);
  if (matches) {
    type = matches[1];
  }
  return {
    type: type,
    data: uri[1]
  };
};
URI.getDocumentBaseUrl = function (loc) {
  var baseUrl;
  if (loc.protocol.indexOf(&#39;http&#39;) !== 0 &amp;&amp; loc.protocol !== &#39;file:&#39;) {
    baseUrl = loc.href;
  } else {
    baseUrl = loc.protocol + &#39;//&#39; + loc.host + loc.pathname;
  }
  if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
    baseUrl = baseUrl.replace(/[\?#].*$/, &#39;&#39;).replace(/[\/\\][^\/]+$/, &#39;&#39;);
    if (!/[\/\\]$/.test(baseUrl)) {
      baseUrl += &#39;/&#39;;
    }
  }
  return baseUrl;
};

var defaultFormat = &#39;html&#39;;
var trimEmptyContents = function (editor, html) {
  var blockName = Settings.getForcedRootBlock(editor);
  var emptyRegExp = new RegExp(&#39;^(&lt;&#39; + blockName + &#39;[^&gt;]*&gt;(&amp;nbsp;|&amp;#160;|\\s|\xA0|&lt;br \\/&gt;|)&lt;\\/&#39; + blockName + &#39;&gt;[\r\n]*|&lt;br \\/&gt;[\r\n]*)$&#39;);
  return html.replace(emptyRegExp, &#39;&#39;);
};
var getContentFromBody = function (editor, args, body) {
  var content;
  args.format = args.format ? args.format : defaultFormat;
  args.get = true;
  args.getInner = true;
  if (!args.no_events) {
    editor.fire(&#39;BeforeGetContent&#39;, args);
  }
  if (args.format === &#39;raw&#39;) {
    content = Tools.trim(TrimHtml.trimExternal(editor.serializer, body.innerHTML));
  } else if (args.format === &#39;text&#39;) {
    content = Zwsp.trim(body.innerText || body.textContent);
  } else if (args.format === &#39;tree&#39;) {
    return editor.serializer.serialize(body, args);
  } else {
    content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
  }
  if (args.format !== &#39;text&#39; &amp;&amp; !isWsPreserveElement(Element$$1.fromDom(body))) {
    args.content = Tools.trim(content);
  } else {
    args.content = content;
  }
  if (!args.no_events) {
    editor.fire(&#39;GetContent&#39;, args);
  }
  return args.content;
};
var getContent$1 = function (editor, args) {
  if (args === void 0) {
    args = {};
  }
  return Option.from(editor.getBody()).fold(constant(args.format === &#39;tree&#39; ? new Node$2(&#39;body&#39;, 11) : &#39;&#39;), function (body) {
    return getContentFromBody(editor, args, body);
  });
};

var traverse = function (node, fn) {
  fn(node);
  if (node.firstChild) {
    traverse(node.firstChild, fn);
  }
  if (node.next) {
    traverse(node.next, fn);
  }
};
var findMatchingNodes = function (nodeFilters, attributeFilters, node) {
  var nodeMatches = {};
  var attrMatches = {};
  var matches = [];
  if (node.firstChild) {
    traverse(node.firstChild, function (node) {
      each(nodeFilters, function (filter$$1) {
        if (filter$$1.name === node.name) {
          if (nodeMatches[filter$$1.name]) {
            nodeMatches[filter$$1.name].nodes.push(node);
          } else {
            nodeMatches[filter$$1.name] = {
              filter: filter$$1,
              nodes: [node]
            };
          }
        }
      });
      each(attributeFilters, function (filter$$1) {
        if (typeof node.attr(filter$$1.name) === &#39;string&#39;) {
          if (attrMatches[filter$$1.name]) {
            attrMatches[filter$$1.name].nodes.push(node);
          } else {
            attrMatches[filter$$1.name] = {
              filter: filter$$1,
              nodes: [node]
            };
          }
        }
      });
    });
  }
  for (var name in nodeMatches) {
    if (nodeMatches.hasOwnProperty(name)) {
      matches.push(nodeMatches[name]);
    }
  }
  for (var name in attrMatches) {
    if (attrMatches.hasOwnProperty(name)) {
      matches.push(attrMatches[name]);
    }
  }
  return matches;
};
var filter$3 = function (nodeFilters, attributeFilters, node) {
  var matches = findMatchingNodes(nodeFilters, attributeFilters, node);
  each(matches, function (match) {
    each(match.filter.callbacks, function (callback) {
      callback(match.nodes, match.filter.name, {});
    });
  });
};

var defaultFormat$1 = &#39;html&#39;;
var isTreeNode = function (content) {
  return content instanceof Node$2;
};
var moveSelection = function (editor) {
  if (EditorFocus.hasFocus(editor)) {
    CaretFinder.firstPositionIn(editor.getBody()).each(function (pos) {
      var node = pos.getNode();
      var caretPos = NodeType.isTable(node) ? CaretFinder.firstPositionIn(node).getOr(pos) : pos;
      editor.selection.setRng(caretPos.toRange());
    });
  }
};
var setEditorHtml = function (editor, html) {
  editor.dom.setHTML(editor.getBody(), html);
  moveSelection(editor);
};
var setContentString = function (editor, body, content, args) {
  var forcedRootBlockName, padd;
  if (content.length === 0 || /^\s+$/.test(content)) {
    padd = &#39;&lt;br data-mce-bogus=&quot;1&quot;&gt;&#39;;
    if (body.nodeName === &#39;TABLE&#39;) {
      content = &#39;&lt;tr&gt;&lt;td&gt;&#39; + padd + &#39;&lt;/td&gt;&lt;/tr&gt;&#39;;
    } else if (/^(UL|OL)$/.test(body.nodeName)) {
      content = &#39;&lt;li&gt;&#39; + padd + &#39;&lt;/li&gt;&#39;;
    }
    forcedRootBlockName = Settings.getForcedRootBlock(editor);
    if (forcedRootBlockName &amp;&amp; editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
      content = padd;
      content = editor.dom.createHTML(forcedRootBlockName, editor.settings.forced_root_block_attrs, content);
    } else if (!content) {
      content = &#39;&lt;br data-mce-bogus=&quot;1&quot;&gt;&#39;;
    }
    setEditorHtml(editor, content);
    editor.fire(&#39;SetContent&#39;, args);
  } else {
    if (args.format !== &#39;raw&#39;) {
      content = Serializer({ validate: editor.validate }, editor.schema).serialize(editor.parser.parse(content, {
        isRootContent: true,
        insert: true
      }));
    }
    args.content = isWsPreserveElement(Element$$1.fromDom(body)) ? content : Tools.trim(content);
    setEditorHtml(editor, args.content);
    if (!args.no_events) {
      editor.fire(&#39;SetContent&#39;, args);
    }
  }
  return args.content;
};
var setContentTree = function (editor, body, content, args) {
  filter$3(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
  var html = Serializer({ validate: editor.validate }, editor.schema).serialize(content);
  args.content = isWsPreserveElement(Element$$1.fromDom(body)) ? html : Tools.trim(html);
  setEditorHtml(editor, args.content);
  if (!args.no_events) {
    editor.fire(&#39;SetContent&#39;, args);
  }
  return content;
};
var setContent$1 = function (editor, content, args) {
  if (args === void 0) {
    args = {};
  }
  args.format = args.format ? args.format : defaultFormat$1;
  args.set = true;
  args.content = isTreeNode(content) ? &#39;&#39; : content;
  if (!isTreeNode(content) &amp;&amp; !args.no_events) {
    editor.fire(&#39;BeforeSetContent&#39;, args);
    content = args.content;
  }
  return Option.from(editor.getBody()).fold(constant(content), function (body) {
    return isTreeNode(content) ? setContentTree(editor, body, content, args) : setContentString(editor, body, content, args);
  });
};

var DOM$6 = DOMUtils$1.DOM;
var restoreOriginalStyles = function (editor) {
  DOM$6.setStyle(editor.id, &#39;display&#39;, editor.orgDisplay);
};
var safeDestroy = function (x) {
  return Option.from(x).each(function (x) {
    return x.destroy();
  });
};
var clearDomReferences = function (editor) {
  editor.contentAreaContainer = editor.formElement = editor.container = editor.editorContainer = null;
  editor.bodyElement = editor.contentDocument = editor.contentWindow = null;
  editor.iframeElement = editor.targetElm = null;
  if (editor.selection) {
    editor.selection = editor.selection.win = editor.selection.dom = editor.selection.dom.doc = null;
  }
};
var restoreForm = function (editor) {
  var form = editor.formElement;
  if (form) {
    if (form._mceOldSubmit) {
      form.submit = form._mceOldSubmit;
      form._mceOldSubmit = null;
    }
    DOM$6.unbind(form, &#39;submit reset&#39;, editor.formEventDelegate);
  }
};
var remove$9 = function (editor) {
  if (!editor.removed) {
    var _selectionOverrides = editor._selectionOverrides, editorUpload = editor.editorUpload;
    var body = editor.getBody();
    var element = editor.getElement();
    if (body) {
      editor.save({ is_removing: true });
    }
    editor.removed = true;
    editor.unbindAllNativeEvents();
    if (editor.hasHiddenInput &amp;&amp; element) {
      DOM$6.remove(element.nextSibling);
    }
    if (!editor.inline &amp;&amp; body) {
      restoreOriginalStyles(editor);
    }
    Events.fireRemove(editor);
    editor.editorManager.remove(editor);
    DOM$6.remove(editor.getContainer());
    safeDestroy(_selectionOverrides);
    safeDestroy(editorUpload);
    editor.destroy();
  }
};
var destroy = function (editor, automatic) {
  var selection = editor.selection, dom = editor.dom;
  if (editor.destroyed) {
    return;
  }
  if (!automatic &amp;&amp; !editor.removed) {
    editor.remove();
    return;
  }
  if (!automatic) {
    editor.editorManager.off(&#39;beforeunload&#39;, editor._beforeUnload);
    if (editor.theme &amp;&amp; editor.theme.destroy) {
      editor.theme.destroy();
    }
    safeDestroy(selection);
    safeDestroy(dom);
  }
  restoreForm(editor);
  clearDomReferences(editor);
  editor.destroyed = true;
};

var DOM$7 = DOMUtils$1.DOM;
var extend$4 = Tools.extend, each$l = Tools.each;
var resolve$4 = Tools.resolve;
var ie$2 = Env.ie;
var Editor = function (id, settings, editorManager) {
  var self = this;
  var documentBaseUrl = self.documentBaseUrl = editorManager.documentBaseURL;
  var baseUri = editorManager.baseURI;
  settings = getEditorSettings(self, id, documentBaseUrl, editorManager.defaultSettings, settings);
  self.settings = settings;
  AddOnManager.language = settings.language || &#39;en&#39;;
  AddOnManager.languageLoad = settings.language_load;
  AddOnManager.baseURL = editorManager.baseURL;
  self.id = id;
  self.setDirty(false);
  self.plugins = {};
  self.documentBaseURI = new URI(settings.document_base_url, { base_uri: baseUri });
  self.baseURI = baseUri;
  self.contentCSS = [];
  self.contentStyles = [];
  self.shortcuts = new Shortcuts(self);
  self.loadedCSS = {};
  self.editorCommands = new EditorCommands(self);
  self.suffix = editorManager.suffix;
  self.editorManager = editorManager;
  self.inline = settings.inline;
  self.buttons = {};
  self.menuItems = {};
  if (settings.cache_suffix) {
    Env.cacheSuffix = settings.cache_suffix.replace(/^[\?\&amp;]+/, &#39;&#39;);
  }
  if (settings.override_viewport === false) {
    Env.overrideViewPort = false;
  }
  editorManager.fire(&#39;SetupEditor&#39;, { editor: self });
  self.execCallback(&#39;setup&#39;, self);
  self.$ = DomQuery.overrideDefaults(function () {
    return {
      context: self.inline ? self.getBody() : self.getDoc(),
      element: self.getBody()
    };
  });
};
Editor.prototype = {
  render: function () {
    Render.render(this);
  },
  focus: function (skipFocus) {
    EditorFocus.focus(this, skipFocus);
  },
  hasFocus: function () {
    return EditorFocus.hasFocus(this);
  },
  execCallback: function (name) {
    var x = [];
    for (var _i = 1; _i &lt; arguments.length; _i++) {
      x[_i - 1] = arguments[_i];
    }
    var self = this;
    var callback = self.settings[name], scope;
    if (!callback) {
      return;
    }
    if (self.callbackLookup &amp;&amp; (scope = self.callbackLookup[name])) {
      callback = scope.func;
      scope = scope.scope;
    }
    if (typeof callback === &#39;string&#39;) {
      scope = callback.replace(/\.\w+$/, &#39;&#39;);
      scope = scope ? resolve$4(scope) : 0;
      callback = resolve$4(callback);
      self.callbackLookup = self.callbackLookup || {};
      self.callbackLookup[name] = {
        func: callback,
        scope: scope
      };
    }
    return callback.apply(scope || self, Array.prototype.slice.call(arguments, 1));
  },
  translate: function (text) {
    if (text &amp;&amp; Tools.is(text, &#39;string&#39;)) {
      var lang_1 = this.settings.language || &#39;en&#39;, i18n_1 = this.editorManager.i18n;
      text = i18n_1.data[lang_1 + &#39;.&#39; + text] || text.replace(/\{\#([^\}]+)\}/g, function (a, b) {
        return i18n_1.data[lang_1 + &#39;.&#39; + b] || &#39;{#&#39; + b + &#39;}&#39;;
      });
    }
    return this.editorManager.translate(text);
  },
  getLang: function (name, defaultVal) {
    return this.editorManager.i18n.data[(this.settings.language || &#39;en&#39;) + &#39;.&#39; + name] || (defaultVal !== undefined ? defaultVal : &#39;{#&#39; + name + &#39;}&#39;);
  },
  getParam: function (name, defaultVal, type) {
    return getParam(this, name, defaultVal, type);
  },
  nodeChanged: function (args) {
    this._nodeChangeDispatcher.nodeChanged(args);
  },
  addButton: function (name, settings) {
    var self = this;
    if (settings.cmd) {
      settings.onclick = function () {
        self.execCommand(settings.cmd);
      };
    }
    if (settings.stateSelector &amp;&amp; typeof settings.active === &#39;undefined&#39;) {
      settings.active = false;
    }
    if (!settings.text &amp;&amp; !settings.icon) {
      settings.icon = name;
    }
    settings.tooltip = settings.tooltip || settings.title;
    self.buttons[name] = settings;
  },
  addSidebar: function (name, settings) {
    return Sidebar.add(this, name, settings);
  },
  addMenuItem: function (name, settings) {
    var self = this;
    if (settings.cmd) {
      settings.onclick = function () {
        self.execCommand(settings.cmd);
      };
    }
    self.menuItems[name] = settings;
  },
  addContextToolbar: function (predicate, items) {
    var self = this;
    var selector;
    self.contextToolbars = self.contextToolbars || [];
    if (typeof predicate === &#39;string&#39;) {
      selector = predicate;
      predicate = function (elm) {
        return self.dom.is(elm, selector);
      };
    }
    self.contextToolbars.push({
      id: Uuid.uuid(&#39;mcet&#39;),
      predicate: predicate,
      items: items
    });
  },
  addCommand: function (name, callback, scope) {
    this.editorCommands.addCommand(name, callback, scope);
  },
  addQueryStateHandler: function (name, callback, scope) {
    this.editorCommands.addQueryStateHandler(name, callback, scope);
  },
  addQueryValueHandler: function (name, callback, scope) {
    this.editorCommands.addQueryValueHandler(name, callback, scope);
  },
  addShortcut: function (pattern, desc, cmdFunc, scope) {
    this.shortcuts.add(pattern, desc, cmdFunc, scope);
  },
  execCommand: function (cmd, ui, value, args) {
    return this.editorCommands.execCommand(cmd, ui, value, args);
  },
  queryCommandState: function (cmd) {
    return this.editorCommands.queryCommandState(cmd);
  },
  queryCommandValue: function (cmd) {
    return this.editorCommands.queryCommandValue(cmd);
  },
  queryCommandSupported: function (cmd) {
    return this.editorCommands.queryCommandSupported(cmd);
  },
  show: function () {
    var self = this;
    if (self.hidden) {
      self.hidden = false;
      if (self.inline) {
        self.getBody().contentEditable = true;
      } else {
        DOM$7.show(self.getContainer());
        DOM$7.hide(self.id);
      }
      self.load();
      self.fire(&#39;show&#39;);
    }
  },
  hide: function () {
    var self = this, doc = self.getDoc();
    if (!self.hidden) {
      if (ie$2 &amp;&amp; doc &amp;&amp; !self.inline) {
        doc.execCommand(&#39;SelectAll&#39;);
      }
      self.save();
      if (self.inline) {
        self.getBody().contentEditable = false;
        if (self === self.editorManager.focusedEditor) {
          self.editorManager.focusedEditor = null;
        }
      } else {
        DOM$7.hide(self.getContainer());
        DOM$7.setStyle(self.id, &#39;display&#39;, self.orgDisplay);
      }
      self.hidden = true;
      self.fire(&#39;hide&#39;);
    }
  },
  isHidden: function () {
    return !!this.hidden;
  },
  setProgressState: function (state, time) {
    this.fire(&#39;ProgressState&#39;, {
      state: state,
      time: time
    });
  },
  load: function (args) {
    var self = this;
    var elm = self.getElement(), html;
    if (self.removed) {
      return &#39;&#39;;
    }
    if (elm) {
      args = args || {};
      args.load = true;
      html = self.setContent(elm.value !== undefined ? elm.value : elm.innerHTML, args);
      args.element = elm;
      if (!args.no_events) {
        self.fire(&#39;LoadContent&#39;, args);
      }
      args.element = elm = null;
      return html;
    }
  },
  save: function (args) {
    var self = this;
    var elm = self.getElement(), html, form;
    if (!elm || !self.initialized || self.removed) {
      return;
    }
    args = args || {};
    args.save = true;
    args.element = elm;
    html = args.content = self.getContent(args);
    if (!args.no_events) {
      self.fire(&#39;SaveContent&#39;, args);
    }
    if (args.format === &#39;raw&#39;) {
      self.fire(&#39;RawSaveContent&#39;, args);
    }
    html = args.content;
    if (!/TEXTAREA|INPUT/i.test(elm.nodeName)) {
      if (args.is_removing || !self.inline) {
        elm.innerHTML = html;
      }
      if (form = DOM$7.getParent(self.id, &#39;form&#39;)) {
        each$l(form.elements, function (elm) {
          if (elm.name === self.id) {
            elm.value = html;
            return false;
          }
        });
      }
    } else {
      elm.value = html;
    }
    args.element = elm = null;
    if (args.set_dirty !== false) {
      self.setDirty(false);
    }
    return html;
  },
  setContent: function (content, args) {
    return setContent$1(this, content, args);
  },
  getContent: function (args) {
    return getContent$1(this, args);
  },
  insertContent: function (content, args) {
    if (args) {
      content = extend$4({ content: content }, args);
    }
    this.execCommand(&#39;mceInsertContent&#39;, false, content);
  },
  isDirty: function () {
    return !this.isNotDirty;
  },
  setDirty: function (state) {
    var oldState = !this.isNotDirty;
    this.isNotDirty = !state;
    if (state &amp;&amp; state !== oldState) {
      this.fire(&#39;dirty&#39;);
    }
  },
  setMode: function (mode) {
    setMode(this, mode);
  },
  getContainer: function () {
    var self = this;
    if (!self.container) {
      self.container = DOM$7.get(self.editorContainer || self.id + &#39;_parent&#39;);
    }
    return self.container;
  },
  getContentAreaContainer: function () {
    return this.contentAreaContainer;
  },
  getElement: function () {
    if (!this.targetElm) {
      this.targetElm = DOM$7.get(this.id);
    }
    return this.targetElm;
  },
  getWin: function () {
    var self = this;
    var elm;
    if (!self.contentWindow) {
      elm = self.iframeElement;
      if (elm) {
        self.contentWindow = elm.contentWindow;
      }
    }
    return self.contentWindow;
  },
  getDoc: function () {
    var self = this;
    var win;
    if (!self.contentDocument) {
      win = self.getWin();
      if (win) {
        self.contentDocument = win.document;
      }
    }
    return self.contentDocument;
  },
  getBody: function () {
    var doc = this.getDoc();
    return this.bodyElement || (doc ? doc.body : null);
  },
  convertURL: function (url, name, elm) {
    var self = this, settings = self.settings;
    if (settings.urlconverter_callback) {
      return self.execCallback(&#39;urlconverter_callback&#39;, url, elm, true, name);
    }
    if (!settings.convert_urls || elm &amp;&amp; elm.nodeName === &#39;LINK&#39; || url.indexOf(&#39;file:&#39;) === 0 || url.length === 0) {
      return url;
    }
    if (settings.relative_urls) {
      return self.documentBaseURI.toRelative(url);
    }
    url = self.documentBaseURI.toAbsolute(url, settings.remove_script_host);
    return url;
  },
  addVisual: function (elm) {
    var self = this;
    var settings = self.settings;
    var dom = self.dom;
    var cls;
    elm = elm || self.getBody();
    if (self.hasVisual === undefined) {
      self.hasVisual = settings.visual;
    }
    each$l(dom.select(&#39;table,a&#39;, elm), function (elm) {
      var value;
      switch (elm.nodeName) {
      case &#39;TABLE&#39;:
        cls = settings.visual_table_class || &#39;mce-item-table&#39;;
        value = dom.getAttrib(elm, &#39;border&#39;);
        if ((!value || value === &#39;0&#39;) &amp;&amp; self.hasVisual) {
          dom.addClass(elm, cls);
        } else {
          dom.removeClass(elm, cls);
        }
        return;
      case &#39;A&#39;:
        if (!dom.getAttrib(elm, &#39;href&#39;)) {
          value = dom.getAttrib(elm, &#39;name&#39;) || elm.id;
          cls = settings.visual_anchor_class || &#39;mce-item-anchor&#39;;
          if (value &amp;&amp; self.hasVisual) {
            dom.addClass(elm, cls);
          } else {
            dom.removeClass(elm, cls);
          }
        }
        return;
      }
    });
    self.fire(&#39;VisualAid&#39;, {
      element: elm,
      hasVisual: self.hasVisual
    });
  },
  remove: function () {
    remove$9(this);
  },
  destroy: function (automatic) {
    destroy(this, automatic);
  },
  uploadImages: function (callback) {
    return this.editorUpload.uploadImages(callback);
  },
  _scanForImages: function () {
    return this.editorUpload.scanForImages();
  }
};
extend$4(Editor.prototype, EditorObservable$1);

var isEditorUIElement = function (elm) {
  return elm.className.toString().indexOf(&#39;mce-&#39;) !== -1;
};
var FocusManager = { isEditorUIElement: isEditorUIElement };

var isManualNodeChange = function (e) {
  return e.type === &#39;nodechange&#39; &amp;&amp; e.selectionChange;
};
var registerPageMouseUp = function (editor, throttledStore) {
  var mouseUpPage = function () {
    throttledStore.throttle();
  };
  DOMUtils$1.DOM.bind(document, &#39;mouseup&#39;, mouseUpPage);
  editor.on(&#39;remove&#39;, function () {
    DOMUtils$1.DOM.unbind(document, &#39;mouseup&#39;, mouseUpPage);
  });
};
var registerFocusOut = function (editor) {
  editor.on(&#39;focusout&#39;, function () {
    SelectionBookmark.store(editor);
  });
};
var registerMouseUp = function (editor, throttledStore) {
  editor.on(&#39;mouseup touchend&#39;, function (e) {
    throttledStore.throttle();
  });
};
var registerEditorEvents = function (editor, throttledStore) {
  var browser = PlatformDetection$1.detect().browser;
  if (browser.isIE()) {
    registerFocusOut(editor);
  } else {
    registerMouseUp(editor, throttledStore);
  }
  editor.on(&#39;keyup nodechange&#39;, function (e) {
    if (!isManualNodeChange(e)) {
      SelectionBookmark.store(editor);
    }
  });
};
var register$3 = function (editor) {
  var throttledStore = first$1(function () {
    SelectionBookmark.store(editor);
  }, 0);
  if (editor.inline) {
    registerPageMouseUp(editor, throttledStore);
  }
  editor.on(&#39;init&#39;, function () {
    registerEditorEvents(editor, throttledStore);
  });
  editor.on(&#39;remove&#39;, function () {
    throttledStore.cancel();
  });
};
var SelectionRestore = { register: register$3 };

var documentFocusInHandler;
var DOM$8 = DOMUtils$1.DOM;
var isEditorUIElement$1 = function (elm) {
  return FocusManager.isEditorUIElement(elm);
};
var isUIElement = function (editor, elm) {
  var customSelector = editor ? editor.settings.custom_ui_selector : &#39;&#39;;
  var parent$$1 = DOM$8.getParent(elm, function (elm) {
    return isEditorUIElement$1(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);
  });
  return parent$$1 !== null;
};
var getActiveElement = function () {
  try {
    return document.activeElement;
  } catch (ex) {
    return document.body;
  }
};
var registerEvents = function (editorManager, e) {
  var editor = e.editor;
  SelectionRestore.register(editor);
  editor.on(&#39;focusin&#39;, function () {
    var self$$1 = this;
    var focusedEditor = editorManager.focusedEditor;
    if (focusedEditor !== self$$1) {
      if (focusedEditor) {
        focusedEditor.fire(&#39;blur&#39;, { focusedEditor: self$$1 });
      }
      editorManager.setActive(self$$1);
      editorManager.focusedEditor = self$$1;
      self$$1.fire(&#39;focus&#39;, { blurredEditor: focusedEditor });
      self$$1.focus(true);
    }
  });
  editor.on(&#39;focusout&#39;, function () {
    var self$$1 = this;
    Delay.setEditorTimeout(self$$1, function () {
      var focusedEditor = editorManager.focusedEditor;
      if (!isUIElement(self$$1, getActiveElement()) &amp;&amp; focusedEditor === self$$1) {
        self$$1.fire(&#39;blur&#39;, { focusedEditor: null });
        editorManager.focusedEditor = null;
      }
    });
  });
  if (!documentFocusInHandler) {
    documentFocusInHandler = function (e) {
      var activeEditor = editorManager.activeEditor;
      var target;
      target = e.target;
      if (activeEditor &amp;&amp; target.ownerDocument === document) {
        if (target !== document.body &amp;&amp; !isUIElement(activeEditor, target) &amp;&amp; editorManager.focusedEditor === activeEditor) {
          activeEditor.fire(&#39;blur&#39;, { focusedEditor: null });
          editorManager.focusedEditor = null;
        }
      }
    };
    DOM$8.bind(document, &#39;focusin&#39;, documentFocusInHandler);
  }
};
var unregisterDocumentEvents = function (editorManager, e) {
  if (editorManager.focusedEditor === e.editor) {
    editorManager.focusedEditor = null;
  }
  if (!editorManager.activeEditor) {
    DOM$8.unbind(document, &#39;focusin&#39;, documentFocusInHandler);
    documentFocusInHandler = null;
  }
};
var setup$g = function (editorManager) {
  editorManager.on(&#39;AddEditor&#39;, curry(registerEvents, editorManager));
  editorManager.on(&#39;RemoveEditor&#39;, curry(unregisterDocumentEvents, editorManager));
};
var FocusController = {
  setup: setup$g,
  isEditorUIElement: isEditorUIElement$1,
  isUIElement: isUIElement
};

var data = {};
var code = &#39;en&#39;;
var I18n = {
  setCode: function (newCode) {
    if (newCode) {
      code = newCode;
      this.rtl = this.data[newCode] ? this.data[newCode]._dir === &#39;rtl&#39; : false;
    }
  },
  getCode: function () {
    return code;
  },
  rtl: false,
  add: function (code, items) {
    var langData = data[code];
    if (!langData) {
      data[code] = langData = {};
    }
    for (var name in items) {
      langData[name] = items[name];
    }
    this.setCode(code);
  },
  translate: function (text) {
    var langData = data[code] || {};
    var toString = function (obj) {
      if (Tools.is(obj, &#39;function&#39;)) {
        return Object.prototype.toString.call(obj);
      }
      return !isEmpty(obj) ? &#39;&#39; + obj : &#39;&#39;;
    };
    var isEmpty = function (text) {
      return text === &#39;&#39; || text === null || Tools.is(text, &#39;undefined&#39;);
    };
    var getLangData = function (text) {
      text = toString(text);
      return Tools.hasOwn(langData, text) ? toString(langData[text]) : text;
    };
    if (isEmpty(text)) {
      return &#39;&#39;;
    }
    if (Tools.is(text, &#39;object&#39;) &amp;&amp; Tools.hasOwn(text, &#39;raw&#39;)) {
      return toString(text.raw);
    }
    if (Tools.is(text, &#39;array&#39;)) {
      var values_1 = text.slice(1);
      text = getLangData(text[0]).replace(/\{([0-9]+)\}/g, function ($1, $2) {
        return Tools.hasOwn(values_1, $2) ? toString(values_1[$2]) : $1;
      });
    }
    return getLangData(text).replace(/{context:\w+}$/, &#39;&#39;);
  },
  data: data
};

var DOM$9 = DOMUtils$1.DOM;
var explode$4 = Tools.explode, each$m = Tools.each, extend$5 = Tools.extend;
var instanceCounter = 0, beforeUnloadDelegate, EditorManager, boundGlobalEvents = false;
var legacyEditors = [];
var editors = [];
var isValidLegacyKey = function (id) {
  return id !== &#39;length&#39;;
};
var globalEventDelegate = function (e) {
  each$m(EditorManager.get(), function (editor) {
    if (e.type === &#39;scroll&#39;) {
      editor.fire(&#39;ScrollWindow&#39;, e);
    } else {
      editor.fire(&#39;ResizeWindow&#39;, e);
    }
  });
};
var toggleGlobalEvents = function (state) {
  if (state !== boundGlobalEvents) {
    if (state) {
      DomQuery(window).on(&#39;resize scroll&#39;, globalEventDelegate);
    } else {
      DomQuery(window).off(&#39;resize scroll&#39;, globalEventDelegate);
    }
    boundGlobalEvents = state;
  }
};
var removeEditorFromList = function (targetEditor) {
  var oldEditors = editors;
  delete legacyEditors[targetEditor.id];
  for (var i = 0; i &lt; legacyEditors.length; i++) {
    if (legacyEditors[i] === targetEditor) {
      legacyEditors.splice(i, 1);
      break;
    }
  }
  editors = filter(editors, function (editor) {
    return targetEditor !== editor;
  });
  if (EditorManager.activeEditor === targetEditor) {
    EditorManager.activeEditor = editors.length &gt; 0 ? editors[0] : null;
  }
  if (EditorManager.focusedEditor === targetEditor) {
    EditorManager.focusedEditor = null;
  }
  return oldEditors.length !== editors.length;
};
var purgeDestroyedEditor = function (editor) {
  if (editor &amp;&amp; editor.initialized &amp;&amp; !(editor.getContainer() || editor.getBody()).parentNode) {
    removeEditorFromList(editor);
    editor.unbindAllNativeEvents();
    editor.destroy(true);
    editor.removed = true;
    editor = null;
  }
  return editor;
};
EditorManager = {
  defaultSettings: {},
  $: DomQuery,
  majorVersion: &#39;4&#39;,
  minorVersion: &#39;9.0&#39;,
  releaseDate: &#39;2018-11-27&#39;,
  editors: legacyEditors,
  i18n: I18n,
  activeEditor: null,
  settings: {},
  setup: function () {
    var self$$1 = this;
    var baseURL, documentBaseURL, suffix = &#39;&#39;, preInit, src;
    documentBaseURL = URI.getDocumentBaseUrl(document.location);
    if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
      documentBaseURL = documentBaseURL.replace(/[\?#].*$/, &#39;&#39;).replace(/[\/\\][^\/]+$/, &#39;&#39;);
      if (!/[\/\\]$/.test(documentBaseURL)) {
        documentBaseURL += &#39;/&#39;;
      }
    }
    preInit = window.tinymce || window.tinyMCEPreInit;
    if (preInit) {
      baseURL = preInit.base || preInit.baseURL;
      suffix = preInit.suffix;
    } else {
      var scripts = document.getElementsByTagName(&#39;script&#39;);
      for (var i = 0; i &lt; scripts.length; i++) {
        src = scripts[i].src;
        var srcScript = src.substring(src.lastIndexOf(&#39;/&#39;));
        if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
          if (srcScript.indexOf(&#39;.min&#39;) !== -1) {
            suffix = &#39;.min&#39;;
          }
          baseURL = src.substring(0, src.lastIndexOf(&#39;/&#39;));
          break;
        }
      }
      if (!baseURL &amp;&amp; document.currentScript) {
        src = document.currentScript.src;
        if (src.indexOf(&#39;.min&#39;) !== -1) {
          suffix = &#39;.min&#39;;
        }
        baseURL = src.substring(0, src.lastIndexOf(&#39;/&#39;));
      }
    }
    self$$1.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
    self$$1.documentBaseURL = documentBaseURL;
    self$$1.baseURI = new URI(self$$1.baseURL);
    self$$1.suffix = suffix;
    FocusController.setup(self$$1);
  },
  overrideDefaults: function (defaultSettings) {
    var baseUrl, suffix;
    baseUrl = defaultSettings.base_url;
    if (baseUrl) {
      this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, &#39;&#39;));
      this.baseURI = new URI(this.baseURL);
    }
    suffix = defaultSettings.suffix;
    if (defaultSettings.suffix) {
      this.suffix = suffix;
    }
    this.defaultSettings = defaultSettings;
    var pluginBaseUrls = defaultSettings.plugin_base_urls;
    for (var name$$1 in pluginBaseUrls) {
      AddOnManager.PluginManager.urls[name$$1] = pluginBaseUrls[name$$1];
    }
  },
  init: function (settings) {
    var self$$1 = this;
    var result, invalidInlineTargets;
    invalidInlineTargets = Tools.makeMap(&#39;area bitters basefont br col frame hr img input isindex link meta param embed source wbr track &#39; + &#39;colgroup option tbody tfoot thead tr script noscript style textarea video audio iframe object menu&#39;, &#39; &#39;);
    var isInvalidInlineTarget = function (settings, elm) {
      return settings.inline &amp;&amp; elm.tagName.toLowerCase() in invalidInlineTargets;
    };
    var createId = function (elm) {
      var id = elm.id;
      if (!id) {
        id = elm.name;
        if (id &amp;&amp; !DOM$9.get(id)) {
          id = elm.name;
        } else {
          id = DOM$9.uniqueId();
        }
        elm.setAttribute(&#39;id&#39;, id);
      }
      return id;
    };
    var execCallback = function (name$$1) {
      var callback = settings[name$$1];
      if (!callback) {
        return;
      }
      return callback.apply(self$$1, Array.prototype.slice.call(arguments, 2));
    };
    var hasClass = function (elm, className) {
      return className.constructor === RegExp ? className.test(elm.className) : DOM$9.hasClass(elm, className);
    };
    var findTargets = function (settings) {
      var l, targets = [];
      if (Env.ie &amp;&amp; Env.ie &lt; 11) {
        ErrorReporter.initError(&#39;TinyMCE does not support the browser you are using. For a list of supported&#39; + &#39; browsers please see: https://www.tinymce.com/docs/get-started/system-requirements/&#39;);
        return [];
      }
      if (settings.types) {
        each$m(settings.types, function (type) {
          targets = targets.concat(DOM$9.select(type.selector));
        });
        return targets;
      } else if (settings.selector) {
        return DOM$9.select(settings.selector);
      } else if (settings.target) {
        return [settings.target];
      }
      switch (settings.mode) {
      case &#39;exact&#39;:
        l = settings.elements || &#39;&#39;;
        if (l.length &gt; 0) {
          each$m(explode$4(l), function (id) {
            var elm;
            if (elm = DOM$9.get(id)) {
              targets.push(elm);
            } else {
              each$m(document.forms, function (f) {
                each$m(f.elements, function (e) {
                  if (e.name === id) {
                    id = &#39;mce_editor_&#39; + instanceCounter++;
                    DOM$9.setAttrib(e, &#39;id&#39;, id);
                    targets.push(e);
                  }
                });
              });
            }
          });
        }
        break;
      case &#39;textareas&#39;:
      case &#39;specific_textareas&#39;:
        each$m(DOM$9.select(&#39;textarea&#39;), function (elm) {
          if (settings.editor_deselector &amp;&amp; hasClass(elm, settings.editor_deselector)) {
            return;
          }
          if (!settings.editor_selector || hasClass(elm, settings.editor_selector)) {
            targets.push(elm);
          }
        });
        break;
      }
      return targets;
    };
    var provideResults = function (editors) {
      result = editors;
    };
    var initEditors = function () {
      var initCount = 0;
      var editors = [];
      var targets;
      var createEditor = function (id, settings, targetElm) {
        var editor = new Editor(id, settings, self$$1);
        editors.push(editor);
        editor.on(&#39;init&#39;, function () {
          if (++initCount === targets.length) {
            provideResults(editors);
          }
        });
        editor.targetElm = editor.targetElm || targetElm;
        editor.render();
      };
      DOM$9.unbind(window, &#39;ready&#39;, initEditors);
      execCallback(&#39;onpageload&#39;);
      targets = DomQuery.unique(findTargets(settings));
      if (settings.types) {
        each$m(settings.types, function (type) {
          Tools.each(targets, function (elm) {
            if (DOM$9.is(elm, type.selector)) {
              createEditor(createId(elm), extend$5({}, settings, type), elm);
              return false;
            }
            return true;
          });
        });
        return;
      }
      Tools.each(targets, function (elm) {
        purgeDestroyedEditor(self$$1.get(elm.id));
      });
      targets = Tools.grep(targets, function (elm) {
        return !self$$1.get(elm.id);
      });
      if (targets.length === 0) {
        provideResults([]);
      } else {
        each$m(targets, function (elm) {
          if (isInvalidInlineTarget(settings, elm)) {
            ErrorReporter.initError(&#39;Could not initialize inline editor on invalid inline target element&#39;, elm);
          } else {
            createEditor(createId(elm), settings, elm);
          }
        });
      }
    };
    self$$1.settings = settings;
    DOM$9.bind(window, &#39;ready&#39;, initEditors);
    return new promiseObj(function (resolve) {
      if (result) {
        resolve(result);
      } else {
        provideResults = function (editors) {
          resolve(editors);
        };
      }
    });
  },
  get: function (id) {
    if (arguments.length === 0) {
      return editors.slice(0);
    } else if (isString(id)) {
      return find(editors, function (editor) {
        return editor.id === id;
      }).getOr(null);
    } else if (isNumber(id)) {
      return editors[id] ? editors[id] : null;
    } else {
      return null;
    }
  },
  add: function (editor) {
    var self$$1 = this;
    var existingEditor;
    existingEditor = legacyEditors[editor.id];
    if (existingEditor === editor) {
      return editor;
    }
    if (self$$1.get(editor.id) === null) {
      if (isValidLegacyKey(editor.id)) {
        legacyEditors[editor.id] = editor;
      }
      legacyEditors.push(editor);
      editors.push(editor);
    }
    toggleGlobalEvents(true);
    self$$1.activeEditor = editor;
    self$$1.fire(&#39;AddEditor&#39;, { editor: editor });
    if (!beforeUnloadDelegate) {
      beforeUnloadDelegate = function () {
        self$$1.fire(&#39;BeforeUnload&#39;);
      };
      DOM$9.bind(window, &#39;beforeunload&#39;, beforeUnloadDelegate);
    }
    return editor;
  },
  createEditor: function (id, settings) {
    return this.add(new Editor(id, settings, this));
  },
  remove: function (selector) {
    var self$$1 = this;
    var i, editor;
    if (!selector) {
      for (i = editors.length - 1; i &gt;= 0; i--) {
        self$$1.remove(editors[i]);
      }
      return;
    }
    if (isString(selector)) {
      each$m(DOM$9.select(selector), function (elm) {
        editor = self$$1.get(elm.id);
        if (editor) {
          self$$1.remove(editor);
        }
      });
      return;
    }
    editor = selector;
    if (isNull(self$$1.get(editor.id))) {
      return null;
    }
    if (removeEditorFromList(editor)) {
      self$$1.fire(&#39;RemoveEditor&#39;, { editor: editor });
    }
    if (editors.length === 0) {
      DOM$9.unbind(window, &#39;beforeunload&#39;, beforeUnloadDelegate);
    }
    editor.remove();
    toggleGlobalEvents(editors.length &gt; 0);
    return editor;
  },
  execCommand: function (cmd, ui, value) {
    var self$$1 = this, editor = self$$1.get(value);
    switch (cmd) {
    case &#39;mceAddEditor&#39;:
      if (!self$$1.get(value)) {
        new Editor(value, self$$1.settings, self$$1).render();
      }
      return true;
    case &#39;mceRemoveEditor&#39;:
      if (editor) {
        editor.remove();
      }
      return true;
    case &#39;mceToggleEditor&#39;:
      if (!editor) {
        self$$1.execCommand(&#39;mceAddEditor&#39;, 0, value);
        return true;
      }
      if (editor.isHidden()) {
        editor.show();
      } else {
        editor.hide();
      }
      return true;
    }
    if (self$$1.activeEditor) {
      return self$$1.activeEditor.execCommand(cmd, ui, value);
    }
    return false;
  },
  triggerSave: function () {
    each$m(editors, function (editor) {
      editor.save();
    });
  },
  addI18n: function (code, items) {
    I18n.add(code, items);
  },
  translate: function (text) {
    return I18n.translate(text);
  },
  setActive: function (editor) {
    var activeEditor = this.activeEditor;
    if (this.activeEditor !== editor) {
      if (activeEditor) {
        activeEditor.fire(&#39;deactivate&#39;, { relatedTarget: editor });
      }
      editor.fire(&#39;activate&#39;, { relatedTarget: activeEditor });
    }
    this.activeEditor = editor;
  }
};
extend$5(EditorManager, Observable);
EditorManager.setup();
var EditorManager$1 = EditorManager;

function RangeUtils(dom) {
  var walk = function (rng, callback) {
    return RangeWalk.walk(dom, rng, callback);
  };
  var split = SplitRange.split;
  var normalize = function (rng) {
    return NormalizeRange.normalize(dom, rng).fold(constant(false), function (normalizedRng) {
      rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
      rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
      return true;
    });
  };
  return {
    walk: walk,
    split: split,
    normalize: normalize
  };
}
(function (RangeUtils) {
  RangeUtils.compareRanges = RangeCompare.isEq;
  RangeUtils.getCaretRangeFromPoint = CaretRangeFromPoint.fromPoint;
  RangeUtils.getSelectedNode = getSelectedNode;
  RangeUtils.getNode = getNode;
}(RangeUtils || (RangeUtils = {})));
var RangeUtils$1 = RangeUtils;

var min = Math.min, max = Math.max, round$2 = Math.round;
var relativePosition = function (rect, targetRect, rel) {
  var x, y, w, h, targetW, targetH;
  x = targetRect.x;
  y = targetRect.y;
  w = rect.w;
  h = rect.h;
  targetW = targetRect.w;
  targetH = targetRect.h;
  rel = (rel || &#39;&#39;).split(&#39;&#39;);
  if (rel[0] === &#39;b&#39;) {
    y += targetH;
  }
  if (rel[1] === &#39;r&#39;) {
    x += targetW;
  }
  if (rel[0] === &#39;c&#39;) {
    y += round$2(targetH / 2);
  }
  if (rel[1] === &#39;c&#39;) {
    x += round$2(targetW / 2);
  }
  if (rel[3] === &#39;b&#39;) {
    y -= h;
  }
  if (rel[4] === &#39;r&#39;) {
    x -= w;
  }
  if (rel[3] === &#39;c&#39;) {
    y -= round$2(h / 2);
  }
  if (rel[4] === &#39;c&#39;) {
    x -= round$2(w / 2);
  }
  return create$3(x, y, w, h);
};
var findBestRelativePosition = function (rect, targetRect, constrainRect, rels) {
  var pos, i;
  for (i = 0; i &lt; rels.length; i++) {
    pos = relativePosition(rect, targetRect, rels[i]);
    if (pos.x &gt;= constrainRect.x &amp;&amp; pos.x + pos.w &lt;= constrainRect.w + constrainRect.x &amp;&amp; pos.y &gt;= constrainRect.y &amp;&amp; pos.y + pos.h &lt;= constrainRect.h + constrainRect.y) {
      return rels[i];
    }
  }
  return null;
};
var inflate = function (rect, w, h) {
  return create$3(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
};
var intersect = function (rect, cropRect) {
  var x1, y1, x2, y2;
  x1 = max(rect.x, cropRect.x);
  y1 = max(rect.y, cropRect.y);
  x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);
  y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);
  if (x2 - x1 &lt; 0 || y2 - y1 &lt; 0) {
    return null;
  }
  return create$3(x1, y1, x2 - x1, y2 - y1);
};
var clamp$1 = function (rect, clampRect, fixedSize) {
  var underflowX1, underflowY1, overflowX2, overflowY2, x1, y1, x2, y2, cx2, cy2;
  x1 = rect.x;
  y1 = rect.y;
  x2 = rect.x + rect.w;
  y2 = rect.y + rect.h;
  cx2 = clampRect.x + clampRect.w;
  cy2 = clampRect.y + clampRect.h;
  underflowX1 = max(0, clampRect.x - x1);
  underflowY1 = max(0, clampRect.y - y1);
  overflowX2 = max(0, x2 - cx2);
  overflowY2 = max(0, y2 - cy2);
  x1 += underflowX1;
  y1 += underflowY1;
  if (fixedSize) {
    x2 += underflowX1;
    y2 += underflowY1;
    x1 -= overflowX2;
    y1 -= overflowY2;
  }
  x2 -= overflowX2;
  y2 -= overflowY2;
  return create$3(x1, y1, x2 - x1, y2 - y1);
};
var create$3 = function (x, y, w, h) {
  return {
    x: x,
    y: y,
    w: w,
    h: h
  };
};
var fromClientRect = function (clientRect) {
  return create$3(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
};
var Rect = {
  inflate: inflate,
  relativePosition: relativePosition,
  findBestRelativePosition: findBestRelativePosition,
  intersect: intersect,
  clamp: clamp$1,
  create: create$3,
  fromClientRect: fromClientRect
};

var types = {};
var Factory = {
  add: function (type, typeClass) {
    types[type.toLowerCase()] = typeClass;
  },
  has: function (type) {
    return !!types[type.toLowerCase()];
  },
  get: function (type) {
    var lctype = type.toLowerCase();
    var controlType = types.hasOwnProperty(lctype) ? types[lctype] : null;
    if (controlType === null) {
      throw new Error(&#39;Could not find module for type: &#39; + type);
    }
    return controlType;
  },
  create: function (type, settings) {
    var ControlType;
    if (typeof type === &#39;string&#39;) {
      settings = settings || {};
      settings.type = type;
    } else {
      settings = type;
      type = settings.type;
    }
    type = type.toLowerCase();
    ControlType = types[type];
    if (!ControlType) {
      throw new Error(&#39;Could not find control by type: &#39; + type);
    }
    ControlType = new ControlType(settings);
    ControlType.type = type;
    return ControlType;
  }
};

var each$n = Tools.each, extend$6 = Tools.extend;
var extendClass, initializing;
var Class = function () {
};
Class.extend = extendClass = function (prop) {
  var self = this;
  var _super = self.prototype;
  var prototype, name, member;
  var Class = function () {
    var i, mixins, mixin;
    var self = this;
    if (!initializing) {
      if (self.init) {
        self.init.apply(self, arguments);
      }
      mixins = self.Mixins;
      if (mixins) {
        i = mixins.length;
        while (i--) {
          mixin = mixins[i];
          if (mixin.init) {
            mixin.init.apply(self, arguments);
          }
        }
      }
    }
  };
  var dummy = function () {
    return this;
  };
  var createMethod = function (name, fn) {
    return function () {
      var self = this;
      var tmp = self._super;
      var ret;
      self._super = _super[name];
      ret = fn.apply(self, arguments);
      self._super = tmp;
      return ret;
    };
  };
  initializing = true;
  prototype = new self();
  initializing = false;
  if (prop.Mixins) {
    each$n(prop.Mixins, function (mixin) {
      for (var name_1 in mixin) {
        if (name_1 !== &#39;init&#39;) {
          prop[name_1] = mixin[name_1];
        }
      }
    });
    if (_super.Mixins) {
      prop.Mixins = _super.Mixins.concat(prop.Mixins);
    }
  }
  if (prop.Methods) {
    each$n(prop.Methods.split(&#39;,&#39;), function (name) {
      prop[name] = dummy;
    });
  }
  if (prop.Properties) {
    each$n(prop.Properties.split(&#39;,&#39;), function (name) {
      var fieldName = &#39;_&#39; + name;
      prop[name] = function (value) {
        var self = this;
        if (value !== undefined) {
          self[fieldName] = value;
          return self;
        }
        return self[fieldName];
      };
    });
  }
  if (prop.Statics) {
    each$n(prop.Statics, function (func, name) {
      Class[name] = func;
    });
  }
  if (prop.Defaults &amp;&amp; _super.Defaults) {
    prop.Defaults = extend$6({}, _super.Defaults, prop.Defaults);
  }
  for (name in prop) {
    member = prop[name];
    if (typeof member === &#39;function&#39; &amp;&amp; _super[name]) {
      prototype[name] = createMethod(name, member);
    } else {
      prototype[name] = member;
    }
  }
  Class.prototype = prototype;
  Class.constructor = Class;
  Class.extend = extendClass;
  return Class;
};

var min$1 = Math.min, max$1 = Math.max, round$3 = Math.round;
var Color = function (value) {
  var self = {};
  var r = 0, g = 0, b = 0;
  var rgb2hsv = function (r, g, b) {
    var h, s, v, d, minRGB, maxRGB;
    h = 0;
    s = 0;
    v = 0;
    r = r / 255;
    g = g / 255;
    b = b / 255;
    minRGB = min$1(r, min$1(g, b));
    maxRGB = max$1(r, max$1(g, b));
    if (minRGB === maxRGB) {
      v = minRGB;
      return {
        h: 0,
        s: 0,
        v: v * 100
      };
    }
    d = r === minRGB ? g - b : b === minRGB ? r - g : b - r;
    h = r === minRGB ? 3 : b === minRGB ? 1 : 5;
    h = 60 * (h - d / (maxRGB - minRGB));
    s = (maxRGB - minRGB) / maxRGB;
    v = maxRGB;
    return {
      h: round$3(h),
      s: round$3(s * 100),
      v: round$3(v * 100)
    };
  };
  var hsvToRgb = function (hue, saturation, brightness) {
    var side, chroma, x, match;
    hue = (parseInt(hue, 10) || 0) % 360;
    saturation = parseInt(saturation, 10) / 100;
    brightness = parseInt(brightness, 10) / 100;
    saturation = max$1(0, min$1(saturation, 1));
    brightness = max$1(0, min$1(brightness, 1));
    if (saturation === 0) {
      r = g = b = round$3(255 * brightness);
      return;
    }
    side = hue / 60;
    chroma = brightness * saturation;
    x = chroma * (1 - Math.abs(side % 2 - 1));
    match = brightness - chroma;
    switch (Math.floor(side)) {
    case 0:
      r = chroma;
      g = x;
      b = 0;
      break;
    case 1:
      r = x;
      g = chroma;
      b = 0;
      break;
    case 2:
      r = 0;
      g = chroma;
      b = x;
      break;
    case 3:
      r = 0;
      g = x;
      b = chroma;
      break;
    case 4:
      r = x;
      g = 0;
      b = chroma;
      break;
    case 5:
      r = chroma;
      g = 0;
      b = x;
      break;
    default:
      r = g = b = 0;
    }
    r = round$3(255 * (r + match));
    g = round$3(255 * (g + match));
    b = round$3(255 * (b + match));
  };
  var toHex = function () {
    var hex = function (val) {
      val = parseInt(val, 10).toString(16);
      return val.length &gt; 1 ? val : &#39;0&#39; + val;
    };
    return &#39;#&#39; + hex(r) + hex(g) + hex(b);
  };
  var toRgb = function () {
    return {
      r: r,
      g: g,
      b: b
    };
  };
  var toHsv = function () {
    return rgb2hsv(r, g, b);
  };
  var parse = function (value) {
    var matches;
    if (typeof value === &#39;object&#39;) {
      if (&#39;r&#39; in value) {
        r = value.r;
        g = value.g;
        b = value.b;
      } else if (&#39;v&#39; in value) {
        hsvToRgb(value.h, value.s, value.v);
      }
    } else {
      if (matches = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)[^\)]*\)/gi.exec(value)) {
        r = parseInt(matches[1], 10);
        g = parseInt(matches[2], 10);
        b = parseInt(matches[3], 10);
      } else if (matches = /#([0-F]{2})([0-F]{2})([0-F]{2})/gi.exec(value)) {
        r = parseInt(matches[1], 16);
        g = parseInt(matches[2], 16);
        b = parseInt(matches[3], 16);
      } else if (matches = /#([0-F])([0-F])([0-F])/gi.exec(value)) {
        r = parseInt(matches[1] + matches[1], 16);
        g = parseInt(matches[2] + matches[2], 16);
        b = parseInt(matches[3] + matches[3], 16);
      }
    }
    r = r &lt; 0 ? 0 : r &gt; 255 ? 255 : r;
    g = g &lt; 0 ? 0 : g &gt; 255 ? 255 : g;
    b = b &lt; 0 ? 0 : b &gt; 255 ? 255 : b;
    return self;
  };
  if (value) {
    parse(value);
  }
  self.toRgb = toRgb;
  self.toHsv = toHsv;
  self.toHex = toHex;
  self.parse = parse;
  return self;
};

var serialize = function (o, quote) {
  var i, v, t, name;
  quote = quote || &#39;&quot;&#39;;
  if (o === null) {
    return &#39;null&#39;;
  }
  t = typeof o;
  if (t === &#39;string&#39;) {
    v = &#39;\bb\tt\nn\ff\rr&quot;&quot;\&#39;\&#39;\\\\&#39;;
    return quote + o.replace(/([\u0080-\uFFFF\x00-\x1f\&quot;\&#39;\\])/g, function (a, b) {
      if (quote === &#39;&quot;&#39; &amp;&amp; a === &#39;\&#39;&#39;) {
        return a;
      }
      i = v.indexOf(b);
      if (i + 1) {
        return &#39;\\&#39; + v.charAt(i + 1);
      }
      a = b.charCodeAt().toString(16);
      return &#39;\\u&#39; + &#39;0000&#39;.substring(a.length) + a;
    }) + quote;
  }
  if (t === &#39;object&#39;) {
    if (o.hasOwnProperty &amp;&amp; Object.prototype.toString.call(o) === &#39;[object Array]&#39;) {
      for (i = 0, v = &#39;[&#39;; i &lt; o.length; i++) {
        v += (i &gt; 0 ? &#39;,&#39; : &#39;&#39;) + serialize(o[i], quote);
      }
      return v + &#39;]&#39;;
    }
    v = &#39;{&#39;;
    for (name in o) {
      if (o.hasOwnProperty(name)) {
        v += typeof o[name] !== &#39;function&#39; ? (v.length &gt; 1 ? &#39;,&#39; + quote : quote) + name + quote + &#39;:&#39; + serialize(o[name], quote) : &#39;&#39;;
      }
    }
    return v + &#39;}&#39;;
  }
  return &#39;&#39; + o;
};
var JSON$1 = {
  serialize: serialize,
  parse: function (text) {
    try {
      return JSON.parse(text);
    } catch (ex) {
    }
  }
};

var JSONP = {
  callbacks: {},
  count: 0,
  send: function (settings) {
    var self = this, dom = DOMUtils$1.DOM, count = settings.count !== undefined ? settings.count : self.count;
    var id = &#39;tinymce_jsonp_&#39; + count;
    self.callbacks[count] = function (json) {
      dom.remove(id);
      delete self.callbacks[count];
      settings.callback(json);
    };
    dom.add(dom.doc.body, &#39;script&#39;, {
      id: id,
      src: settings.url,
      type: &#39;text/javascript&#39;
    });
    self.count++;
  }
};

var XHR = {
  send: function (settings) {
    var xhr, count = 0;
    var ready = function () {
      if (!settings.async || xhr.readyState === 4 || count++ &gt; 10000) {
        if (settings.success &amp;&amp; count &lt; 10000 &amp;&amp; xhr.status === 200) {
          settings.success.call(settings.success_scope, &#39;&#39; + xhr.responseText, xhr, settings);
        } else if (settings.error) {
          settings.error.call(settings.error_scope, count &gt; 10000 ? &#39;TIMED_OUT&#39; : &#39;GENERAL&#39;, xhr, settings);
        }
        xhr = null;
      } else {
        setTimeout(ready, 10);
      }
    };
    settings.scope = settings.scope || this;
    settings.success_scope = settings.success_scope || settings.scope;
    settings.error_scope = settings.error_scope || settings.scope;
    settings.async = settings.async === false ? false : true;
    settings.data = settings.data || &#39;&#39;;
    XHR.fire(&#39;beforeInitialize&#39;, { settings: settings });
    xhr = XMLHttpRequest();
    if (xhr) {
      if (xhr.overrideMimeType) {
        xhr.overrideMimeType(settings.content_type);
      }
      xhr.open(settings.type || (settings.data ? &#39;POST&#39; : &#39;GET&#39;), settings.url, settings.async);
      if (settings.crossDomain) {
        xhr.withCredentials = true;
      }
      if (settings.content_type) {
        xhr.setRequestHeader(&#39;Content-Type&#39;, settings.content_type);
      }
      if (settings.requestheaders) {
        Tools.each(settings.requestheaders, function (header) {
          xhr.setRequestHeader(header.key, header.value);
        });
      }
      xhr.setRequestHeader(&#39;X-Requested-With&#39;, &#39;XMLHttpRequest&#39;);
      xhr = XHR.fire(&#39;beforeSend&#39;, {
        xhr: xhr,
        settings: settings
      }).xhr;
      xhr.send(settings.data);
      if (!settings.async) {
        return ready();
      }
      setTimeout(ready, 10);
    }
  }
};
Tools.extend(XHR, Observable);

var extend$7 = Tools.extend;
var JSONRequest = function (settings) {
  this.settings = extend$7({}, settings);
  this.count = 0;
};
JSONRequest.sendRPC = function (o) {
  return new JSONRequest().send(o);
};
JSONRequest.prototype = {
  send: function (args) {
    var ecb = args.error, scb = args.success;
    args = extend$7(this.settings, args);
    args.success = function (c, x) {
      c = JSON$1.parse(c);
      if (typeof c === &#39;undefined&#39;) {
        c = { error: &#39;JSON Parse error.&#39; };
      }
      if (c.error) {
        ecb.call(args.error_scope || args.scope, c.error, x);
      } else {
        scb.call(args.success_scope || args.scope, c.result);
      }
    };
    args.error = function (ty, x) {
      if (ecb) {
        ecb.call(args.error_scope || args.scope, ty, x);
      }
    };
    args.data = JSON$1.serialize({
      id: args.id || &#39;c&#39; + this.count++,
      method: args.method,
      params: args.params
    });
    args.content_type = &#39;application/json&#39;;
    XHR.send(args);
  }
};

var create$4 = function () {
  return function () {
    var data = {};
    var keys = [];
    var storage = {
      getItem: function (key) {
        var item = data[key];
        return item ? item : null;
      },
      setItem: function (key, value) {
        keys.push(key);
        data[key] = String(value);
      },
      key: function (index) {
        return keys[index];
      },
      removeItem: function (key) {
        keys = keys.filter(function (k) {
          return k === key;
        });
        delete data[key];
      },
      clear: function () {
        keys = [];
        data = {};
      },
      length: 0
    };
    Object.defineProperty(storage, &#39;length&#39;, {
      get: function () {
        return keys.length;
      },
      configurable: false,
      enumerable: false
    });
    return storage;
  }();
};

var localStorage$$1;
try {
  localStorage$$1 = window.localStorage;
} catch (e) {
  localStorage$$1 = create$4();
}
var LocalStorage = localStorage$$1;

var tinymce = EditorManager$1;
var publicApi = {
  geom: { Rect: Rect },
  util: {
    Promise: promiseObj,
    Delay: Delay,
    Tools: Tools,
    VK: VK,
    URI: URI,
    Class: Class,
    EventDispatcher: Dispatcher,
    Observable: Observable,
    I18n: I18n,
    XHR: XHR,
    JSON: JSON$1,
    JSONRequest: JSONRequest,
    JSONP: JSONP,
    LocalStorage: LocalStorage,
    Color: Color
  },
  dom: {
    EventUtils: EventUtils,
    Sizzle: Sizzle,
    DomQuery: DomQuery,
    TreeWalker: TreeWalker,
    DOMUtils: DOMUtils$1,
    ScriptLoader: ScriptLoader,
    RangeUtils: RangeUtils$1,
    Serializer: Serializer$1,
    ControlSelection: ControlSelection,
    BookmarkManager: BookmarkManager$1,
    Selection: Selection,
    Event: EventUtils.Event
  },
  html: {
    Styles: Styles,
    Entities: Entities,
    Node: Node$2,
    Schema: Schema,
    SaxParser: SaxParser$1,
    DomParser: DomParser,
    Writer: Writer,
    Serializer: Serializer
  },
  ui: { Factory: Factory },
  Env: Env,
  AddOnManager: AddOnManager,
  Annotator: Annotator,
  Formatter: Formatter,
  UndoManager: UndoManager,
  EditorCommands: EditorCommands,
  WindowManager: WindowManager,
  NotificationManager: NotificationManager,
  EditorObservable: EditorObservable$1,
  Shortcuts: Shortcuts,
  Editor: Editor,
  FocusManager: FocusManager,
  EditorManager: EditorManager$1,
  DOM: DOMUtils$1.DOM,
  ScriptLoader: ScriptLoader.ScriptLoader,
  PluginManager: AddOnManager.PluginManager,
  ThemeManager: AddOnManager.ThemeManager,
  trim: Tools.trim,
  isArray: Tools.isArray,
  is: Tools.is,
  toArray: Tools.toArray,
  makeMap: Tools.makeMap,
  each: Tools.each,
  map: Tools.map,
  grep: Tools.grep,
  inArray: Tools.inArray,
  extend: Tools.extend,
  create: Tools.create,
  walk: Tools.walk,
  createNS: Tools.createNS,
  resolve: Tools.resolve,
  explode: Tools.explode,
  _addCacheSuffix: Tools._addCacheSuffix,
  isOpera: Env.opera,
  isWebKit: Env.webkit,
  isIE: Env.ie,
  isGecko: Env.gecko,
  isMac: Env.mac
};
tinymce = Tools.extend(tinymce, publicApi);
var Tinymce = tinymce;

var exportToModuleLoaders = function (tinymce) {
  if (typeof module === &#39;object&#39;) {
    try {
      module.exports = tinymce;
    } catch (_) {
    }
  }
};
var exportToWindowGlobal = function (tinymce) {
  window.tinymce = tinymce;
  window.tinyMCE = tinymce;
};
exportToWindowGlobal(Tinymce);
exportToModuleLoaders(Tinymce);
</code></pre>

<p>}()); })();</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
    
    
    
  
</div>

    </div>
  </body>
</html>
